{
  "version": 3,
  "sources": ["../../@fhevm/mock-utils/constants.ts", "../../@fhevm/mock-utils/fhevm/relayer/index.ts", "../../@fhevm/mock-utils/fhevm/relayer/methods.ts", "../../@fhevm/mock-utils/utils/error.ts", "../../@fhevm/mock-utils/utils/runtime.ts", "../../@fhevm/mock-utils/ethers/provider.ts", "../../@fhevm/mock-utils/utils/string.ts", "../../@fhevm/mock-utils/utils/math.ts", "../../@fhevm/mock-utils/fhevm/FheType.ts", "../../@fhevm/mock-utils/fhevm/FhevmType.ts", "../../@fhevm/mock-utils/utils/address.ts", "../../@fhevm/mock-utils/fhevm/relayer/payloads.ts", "../../@fhevm/mock-utils/fhevm/relayer/mock_payloads.ts", "../../@fhevm/mock-utils/fhevm/relayer/MockRelayer.ts", "../../@fhevm/mock-utils/utils/index.ts", "../../@fhevm/mock-utils/utils/time.ts", "../../@fhevm/mock-utils/utils/keypair.ts", "../../@fhevm/mock-utils/fhevm/contracts/index.ts", "../../@fhevm/mock-utils/fhevm/contracts/FhevmContractWrapper.ts", "../../@fhevm/mock-utils/fhevm/contracts/interfaces/ACL.itf.ts", "../../@fhevm/mock-utils/fhevm/contracts/ACL.ts", "../../@fhevm/mock-utils/fhevm/contracts/interfaces/FHEVMExecutor.itf.ts", "../../@fhevm/mock-utils/fhevm/contracts/FHEVMExecutor.ts", "../../@fhevm/mock-utils/fhevm/contracts/interfaces/HCULimit.itf.ts", "../../@fhevm/mock-utils/fhevm/contracts/HCULimit.ts", "../../@fhevm/mock-utils/ethers/eip712.ts", "../../@fhevm/mock-utils/utils/bytes.ts", "../../@fhevm/mock-utils/utils/hex.ts", "../../@fhevm/mock-utils/fhevm/contracts/interfaces/InputVerifier.itf.ts", "../../@fhevm/mock-utils/fhevm/contracts/InputVerifier.ts", "../../@fhevm/mock-utils/fhevm/FhevmHandle.ts", "../../@fhevm/mock-utils/fhevm/contracts/interfaces/KMSVerifier.itf.ts", "../../@fhevm/mock-utils/fhevm/contracts/KMSVerifier.ts", "../../@fhevm/mock-utils/fhevm/contracts/ZamaFheDecryptionOracle.ts", "../../@fhevm/mock-utils/fhevm/contracts/FhevmContractsRepository.ts", "../../@fhevm/mock-utils/ethers/event.ts", "../../@fhevm/mock-utils/fhevm/db/utils.ts", "../../@fhevm/mock-utils/fhevm/db/FhevmDBMap.ts", "../../@fhevm/mock-utils/fhevm/FhevmHandleCoder.ts", "../../@fhevm/mock-utils/fhevm/coprocessor/CoprocessorEvents.ts", "../../@fhevm/mock-utils/fhevm/coprocessor/utils.ts", "../../@fhevm/mock-utils/ethers/anvil.ts", "../../@fhevm/mock-utils/ethers/hardhat.ts", "../../@fhevm/mock-utils/ethers/FhevmMockProvider.ts", "../../@fhevm/mock-utils/fhevm/coprocessor/CoprocessorEventsHandler.ts", "../../@fhevm/mock-utils/fhevm/coprocessor/CoprocessorEventsIterator.ts", "../../@fhevm/mock-utils/fhevm/coprocessor/MockCoprocessor.ts", "../../@fhevm/mock-utils/fhevm/decryptionOracle/DecryptionOracleEvents.ts", "../../@fhevm/mock-utils/fhevm/decryptionOracle/abi.ts", "../../@fhevm/mock-utils/fhevm/decryptionOracle/utils.ts", "../../@fhevm/mock-utils/fhevm/decryptionOracle/DecryptionOracleEventsHandler.ts", "../../@fhevm/mock-utils/fhevm/decryptionOracle/DecryptionOracleEventsIterator.ts", "../../@fhevm/mock-utils/fhevm/decryptionOracle/MockDecryptionOracle.ts", "../../@fhevm/mock-utils/relayer-sdk/sdk/keypair.ts", "../../@fhevm/mock-utils/fhevm/MockRelayerEncryptedInput.ts", "../../@fhevm/mock-utils/relayer-sdk/relayer/decryptUtils.ts", "../../@fhevm/mock-utils/relayer-sdk/relayer/publicDecrypt.ts", "../../@fhevm/mock-utils/relayer-sdk/relayer/userDecrypt.ts", "../../@fhevm/mock-utils/fhevm/MockFhevmInstance.ts", "../../@fhevm/mock-utils/fhevm/userDecrypt.ts", "../../@fhevm/mock-utils/ethers/storage.ts", "../../@fhevm/mock-utils/fhevm/CoprocessorConfig.ts", "../../@fhevm/mock-utils/_version.ts"],
  "sourcesContent": ["const constants = {\n  FHEVM_HANDLE_VERSION: 0,\n  DEFAULT_DURATION_DAYS: 365,\n  PUBLIC_DECRYPT_EIP712: {\n    domain: { version: \"1\", name: \"Decryption\" },\n    types: {\n      PublicDecryptVerification: [\n        {\n          name: \"ctHandles\",\n          type: \"bytes32[]\",\n        },\n        {\n          name: \"decryptedResult\",\n          type: \"bytes\",\n        },\n        {\n          name: \"extraData\",\n          type: \"bytes\",\n        },\n      ],\n    },\n  },\n  INPUT_VERIFICATION_EIP712: {\n    domain: { version: \"1\", name: \"InputVerification\" },\n    types: {\n      CiphertextVerification: [\n        {\n          name: \"ctHandles\",\n          type: \"bytes32[]\",\n        },\n        {\n          name: \"userAddress\",\n          type: \"address\",\n        },\n        {\n          name: \"contractAddress\",\n          type: \"address\",\n        },\n        {\n          name: \"contractChainId\",\n          type: \"uint256\",\n        },\n        {\n          name: \"extraData\",\n          type: \"bytes\",\n        },\n      ],\n    },\n  },\n  TEST_MNEMONIC: \"test test test test test test test future home encrypt virtual machine\",\n  DEFAULT_KMS_SIGNERS_ACCOUNTS: {\n    initialIndex: 0,\n    path: \"m/44'/60'/1'/0\",\n  },\n  DEFAULT_COPROCESSOR_SIGNERS_ACCOUNTS: {\n    initialIndex: 0,\n    path: \"m/44'/60'/2'/0\",\n  },\n  DEFAULT_RELAYER_SIGNERS_ACCOUNTS: {\n    initialIndex: 0,\n    path: \"m/44'/60'/3'/0\",\n  },\n  SEPOLIA_ETHEREUM_TESTNET_CHAINID: 11155111,\n  FHEVM_CORE_CONTRACTS_PACKAGE_NAME: \"@fhevm/core-contracts\",\n  ZAMA_FHE_ORACLE_SOLIDITY_PACKAGE_NAME: \"@zama-fhe/oracle-solidity\",\n};\nObject.freeze(constants);\n\nexport default constants;\n", "export {\n  RELAYER_METADATA,\n  RELAYER_V1_INPUT_PROOF,\n  RELAYER_V1_PUBLIC_DECRYPT,\n  RELAYER_V1_USER_DECRYPT,\n  FHEVM_AWAIT_DECRYPTION_ORACLE,\n  FHEVM_GET_CLEAR_TEXT,\n  FHEVM_CREATE_DECRYPTION_SIGNATURES,\n} from \"./methods.js\";\nexport {\n  requestRelayerMetadata,\n  requestRelayerV1InputProof,\n  requestRelayerV1PublicDecrypt,\n  requestRelayerV1UserDecrypt,\n  requestFhevmAwaitDecryptionOracle,\n  requestFhevmGetClearText,\n  requestFhevmCreateDecryptionSignatures,\n} from \"./MockRelayer.js\";\nexport type {\n  RelayerMetadata,\n  RelayerV1InputProofPayload,\n  RelayerV1InputProofResponse,\n  RelayerV1PublicDecryptPayload,\n  RelayerV1PublicDecryptResponse,\n  RelayerV1UserDecryptHandleContractPair,\n  RelayerV1UserDecryptPayload,\n  RelayerV1UserDecryptValidity,\n  RelayerV1UserDecryptResponse,\n} from \"./payloads.js\";\nexport {\n  assertIsRelayerV1PublicDecryptPayload,\n  assertIsRelayerV1PublicDecryptResponse,\n  assertIsRelayerV1UserDecryptPayload,\n  assertIsRelayerV1UserDecryptResponse,\n  assertIsRelayerMetadata,\n  assertIsRelayerV1InputProofResponse,\n} from \"./payloads.js\";\nexport type { MockRelayerData, MockRelayerV1InputProofPayload } from \"./mock_payloads.js\";\nexport { assertIsMockRelayerV1InputProofPayload } from \"./mock_payloads.js\";\n", "export const RELAYER_METADATA = \"fhevm_relayer_metadata\";\nexport const RELAYER_V1_PUBLIC_DECRYPT = \"fhevm_relayer_v1_public_decrypt\";\nexport const RELAYER_V1_USER_DECRYPT = \"fhevm_relayer_v1_user_decrypt\";\nexport const RELAYER_V1_INPUT_PROOF = \"fhevm_relayer_v1_input_proof\";\nexport const FHEVM_GET_CLEAR_TEXT = \"fhevm_getClearText\";\nexport const FHEVM_AWAIT_DECRYPTION_ORACLE = \"fhevm_awaitDecryptionOracle\";\nexport const FHEVM_CREATE_DECRYPTION_SIGNATURES = \"fhevm_createDecryptionSignatures\";\n", "export function assertFhevm(check: unknown, message?: string): asserts check {\n  if (!check) {\n    const title = \"Fhevm assertion failed\";\n    message = message ? title + \": \" + message : title;\n    throw new FhevmError(message);\n  }\n}\n\nexport function assertFhevmFailed(message?: string): never {\n  const title = \"Fhevm assertion failed\";\n  message = message ? title + \": \" + message : title;\n  throw new FhevmError(message);\n}\n\nexport function assertIsArray(value: unknown, valueName?: string): asserts value is string {\n  assertFhevm(Array.isArray(value), `${valueName ?? \"value\"} is not an array`);\n}\n\nexport function assertIsArrayProperty<K extends string>(\n  value: unknown,\n  propertyNames: K[],\n  typeName?: string,\n): asserts value is { [P in K]: any[] } {\n  if (typeof value !== \"object\" || value === null) {\n    throw new FhevmError(`${typeName} must be a non-null object.`);\n  }\n\n  for (const key of propertyNames) {\n    const prop = (value as any)[key];\n    if (prop === undefined || prop === null) {\n      throw new FhevmError(`Invalid ${typeName}. Missing '${key}' property.`);\n    }\n    if (!Array.isArray(prop)) {\n      throw new FhevmError(`Expected '${key}' in ${typeName} to be an array.`);\n    }\n  }\n}\n\nexport function assertUint8ArrayDeepEqual(a1: Uint8Array, a2: Uint8Array) {\n  assertFhevm(a1.length === a2.length, \"Arrays do not have the same length\");\n  for (let i = 0; i < a1.length; ++i) {\n    assertFhevm(a1[i] === a2[i], `Arrays are different. a1[${i}]=${a1[i]} !== a2[${i}]=${a2[i]}`);\n  }\n}\n\nexport function assertArrayOfUint8ArrayDeepEqual(a1: Uint8Array[], a2: Uint8Array[]) {\n  assertFhevm(a1.length === a2.length, \"Arrays do not have the same length\");\n  for (let i = 0; i < a1.length; ++i) {\n    assertUint8ArrayDeepEqual(a1[i], a2[i]);\n  }\n}\n\nexport function assertIsObjectProperty<K extends string>(\n  value: unknown,\n  propertyNames: K[],\n  typeName?: string,\n): asserts value is { [P in K]: any[] } {\n  if (typeof value !== \"object\" || value === null) {\n    throw new FhevmError(`${typeName} must be a non-null object.`);\n  }\n\n  for (const key of propertyNames) {\n    const prop = (value as any)[key];\n    if (prop === undefined || prop === null) {\n      throw new FhevmError(`Invalid ${typeName}. Missing '${key}' property.`);\n    }\n    if (typeof prop !== \"object\") {\n      throw new FhevmError(`Expected '${key}' in ${typeName} to be an object. Got ${typeof prop} instead.`);\n    }\n  }\n}\n\nexport class FhevmError extends Error {\n  //@ts-ignore\n  private readonly __isFhevmError;\n\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n    this.__isFhevmError = true;\n  }\n}\n\nexport function isHardhatProviderError(other: any): other is Error & { code: number } {\n  if (other === undefined || other === null) {\n    return false;\n  }\n  if (!(other instanceof Error)) {\n    return false;\n  }\n  if (!(\"code\" in other)) {\n    return false;\n  }\n  if (!(\"_isProviderError\" in other)) {\n    return false;\n  }\n  return other._isProviderError === true;\n}\n\nexport function isHardhatError(other: any): other is Error & { number: number } {\n  if (other === undefined || other === null) {\n    return false;\n  }\n  if (!(other instanceof Error)) {\n    return false;\n  }\n  if (!(\"number\" in other)) {\n    return false;\n  }\n  if (!(\"_isHardhatError\" in other)) {\n    return false;\n  }\n  return other._isHardhatError === true;\n}\n", "/**\n * Returns `true` if the Typescript code is running within a node process, `false` otherwise\n */\nexport function isNodeRuntime() {\n  return typeof process !== \"undefined\" && process.versions != null && process.versions.node != null;\n}\n\ndeclare var Bun: {\n  version: string;\n};\n\n/**\n * Returns `true` if the Typescript code is running within a bun process, `false` otherwise\n */\nexport function isBunRuntime() {\n  return typeof Bun !== \"undefined\";\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { FhevmError, isHardhatError, isHardhatProviderError } from \"../utils/error.js\";\nimport { isNodeRuntime } from \"../utils/runtime.js\";\n\nexport interface MinimalEthereumProvider {\n  send(method: string, params: any[]): Promise<any>;\n}\n\n/**\n * A minimal provider abstraction that represents any Ethereum-compatible provider\n * capable of sending JSON-RPC requests.\n *\n * This can be either:\n * - An EIP-1193-compliant provider (e.g., `ethers.Eip1193Provider`)\n * - A lower-level provider interface (e.g., `ethers.JsonRpcApiProvider`) that exposes a `send` method\n * - A custom provider interface (e.g. `HardhatEthersProvider`)\n *\n * Used to generalize RPC interactions without relying on full `ethers.js` provider features.\n */\nexport type MinimalProvider = MinimalEthereumProvider | EthersT.Eip1193Provider;\n\n/**\n * Sends a JSON-RPC request using a minimal Ethereum-compatible provider.\n *\n * This function abstracts over both `EIP-1193`-style providers (which implement `request({ method, params })`)\n * and legacy or lower-level providers (which implement `send(method, params)`), such as Hardhat or\n * custom ethers.js providers.\n *\n * It attempts to call `send()` first (commonly found in Hardhat or JsonRpcApiProvider), and falls back to\n * `request()` if `send` is not available.\n *\n * @param provider - A `MinimalProvider` that supports either `send` or `request` for RPC interaction.\n * @param method - The name of the JSON-RPC method to invoke (e.g. `\"eth_getBalance\"`).\n * @param params - An array of parameters to pass to the RPC method.\n * @returns A Promise resolving to the JSON-RPC result.\n *\n * @throws {FhevmError} If the provider does not implement a compatible RPC interface.\n */\nexport async function minimalProviderSend(provider: MinimalProvider, method: string, params: any[]) {\n  let response;\n\n  // Call send first otherwise call request.\n  // In case provider is a Hardhat provider, call via send.\n  if (\"send\" in provider && typeof provider.send === \"function\") {\n    response = await provider.send(method, params);\n  } else if (\"request\" in provider && typeof provider.request === \"function\") {\n    response = await provider.request({ method, params });\n  } else {\n    throw new FhevmError(\"Invalid provider: must implement request() or send()\");\n  }\n\n  return response;\n}\n\n/**\n * Retrieves the `chainId` from a given Ethereum provider.\n *\n * Attempts to query the provider using `eth_chainId`. If the provider is unreachable\n * (e.g., connection refused), the function returns `undefined`. For all other\n * unexpected failures (e.g., malformed response, internal provider error), the function throws.\n *\n * @param provider - A `MinimalProvider` that supports either `send` or `request` for RPC interaction.\n *\n * @returns A promise resolving to:\n * - The `chainId` as a number if the provider is reachable and responds correctly.\n * - `undefined` if the provider is unreachable (network failure).\n *\n * @throws If the provider responds unexpectedly or fails.\n */\nexport async function connectedChainId(provider: MinimalProvider): Promise<number | undefined> {\n  try {\n    return await getProviderChainId(provider);\n  } catch (e) {\n    if (isHardhatProviderError(e)) {\n      // RPC method not supported\n      if (e.code === -32004) {\n        throw e;\n      }\n    } else if (isHardhatError(e)) {\n      // HH only: cannot connect to specified network\n      if (e.number === 108) {\n        return undefined;\n      }\n    } else if (isNodeRuntime()) {\n      if (e instanceof Error && \"code\" in e) {\n        // Connection refused, this error can only be catched from a node runtime\n        if (e.code === \"ECONNREFUSED\") {\n          return undefined;\n        }\n      }\n    }\n\n    // Propagate the error\n    throw e;\n  }\n}\n\n/**\n * Retrieves the `chainId` from a given Ethereum provider using `eth_chainId` RPC call.\n * @param provider - A `MinimalProvider` that supports either `send` or `request` for RPC interaction.\n * @returns A promise that resolves to the chain ID as a number.\n */\nexport async function getProviderChainId(provider: MinimalProvider): Promise<number | undefined> {\n  const chainIdHex = await minimalProviderSend(provider, \"eth_chainId\", []);\n  return Number(BigInt(chainIdHex));\n}\n\n/**\n * Retrieves the web3 client version from a given Ethereum provider.\n *\n * @returns A promise that resolves to one of the following:\n * - `{ client: any, couldNotConnect: false }` if the provider is reachable web3 client.\n * - `{ client: undefined, couldNotConnect: false }` if the provider is reachable but is not a valid web3 client.\n * - `{ client: undefined, couldNotConnect: true }` if the provider is unreachable.\n *\n * @throws If the provider fails in an unexpected way the function will propagate the error.\n */\nexport async function connectedWeb3Client(\n  provider: MinimalProvider,\n): Promise<{ client: any; couldNotConnect: boolean }> {\n  try {\n    return { client: await getWeb3ClientVersion(provider), couldNotConnect: false };\n  } catch (e) {\n    if (isHardhatProviderError(e)) {\n      // RPC method not supported\n      if (e.code === -32004) {\n        return { client: undefined, couldNotConnect: false };\n      }\n    } else if (isHardhatError(e)) {\n      // HH only: cannot connect to specified network\n      if (e.number === 108) {\n        return { client: undefined, couldNotConnect: true };\n      }\n    } else if (isNodeRuntime()) {\n      if (e instanceof Error && \"code\" in e) {\n        // Connection refused, this error can only be catched from a node runtime\n        if (e.code === \"ECONNREFUSED\") {\n          return { client: undefined, couldNotConnect: true };\n        }\n      }\n    }\n\n    // Propagate the error\n    throw e;\n  }\n}\n\n/**\n * Executes the `web3_clientVersion` RPC call on a given provider.\n * @param provider - A `MinimalProvider` that supports either `send` or `request` for RPC interaction.\n * @returns A promise that resolves to the RPC call response.\n */\nexport async function getWeb3ClientVersion(provider: MinimalProvider) {\n  return minimalProviderSend(provider, \"web3_clientVersion\", []);\n}\n\n// Not used\nexport async function getSignerChainId(signer: EthersT.Signer): Promise<number> {\n  const provider = signer.provider;\n  if (!provider) {\n    throw new FhevmError(\"Unable to determine signer provider\");\n  }\n\n  const network = await provider.getNetwork();\n\n  return Number(network.chainId);\n}\n\nexport function canSign(obj: any): boolean {\n  if (!obj) {\n    throw new FhevmError(`Invalid argument`);\n  }\n  const isDirectSigner = typeof obj.signTransaction === \"function\";\n  const canProduceSigner = typeof obj.getSigner === \"function\";\n  return isDirectSigner || canProduceSigner;\n}\n\nexport function isReadonlyContract(contract: EthersT.BaseContract): boolean {\n  return !canSign(contract.runner);\n}\n\nexport function isReadonlyProvider(obj: any): obj is EthersT.Provider {\n  if (!obj) {\n    throw new FhevmError(`Invalid argument`);\n  }\n  return (\n    !canSign(obj) &&\n    typeof obj.estimateGas === \"function\" &&\n    typeof obj.call === \"function\" &&\n    typeof obj.getBlock === \"function\" &&\n    typeof obj.getNetwork === \"function\" &&\n    typeof obj.getCode === \"function\"\n  );\n}\n", "import { FhevmError, assertFhevm } from \"./error.js\";\n\nexport function removePrefix(s: string, prefix: string): string {\n  return s.startsWith(prefix) ? s.substring(prefix.length) : s;\n}\n\nexport function removeSuffix(s: string, suffix: string): string {\n  return s.endsWith(suffix) ? s.substring(0, s.length - suffix.length) : s;\n}\n\nexport function ensure0x(s: string): `0x${string}` {\n  return !s.startsWith(\"0x\") ? `0x${s}` : (s as `0x${string}`);\n}\n\nexport function remove0x(s: string): string {\n  return s.startsWith(\"0x\") ? s.substring(2) : s;\n}\n\nexport function ensurePrefix(s: string, prefix: string): string {\n  return !s.startsWith(prefix) ? prefix + s : s;\n}\n\nexport function ensureSuffix(s: string, suffix: string): string {\n  return !s.endsWith(suffix) ? s + suffix : s;\n}\n\nexport function assertIsString(value: unknown, valueName?: string): asserts value is string {\n  assertFhevm(typeof value === \"string\", `${valueName ?? \"value\"} is not of type string, got ${typeof value} instead`);\n}\n\nexport function assertIsStringArray(value: unknown, valueName?: string): asserts value is string[] {\n  if (!Array.isArray(value)) {\n    throw new FhevmError(`${valueName ?? \"value\"} is not an array of string`);\n  }\n  for (let i = 0; i < value.length; ++i) {\n    assertFhevm(\n      typeof value[i] === \"string\",\n      `${valueName ?? \"value\"}[${i}] is not of type string, got ${typeof value[i]} instead`,\n    );\n  }\n}\n\nexport function assertIsStringProperty<K extends string>(\n  value: unknown,\n  propertyNames: K[],\n  typeName?: string,\n): asserts value is { [P in K]: string } {\n  if (typeof value !== \"object\" || value === null) {\n    throw new FhevmError(`${typeName} must be a non-null object.`);\n  }\n\n  for (const key of propertyNames) {\n    const prop = (value as any)[key];\n    if (typeof prop !== \"string\") {\n      throw new FhevmError(`Expected '${key}' in ${typeName} to be a string, but got ${typeof prop} instead.`);\n    }\n  }\n}\n\nexport function assertIsStringArrayProperty<K extends string>(\n  value: unknown,\n  propertyNames: K[],\n  typeName?: string,\n): asserts value is { [P in K]: string[] } {\n  if (typeof value !== \"object\" || value === null) {\n    throw new FhevmError(`${typeName} must be a non-null object.`);\n  }\n\n  for (const key of propertyNames) {\n    const prop = (value as any)[key];\n    assertIsStringArray(prop, ` ${typeName}.${key}`);\n  }\n}\n\nexport function toLowerCaseSet(array: string[]): Set<string> {\n  const s = new Set<string>();\n  for (let i = 0; i < array.length; ++i) {\n    const item = array[i];\n    if (item) {\n      s.add(item.toLowerCase());\n    }\n  }\n  return s;\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { FhevmError, assertFhevm } from \"./error.js\";\n\nexport const MAX_UINT8 = 0xffn;\nexport const MAX_UINT16 = 0xffffn;\nexport const MAX_UINT32 = 0xffffffffn;\nexport const MAX_UINT64 = 0xffffffffffffffffn;\nexport const MAX_UINT128 = 0xffffffffffffffffffffffffffffffffn;\nexport const MAX_UINT160 = 0xffffffffffffffffffffffffffffffffffffffffn;\nexport const MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn;\nexport const MAX_UINT512 =\n  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn;\n\nexport function toUIntNumber(value: EthersT.BigNumberish, name?: string): number {\n  try {\n    const bn = EthersT.getUint(value, name);\n    return EthersT.getNumber(bn);\n  } catch {\n    throw new FhevmError(`${name} is not a positive integer`);\n  }\n}\n\nexport function isInt(value: unknown): value is EthersT.Numeric {\n  if (typeof value === \"bigint\") {\n    return true;\n  }\n  if (typeof value === \"number\") {\n    return Number.isInteger(value);\n  }\n  return false;\n}\n\nexport function isUInt(value: unknown): value is EthersT.Numeric {\n  if (!isInt(value)) {\n    return false;\n  }\n  return (value as EthersT.Numeric) >= 0;\n}\n\nexport function isEvenUInt(value: unknown): value is EthersT.Numeric {\n  if (!isUInt(value)) {\n    return false;\n  }\n  return typeof value === \"bigint\" ? value % 2n === 0n : value % 2 === 0;\n}\n\nexport function boolToBigInt(value: EthersT.Numeric | boolean): 0n | 1n {\n  if (value === null || value === undefined) {\n    throw new FhevmError(\"Missing value\");\n  }\n\n  let zeroOrOne: 0n | 1n = 0n;\n\n  // Must be 0 or 1\n  if (typeof value === \"bigint\") {\n    if (value !== 1n && value !== 0n) {\n      throw new FhevmError(\"The value must be 1 or 0.\");\n    }\n    zeroOrOne = value;\n  } else if (typeof value === \"number\") {\n    if (value !== 1 && value !== 0) {\n      throw new FhevmError(\"The value must be 1 or 0.\");\n    }\n    zeroOrOne = value === 0 ? 0n : 1n;\n  } else if (typeof value === \"boolean\") {\n    zeroOrOne = value === true ? 1n : 0n;\n  } else {\n    throw new FhevmError(\"The value must be a boolean, a number or a bigint.\");\n  }\n\n  return zeroOrOne;\n}\n\nexport function bitwiseNotUIntBits(value: bigint, numBits: number | bigint) {\n  if (typeof value !== \"bigint\") {\n    throw new FhevmError(\"The input value must be a BigInt.\");\n  }\n  if (!isUInt(numBits)) {\n    throw new FhevmError(\"The numBits parameter must be a positive integer.\");\n  }\n  // Create the mask with numBits bits set to 1\n  const BIT_MASK = (BigInt(1) << BigInt(numBits)) - BigInt(1);\n  return ~value & BIT_MASK;\n}\n\nexport function getMaxBigInt(bitLength: number): bigint {\n  if (!isUInt(bitLength)) {\n    throw new FhevmError(`Invalid bitLength argument (${bitLength}), expecting a positive integer value.`);\n  }\n\n  return (1n << BigInt(bitLength)) - 1n;\n}\n\nexport function log2BigInt(x: bigint): bigint {\n  const n = x.toString(2).length - 1;\n  return x <= 0n ? 0n : BigInt(n);\n}\n\nexport function getRandomBigInt(numBits: number): bigint {\n  if (numBits <= 0) {\n    throw new TypeError(\"Number of bits must be greater than 0\");\n  }\n\n  const numBytes = Math.ceil(numBits / 8);\n  const randomBytes = EthersT.randomBytes(numBytes);\n\n  let randomBigInt = BigInt(0);\n  for (let i = 0; i < numBytes; i++) {\n    randomBigInt = (randomBigInt << BigInt(8)) | BigInt(randomBytes[i]);\n  }\n\n  const mask = (BigInt(1) << BigInt(numBits)) - BigInt(1);\n  randomBigInt = randomBigInt & mask;\n\n  return randomBigInt;\n}\n\nexport function assertIsUintNumber(value: unknown, valueName?: string): asserts value is number {\n  assertFhevm(typeof value === \"number\", `${valueName ?? \"value\"} is not of type number, got ${typeof value} instead`);\n  assertFhevm(isUInt(value), `${valueName ?? \"value\"} is not an uint, got ${typeof value} instead`);\n}\n\n/*\n\n  BigInt assertions\n\n*/\n\nexport function assertIsBigUint8(value: unknown, valueName?: string): asserts value is bigint {\n  _assertIsBigUint(value, 8, MAX_UINT8, valueName);\n}\nexport function assertIsBigUint16(value: unknown, valueName?: string): asserts value is bigint {\n  _assertIsBigUint(value, 16, MAX_UINT16, valueName);\n}\nexport function assertIsBigUint32(value: unknown, valueName?: string): asserts value is bigint {\n  _assertIsBigUint(value, 32, MAX_UINT32, valueName);\n}\nexport function assertIsBigUint64(value: unknown, valueName?: string): asserts value is bigint {\n  _assertIsBigUint(value, 64, MAX_UINT64, valueName);\n}\nexport function assertIsBigUint128(value: unknown, valueName?: string): asserts value is bigint {\n  _assertIsBigUint(value, 128, MAX_UINT128, valueName);\n}\nexport function assertIsBigUint160(value: unknown, valueName?: string): asserts value is bigint {\n  _assertIsBigUint(value, 128, MAX_UINT160, valueName);\n}\nexport function assertIsBigUint256(value: unknown, valueName?: string): asserts value is bigint {\n  _assertIsBigUint(value, 256, MAX_UINT256, valueName);\n}\nexport function assertIsBigUint512(value: unknown, valueName?: string): asserts value is bigint {\n  _assertIsBigUint(value, 512, MAX_UINT512, valueName);\n}\nexport function assertIsBigUint1024(value: unknown, valueName?: string): asserts value is bigint {\n  _assertIsBigUint(value, 1024, getMaxBigInt(1024), valueName);\n}\nexport function assertIsBigUint2048(value: unknown, valueName?: string): asserts value is bigint {\n  _assertIsBigUint(value, 2048, getMaxBigInt(2048), valueName);\n}\n\nfunction _assertIsBigUint(\n  value: unknown,\n  bitLen: 8 | 16 | 32 | 64 | 128 | 256 | 512 | 1024 | 2048,\n  max: bigint,\n  valueName?: string,\n): asserts value is bigint {\n  assertFhevm(typeof value === \"bigint\", `${valueName ?? \"value\"} is not of type bigint, got ${typeof value} instead`);\n  assertFhevm(\n    value >= 0 && value <= max,\n    `${valueName ?? \"value\"} is larger than uint${bitLen} maximum value, got ${value} > ${max}`,\n  );\n}\n\nexport function assertIsBoolean(value: unknown, valueName?: string): asserts value is boolean {\n  assertFhevm(\n    typeof value === \"boolean\",\n    `${valueName ?? \"value\"} is not of type boolean, got ${typeof value} instead`,\n  );\n}\n\nexport function assertIsNumber(value: unknown, valueName?: string): asserts value is boolean {\n  assertFhevm(typeof value === \"number\", `${valueName ?? \"value\"} is not of type number, got ${typeof value} instead`);\n}\n", "import { FhevmError } from \"../utils/error.js\";\nimport { isUInt } from \"../utils/math.js\";\n\nexport interface FheTypeInfo {\n  type: string;\n  supportedOperators: string[];\n  bitLength: number;\n  clearMatchingType: string;\n  value: number;\n  aliases?: AliasFheType[];\n}\n\nexport interface AliasFheType {\n  type: string;\n  supportedOperators: string[];\n  clearMatchingType: string;\n}\n\nexport enum FheType {\n  Bool = 0,\n  Uint4 = 1,\n  Uint8 = 2,\n  Uint16 = 3,\n  Uint32 = 4,\n  Uint64 = 5,\n  Uint128 = 6,\n  Uint160 = 7,\n  Uint256 = 8,\n  Uint512 = 9,\n  Uint1024 = 10,\n  Uint2048 = 11,\n  Uint2 = 12,\n  Uint6 = 13,\n  Uint10 = 14,\n  Uint12 = 15,\n  Uint14 = 16,\n  Int2 = 17,\n  Int4 = 18,\n  Int6 = 19,\n  Int8 = 20,\n  Int10 = 21,\n  Int12 = 22,\n  Int14 = 23,\n  Int16 = 24,\n  Int32 = 25,\n  Int64 = 26,\n  Int128 = 27,\n  Int160 = 28,\n  Int256 = 29,\n  AsciiString = 30,\n  Int512 = 31,\n  Int1024 = 32,\n  Int2048 = 33,\n  Uint24 = 34,\n  Uint40 = 35,\n  Uint48 = 36,\n  Uint56 = 37,\n  Uint72 = 38,\n  Uint80 = 39,\n  Uint88 = 40,\n  Uint96 = 41,\n  Uint104 = 42,\n  Uint112 = 43,\n  Uint120 = 44,\n  Uint136 = 45,\n  Uint144 = 46,\n  Uint152 = 47,\n  Uint168 = 48,\n  Uint176 = 49,\n  Uint184 = 50,\n  Uint192 = 51,\n  Uint200 = 52,\n  Uint208 = 53,\n  Uint216 = 54,\n  Uint224 = 55,\n  Uint232 = 56,\n  Uint240 = 57,\n  Uint248 = 58,\n  Int24 = 59,\n  Int40 = 60,\n  Int48 = 61,\n  Int56 = 62,\n  Int72 = 63,\n  Int80 = 64,\n  Int88 = 65,\n  Int96 = 66,\n  Int104 = 67,\n  Int112 = 68,\n  Int120 = 69,\n  Int136 = 70,\n  Int144 = 71,\n  Int152 = 72,\n  Int168 = 73,\n  Int176 = 74,\n  Int184 = 75,\n  Int192 = 76,\n  Int200 = 77,\n  Int208 = 78,\n  Int216 = 79,\n  Int224 = 80,\n  Int232 = 81,\n  Int240 = 82,\n  Int248 = 83,\n}\n\n/**\n * A constant array containing all Fully Homomorphic Encryption (FHE) types.\n * Each type is represented as an object with the following properties:\n *\n * - `type`: The name of the FHE type.\n * - `value`: A unique numeric identifier for the FHE type.\n * - `supportedOperators`: An array of strings representing the operators supported by the FHE type.\n * - `bitLength`: The bit length of the FHE type.\n * - `clearMatchingType`: The corresponding clear (non-encrypted) type in Solidity.\n * - `aliases`: An optional array of alias types that are associated with this FHE type.\n *\n * The FHE types included that are currently implemented in the Solidity code generator are:\n *\n * - `Bool`: Boolean type with a bit length of 1.\n * - `Uint8`: Unsigned integer type with a bit length of 8.\n * - `Uint16`: Unsigned integer type with a bit length of 16.\n * - `Uint32`: Unsigned integer type with a bit length of 32.\n * - `Uint64`: Unsigned integer type with a bit length of 64.\n * - `Uint128`: Unsigned integer type with a bit length of 128.\n * - `Uint160`: Unsigned integer type with a bit length of 160.\n * - `Uint256`: Unsigned integer type with a bit length of 256.\n * - `Uint512`: Unsigned integer type with a bit length of 512.\n * - `Uint1024`: Unsigned integer type with a bit length of 1024.\n * - `Uint2048`: Unsigned integer type with a bit length of 2048.\n */\nexport const ALL_FHE_TYPES: FheTypeInfo[] = [\n  {\n    type: \"Bool\",\n    value: 0,\n    supportedOperators: [\"and\", \"or\", \"xor\", \"eq\", \"ne\", \"not\", \"select\", \"rand\"],\n    bitLength: 2,\n    clearMatchingType: \"bool\",\n  },\n  {\n    type: \"Uint4\",\n    value: 1,\n    supportedOperators: [],\n    bitLength: 4,\n    clearMatchingType: \"uint8\",\n  },\n  {\n    type: \"Uint8\",\n    value: 2,\n    supportedOperators: [\n      \"add\",\n      \"sub\",\n      \"mul\",\n      \"div\",\n      \"rem\",\n      \"and\",\n      \"or\",\n      \"xor\",\n      \"shl\",\n      \"shr\",\n      \"rotl\",\n      \"rotr\",\n      \"eq\",\n      \"ne\",\n      \"ge\",\n      \"gt\",\n      \"le\",\n      \"lt\",\n      \"min\",\n      \"max\",\n      \"neg\",\n      \"not\",\n      \"select\",\n      \"rand\",\n      \"randBounded\",\n    ],\n    bitLength: 8,\n    clearMatchingType: \"uint8\",\n    aliases: [\n      {\n        type: \"Bytes1\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes1\",\n      },\n    ],\n  },\n  {\n    type: \"Uint16\",\n    value: 3,\n    supportedOperators: [\n      \"add\",\n      \"sub\",\n      \"mul\",\n      \"div\",\n      \"rem\",\n      \"and\",\n      \"or\",\n      \"xor\",\n      \"shl\",\n      \"shr\",\n      \"rotl\",\n      \"rotr\",\n      \"eq\",\n      \"ne\",\n      \"ge\",\n      \"gt\",\n      \"le\",\n      \"lt\",\n      \"min\",\n      \"max\",\n      \"neg\",\n      \"not\",\n      \"select\",\n      \"rand\",\n      \"randBounded\",\n    ],\n    bitLength: 16,\n    clearMatchingType: \"uint16\",\n    aliases: [\n      {\n        type: \"Bytes2\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes2\",\n      },\n    ],\n  },\n  {\n    type: \"Uint32\",\n    value: 4,\n    supportedOperators: [\n      \"add\",\n      \"sub\",\n      \"mul\",\n      \"div\",\n      \"rem\",\n      \"and\",\n      \"or\",\n      \"xor\",\n      \"shl\",\n      \"shr\",\n      \"rotl\",\n      \"rotr\",\n      \"eq\",\n      \"ne\",\n      \"ge\",\n      \"gt\",\n      \"le\",\n      \"lt\",\n      \"min\",\n      \"max\",\n      \"neg\",\n      \"not\",\n      \"select\",\n      \"rand\",\n      \"randBounded\",\n    ],\n    bitLength: 32,\n    clearMatchingType: \"uint32\",\n    aliases: [\n      {\n        type: \"Bytes4\",\n        supportedOperators: [],\n        clearMatchingType: \"\",\n      },\n    ],\n  },\n  {\n    type: \"Uint64\",\n    value: 5,\n    supportedOperators: [\n      \"add\",\n      \"sub\",\n      \"mul\",\n      \"div\",\n      \"rem\",\n      \"and\",\n      \"or\",\n      \"xor\",\n      \"shl\",\n      \"shr\",\n      \"rotl\",\n      \"rotr\",\n      \"eq\",\n      \"ne\",\n      \"ge\",\n      \"gt\",\n      \"le\",\n      \"lt\",\n      \"min\",\n      \"max\",\n      \"neg\",\n      \"not\",\n      \"select\",\n      \"rand\",\n      \"randBounded\",\n    ],\n    bitLength: 64,\n    clearMatchingType: \"uint64\",\n    aliases: [\n      {\n        type: \"Bytes8\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes8\",\n      },\n    ],\n  },\n  {\n    type: \"Uint128\",\n    value: 6,\n    supportedOperators: [\n      \"add\",\n      \"sub\",\n      \"mul\",\n      \"div\",\n      \"rem\",\n      \"and\",\n      \"or\",\n      \"xor\",\n      \"shl\",\n      \"shr\",\n      \"rotl\",\n      \"rotr\",\n      \"eq\",\n      \"ne\",\n      \"ge\",\n      \"gt\",\n      \"le\",\n      \"lt\",\n      \"min\",\n      \"max\",\n      \"neg\",\n      \"not\",\n      \"select\",\n      \"rand\",\n      \"randBounded\",\n    ],\n    bitLength: 128,\n    clearMatchingType: \"uint128\",\n    aliases: [\n      {\n        type: \"Bytes16\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes16\",\n      },\n    ],\n  },\n  {\n    type: \"Uint160\",\n    value: 7,\n    supportedOperators: [],\n    bitLength: 160,\n    clearMatchingType: \"uint160\",\n    aliases: [\n      {\n        type: \"Address\",\n        supportedOperators: [\"eq\", \"ne\", \"select\"],\n        clearMatchingType: \"address\",\n      },\n      {\n        type: \"Bytes20\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes20\",\n      },\n    ],\n  },\n  {\n    type: \"Uint256\",\n    value: 8,\n    supportedOperators: [\n      \"and\",\n      \"or\",\n      \"xor\",\n      \"shl\",\n      \"shr\",\n      \"rotl\",\n      \"rotr\",\n      \"eq\",\n      \"ne\",\n      \"neg\",\n      \"not\",\n      \"select\",\n      \"rand\",\n      \"randBounded\",\n    ],\n    bitLength: 256,\n    clearMatchingType: \"uint256\",\n    aliases: [\n      {\n        type: \"Bytes32\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes32\",\n      },\n    ],\n  },\n  {\n    type: \"Uint512\",\n    value: 9,\n    supportedOperators: [],\n    bitLength: 512,\n    clearMatchingType: \"bytes memory\",\n    aliases: [\n      {\n        type: \"Bytes64\",\n        supportedOperators: [\"eq\", \"ne\", \"select\", \"rand\"],\n        clearMatchingType: \"\",\n      },\n    ],\n  },\n  {\n    type: \"Uint1024\",\n    value: 10,\n    supportedOperators: [],\n    bitLength: 1024,\n    clearMatchingType: \"bytes memory\",\n    aliases: [\n      {\n        type: \"Bytes128\",\n        supportedOperators: [\"eq\", \"ne\", \"select\", \"rand\"],\n        clearMatchingType: \"\",\n      },\n    ],\n  },\n  {\n    type: \"Uint2048\",\n    value: 11,\n    supportedOperators: [],\n    bitLength: 2048,\n    clearMatchingType: \"bytes memory\",\n    aliases: [\n      {\n        type: \"Bytes256\",\n        supportedOperators: [\"eq\", \"ne\", \"select\", \"rand\"],\n        clearMatchingType: \"\",\n      },\n    ],\n  },\n  {\n    type: \"Uint2\",\n    value: 12,\n    supportedOperators: [],\n    bitLength: 2,\n    clearMatchingType: \"uint8\",\n  },\n  {\n    type: \"Uint6\",\n    value: 13,\n    supportedOperators: [],\n    bitLength: 6,\n    clearMatchingType: \"uint8\",\n  },\n  {\n    type: \"Uint10\",\n    value: 14,\n    supportedOperators: [],\n    bitLength: 10,\n    clearMatchingType: \"uint16\",\n  },\n  {\n    type: \"Uint12\",\n    value: 15,\n    supportedOperators: [],\n    bitLength: 12,\n    clearMatchingType: \"uint16\",\n  },\n  {\n    type: \"Uint14\",\n    value: 16,\n    supportedOperators: [],\n    bitLength: 14,\n    clearMatchingType: \"uint16\",\n  },\n  {\n    type: \"Int2\",\n    value: 17,\n    supportedOperators: [],\n    bitLength: 2,\n    clearMatchingType: \"int8\",\n  },\n  {\n    type: \"Int4\",\n    value: 18,\n    supportedOperators: [],\n    bitLength: 4,\n    clearMatchingType: \"int8\",\n  },\n  {\n    type: \"Int6\",\n    value: 19,\n    supportedOperators: [],\n    bitLength: 6,\n    clearMatchingType: \"int8\",\n  },\n  {\n    type: \"Int8\",\n    value: 20,\n    supportedOperators: [],\n    bitLength: 8,\n    clearMatchingType: \"int8\",\n  },\n  {\n    type: \"Int10\",\n    value: 21,\n    supportedOperators: [],\n    bitLength: 10,\n    clearMatchingType: \"int16\",\n  },\n  {\n    type: \"Int12\",\n    value: 22,\n    supportedOperators: [],\n    bitLength: 12,\n    clearMatchingType: \"int16\",\n  },\n  {\n    type: \"Int14\",\n    value: 23,\n    supportedOperators: [],\n    bitLength: 14,\n    clearMatchingType: \"int16\",\n  },\n  {\n    type: \"Int16\",\n    value: 24,\n    supportedOperators: [],\n    bitLength: 16,\n    clearMatchingType: \"int16\",\n  },\n  {\n    type: \"Int32\",\n    value: 25,\n    supportedOperators: [],\n    bitLength: 32,\n    clearMatchingType: \"int32\",\n  },\n  {\n    type: \"Int64\",\n    value: 26,\n    supportedOperators: [],\n    bitLength: 64,\n    clearMatchingType: \"int64\",\n  },\n  {\n    type: \"Int128\",\n    value: 27,\n    supportedOperators: [],\n    bitLength: 128,\n    clearMatchingType: \"int128\",\n  },\n  {\n    type: \"Int160\",\n    value: 28,\n    supportedOperators: [],\n    bitLength: 160,\n    clearMatchingType: \"int160\",\n  },\n  {\n    type: \"Int256\",\n    value: 29,\n    supportedOperators: [],\n    bitLength: 256,\n    clearMatchingType: \"int256\",\n  },\n  {\n    type: \"AsciiString\",\n    value: 30,\n    supportedOperators: [],\n    bitLength: 0,\n    clearMatchingType: \"string memory\",\n  },\n  {\n    type: \"Int512\",\n    value: 31,\n    supportedOperators: [],\n    bitLength: 512,\n    clearMatchingType: \"bytes memory\",\n  },\n  {\n    type: \"Int1024\",\n    value: 32,\n    supportedOperators: [],\n    bitLength: 1024,\n    clearMatchingType: \"bytes memory\",\n  },\n  {\n    type: \"Int2048\",\n    value: 33,\n    supportedOperators: [],\n    bitLength: 2048,\n    clearMatchingType: \"bytes memory\",\n  },\n  {\n    type: \"Uint24\",\n    value: 34,\n    supportedOperators: [],\n    bitLength: 24,\n    clearMatchingType: \"uint24\",\n    aliases: [\n      {\n        type: \"Bytes3\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes3\",\n      },\n    ],\n  },\n  {\n    type: \"Uint40\",\n    value: 35,\n    supportedOperators: [],\n    bitLength: 40,\n    clearMatchingType: \"uint40\",\n    aliases: [\n      {\n        type: \"Bytes5\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes5\",\n      },\n    ],\n  },\n  {\n    type: \"Uint48\",\n    value: 36,\n    supportedOperators: [],\n    bitLength: 48,\n    clearMatchingType: \"uint48\",\n    aliases: [\n      {\n        type: \"Bytes6\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes6\",\n      },\n    ],\n  },\n  {\n    type: \"Uint56\",\n    value: 37,\n    supportedOperators: [],\n    bitLength: 56,\n    clearMatchingType: \"uint56\",\n    aliases: [\n      {\n        type: \"Bytes7\",\n        supportedOperators: [],\n        clearMatchingType: \"\",\n      },\n    ],\n  },\n  {\n    type: \"Uint72\",\n    value: 38,\n    supportedOperators: [],\n    bitLength: 72,\n    clearMatchingType: \"uint72\",\n    aliases: [\n      {\n        type: \"Bytes9\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes9\",\n      },\n    ],\n  },\n  {\n    type: \"Uint80\",\n    value: 39,\n    supportedOperators: [],\n    bitLength: 80,\n    clearMatchingType: \"uint80\",\n    aliases: [\n      {\n        type: \"Bytes10\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes10\",\n      },\n    ],\n  },\n  {\n    type: \"Uint88\",\n    value: 40,\n    supportedOperators: [],\n    bitLength: 88,\n    clearMatchingType: \"uint88\",\n    aliases: [\n      {\n        type: \"Bytes11\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes11\",\n      },\n    ],\n  },\n  {\n    type: \"Uint96\",\n    value: 41,\n    supportedOperators: [],\n    bitLength: 96,\n    clearMatchingType: \"uint96\",\n    aliases: [\n      {\n        type: \"Bytes12\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes12\",\n      },\n    ],\n  },\n  {\n    type: \"Uint104\",\n    value: 42,\n    supportedOperators: [],\n    bitLength: 104,\n    clearMatchingType: \"uint104\",\n    aliases: [\n      {\n        type: \"Bytes13\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes13\",\n      },\n    ],\n  },\n  {\n    type: \"Uint112\",\n    value: 43,\n    supportedOperators: [],\n    bitLength: 112,\n    clearMatchingType: \"uint112\",\n    aliases: [\n      {\n        type: \"Bytes14\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes14\",\n      },\n    ],\n  },\n  {\n    type: \"Uint120\",\n    value: 44,\n    supportedOperators: [],\n    bitLength: 120,\n    clearMatchingType: \"uint120\",\n    aliases: [\n      {\n        type: \"Bytes15\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes15\",\n      },\n    ],\n  },\n  {\n    type: \"Uint136\",\n    value: 45,\n    supportedOperators: [],\n    bitLength: 136,\n    clearMatchingType: \"uint136\",\n    aliases: [\n      {\n        type: \"Bytes17\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes17\",\n      },\n    ],\n  },\n  {\n    type: \"Uint144\",\n    value: 46,\n    supportedOperators: [],\n    bitLength: 144,\n    clearMatchingType: \"uint144\",\n    aliases: [\n      {\n        type: \"Bytes18\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes18\",\n      },\n    ],\n  },\n  {\n    type: \"Uint152\",\n    value: 47,\n    supportedOperators: [],\n    bitLength: 152,\n    clearMatchingType: \"uint152\",\n    aliases: [\n      {\n        type: \"Bytes19\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes19\",\n      },\n    ],\n  },\n  {\n    type: \"Uint168\",\n    value: 48,\n    supportedOperators: [],\n    bitLength: 168,\n    clearMatchingType: \"uint168\",\n    aliases: [\n      {\n        type: \"Bytes21\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes21\",\n      },\n    ],\n  },\n  {\n    type: \"Uint176\",\n    value: 49,\n    supportedOperators: [],\n    bitLength: 176,\n    clearMatchingType: \"uint176\",\n    aliases: [\n      {\n        type: \"Bytes22\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes22\",\n      },\n    ],\n  },\n  {\n    type: \"Uint184\",\n    value: 50,\n    supportedOperators: [],\n    bitLength: 184,\n    clearMatchingType: \"uint184\",\n    aliases: [\n      {\n        type: \"Bytes23\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes23\",\n      },\n    ],\n  },\n  {\n    type: \"Uint192\",\n    value: 51,\n    supportedOperators: [],\n    bitLength: 192,\n    clearMatchingType: \"uint192\",\n    aliases: [\n      {\n        type: \"Bytes24\",\n        supportedOperators: [],\n        clearMatchingType: \"24\",\n      },\n    ],\n  },\n  {\n    type: \"Uint200\",\n    value: 52,\n    supportedOperators: [],\n    bitLength: 200,\n    clearMatchingType: \"uint200\",\n    aliases: [\n      {\n        type: \"Bytes25\",\n        supportedOperators: [],\n        clearMatchingType: \"25\",\n      },\n    ],\n  },\n  {\n    type: \"Uint208\",\n    value: 53,\n    supportedOperators: [],\n    bitLength: 208,\n    clearMatchingType: \"uint208\",\n    aliases: [\n      {\n        type: \"Bytes26\",\n        supportedOperators: [],\n        clearMatchingType: \"26\",\n      },\n    ],\n  },\n  {\n    type: \"Uint216\",\n    value: 54,\n    supportedOperators: [],\n    bitLength: 216,\n    clearMatchingType: \"uint216\",\n    aliases: [\n      {\n        type: \"Bytes27\",\n        supportedOperators: [],\n        clearMatchingType: \"27\",\n      },\n    ],\n  },\n  {\n    type: \"Uint224\",\n    value: 55,\n    supportedOperators: [],\n    bitLength: 224,\n    clearMatchingType: \"uint224\",\n    aliases: [\n      {\n        type: \"Bytes28\",\n        supportedOperators: [],\n        clearMatchingType: \"28\",\n      },\n    ],\n  },\n  {\n    type: \"Uint232\",\n    value: 56,\n    supportedOperators: [],\n    bitLength: 232,\n    clearMatchingType: \"uint232\",\n    aliases: [\n      {\n        type: \"Bytes29\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes29\",\n      },\n    ],\n  },\n  {\n    type: \"Uint240\",\n    value: 57,\n    supportedOperators: [],\n    bitLength: 240,\n    clearMatchingType: \"uint240\",\n    aliases: [\n      {\n        type: \"Bytes30\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes30\",\n      },\n    ],\n  },\n  {\n    type: \"Uint248\",\n    value: 58,\n    supportedOperators: [],\n    bitLength: 248,\n    clearMatchingType: \"uint248\",\n    aliases: [\n      {\n        type: \"Bytes31\",\n        supportedOperators: [],\n        clearMatchingType: \"bytes31\",\n      },\n    ],\n  },\n  {\n    type: \"Int24\",\n    value: 59,\n    supportedOperators: [],\n    bitLength: 24,\n    clearMatchingType: \"int24\",\n  },\n  {\n    type: \"Int40\",\n    value: 60,\n    supportedOperators: [],\n    bitLength: 40,\n    clearMatchingType: \"int40\",\n  },\n  {\n    type: \"Int48\",\n    value: 61,\n    supportedOperators: [],\n    bitLength: 48,\n    clearMatchingType: \"int48\",\n  },\n  {\n    type: \"Int56\",\n    value: 62,\n    supportedOperators: [],\n    bitLength: 56,\n    clearMatchingType: \"int56\",\n  },\n  {\n    type: \"Int72\",\n    value: 63,\n    supportedOperators: [],\n    bitLength: 72,\n    clearMatchingType: \"int72\",\n  },\n  {\n    type: \"Int80\",\n    value: 64,\n    supportedOperators: [],\n    bitLength: 80,\n    clearMatchingType: \"int80\",\n  },\n  {\n    type: \"Int88\",\n    value: 65,\n    supportedOperators: [],\n    bitLength: 88,\n    clearMatchingType: \"int88\",\n  },\n  {\n    type: \"Int96\",\n    value: 66,\n    supportedOperators: [],\n    bitLength: 96,\n    clearMatchingType: \"int96\",\n  },\n  {\n    type: \"Int104\",\n    value: 67,\n    supportedOperators: [],\n    bitLength: 104,\n    clearMatchingType: \"int104\",\n  },\n  {\n    type: \"Int112\",\n    value: 68,\n    supportedOperators: [],\n    bitLength: 112,\n    clearMatchingType: \"int112\",\n  },\n  {\n    type: \"Int120\",\n    value: 69,\n    supportedOperators: [],\n    bitLength: 120,\n    clearMatchingType: \"int120\",\n  },\n  {\n    type: \"Int136\",\n    value: 70,\n    supportedOperators: [],\n    bitLength: 136,\n    clearMatchingType: \"int136\",\n  },\n  {\n    type: \"Int144\",\n    value: 71,\n    supportedOperators: [],\n    bitLength: 144,\n    clearMatchingType: \"int144\",\n  },\n  {\n    type: \"Int152\",\n    value: 72,\n    supportedOperators: [],\n    bitLength: 152,\n    clearMatchingType: \"int152\",\n  },\n  {\n    type: \"Int168\",\n    value: 73,\n    supportedOperators: [],\n    bitLength: 168,\n    clearMatchingType: \"int168\",\n  },\n  {\n    type: \"Int176\",\n    value: 74,\n    supportedOperators: [],\n    bitLength: 176,\n    clearMatchingType: \"int176\",\n  },\n  {\n    type: \"Int184\",\n    value: 75,\n    supportedOperators: [],\n    bitLength: 184,\n    clearMatchingType: \"int184\",\n  },\n  {\n    type: \"Int192\",\n    value: 76,\n    supportedOperators: [],\n    bitLength: 192,\n    clearMatchingType: \"int192\",\n  },\n  {\n    type: \"Int200\",\n    value: 77,\n    supportedOperators: [],\n    bitLength: 200,\n    clearMatchingType: \"int200\",\n  },\n  {\n    type: \"Int208\",\n    value: 78,\n    supportedOperators: [],\n    bitLength: 208,\n    clearMatchingType: \"int208\",\n  },\n  {\n    type: \"Int216\",\n    value: 79,\n    supportedOperators: [],\n    bitLength: 216,\n    clearMatchingType: \"int216\",\n  },\n  {\n    type: \"Int224\",\n    value: 80,\n    supportedOperators: [],\n    bitLength: 224,\n    clearMatchingType: \"int224\",\n  },\n  {\n    type: \"Int232\",\n    value: 81,\n    supportedOperators: [],\n    bitLength: 232,\n    clearMatchingType: \"int232\",\n  },\n  {\n    type: \"Int240\",\n    value: 82,\n    supportedOperators: [],\n    bitLength: 240,\n    clearMatchingType: \"int240\",\n  },\n  {\n    type: \"Int248\",\n    value: 83,\n    supportedOperators: [],\n    bitLength: 248,\n    clearMatchingType: \"int248\",\n  },\n];\n\nexport function checkFheType(fheType: unknown): asserts fheType is FheType {\n  if (!isUInt(fheType)) {\n    throw new FhevmError(`Invalid FheType ${fheType}`);\n  }\n\n  const theFheType = fheType as bigint | number;\n\n  if (theFheType >= ALL_FHE_TYPES.length) {\n    throw new FhevmError(`Invalid FheType ${fheType}`);\n  }\n}\n\nexport function getFheTypeByteLength(fheType: FheType): number {\n  const fheBitLen = getFheTypeBitLength(fheType);\n  return Math.ceil(fheBitLen / 8);\n}\n\nexport function getFheTypeBitLength(fheType: FheType): number {\n  return getFheTypeInfo(fheType).bitLength;\n}\n\nexport function getFheTypeInfo(type: FheType): FheTypeInfo {\n  return ALL_FHE_TYPES[type];\n}\n", "import { FhevmError } from \"../utils/error.js\";\nimport { getMaxBigInt, isUInt } from \"../utils/math.js\";\nimport { ALL_FHE_TYPES, FheType, checkFheType, getFheTypeBitLength } from \"./FheType.js\";\n\nexport type FhevmTypeName =\n  | \"ebool\"\n  | \"euint4\"\n  | \"euint8\"\n  | \"euint16\"\n  | \"euint32\"\n  | \"euint64\"\n  | \"euint128\"\n  | \"eaddress\"\n  | \"euint256\"\n  | \"ebytes64\"\n  | \"ebytes128\"\n  | \"ebytes256\";\n\nexport type SolidityTypeName =\n  | \"bool\"\n  | \"uint4\"\n  | \"uint8\"\n  | \"uint16\"\n  | \"uint32\"\n  | \"uint64\"\n  | \"uint128\"\n  | \"address\"\n  | \"uint256\"\n  | \"bytes\"\n  | \"bytes\"\n  | \"bytes\";\n\nexport enum FhevmType {\n  ebool = 0, // == FheTypes.Bool\n  euint4 = 1,\n  euint8 = 2,\n  euint16 = 3,\n  euint32 = 4,\n  euint64 = 5,\n  euint128 = 6,\n  eaddress = 7,\n  euint256 = 8,\n  ebytes64 = 9,\n  ebytes128 = 10,\n  ebytes256 = 11,\n}\n\nexport const FhevmTypeMap: Readonly<Record<FhevmTypeName, FhevmType>> = {\n  ebool: FhevmType.ebool,\n  euint4: FhevmType.euint4,\n  euint8: FhevmType.euint8,\n  euint16: FhevmType.euint16,\n  euint32: FhevmType.euint32,\n  euint64: FhevmType.euint64,\n  euint128: FhevmType.euint128,\n  eaddress: FhevmType.eaddress,\n  euint256: FhevmType.euint256,\n  ebytes64: FhevmType.ebytes64,\n  ebytes128: FhevmType.ebytes128,\n  ebytes256: FhevmType.ebytes256,\n};\nObject.freeze(FhevmTypeMap);\n\nexport const FhevmTypeNameMap: Readonly<Record<FhevmType, FhevmTypeName>> = {\n  [FhevmType.ebool]: \"ebool\",\n  [FhevmType.euint4]: \"euint4\",\n  [FhevmType.euint8]: \"euint8\",\n  [FhevmType.euint16]: \"euint16\",\n  [FhevmType.euint32]: \"euint32\",\n  [FhevmType.euint64]: \"euint64\",\n  [FhevmType.euint128]: \"euint128\",\n  [FhevmType.euint256]: \"euint256\",\n  [FhevmType.eaddress]: \"eaddress\",\n  [FhevmType.ebytes64]: \"ebytes64\",\n  [FhevmType.ebytes128]: \"ebytes128\",\n  [FhevmType.ebytes256]: \"ebytes256\",\n};\nObject.freeze(FhevmTypeNameMap);\n\nexport const allFhevmTypes: readonly Readonly<FhevmType>[] = [\n  FhevmType.ebool,\n  FhevmType.euint4,\n  FhevmType.euint8,\n  FhevmType.euint16,\n  FhevmType.euint32,\n  FhevmType.euint64,\n  FhevmType.euint128,\n  FhevmType.eaddress,\n  FhevmType.euint256,\n  FhevmType.ebytes64,\n  FhevmType.ebytes128,\n  FhevmType.ebytes256,\n];\nObject.freeze(allFhevmTypes);\n\nexport const allFhevmTypeNames: readonly Readonly<FhevmTypeName>[] = [\n  \"ebool\",\n  \"euint4\",\n  \"euint8\",\n  \"euint16\",\n  \"euint32\",\n  \"euint64\",\n  \"euint128\",\n  \"eaddress\",\n  \"euint256\",\n  \"ebytes64\",\n  \"ebytes128\",\n  \"ebytes256\",\n];\nObject.freeze(allFhevmTypeNames);\n\n// FhevmEuint\nexport type FhevmTypeEuint =\n  | FhevmType.euint4\n  | FhevmType.euint8\n  | FhevmType.euint16\n  | FhevmType.euint32\n  | FhevmType.euint64\n  | FhevmType.euint128\n  | FhevmType.euint256;\n\nexport type FhevmTypeEbytes = FhevmType.ebytes64 | FhevmType.ebytes128 | FhevmType.ebytes256;\n\n// FhevmTypeInfo\nexport interface FhevmTypeInfo {\n  name: FhevmTypeName;\n  type: FhevmType;\n  fheType: FheType;\n  solidityTypeName: SolidityTypeName;\n  clearTextBitLength: number;\n}\n\n/*\n  Warning !\n  assert(allFhevmTypeInfos[fhevmType].type === fhevmType);\n  assert(allFhevmTypeInfos[fheType].fheType === fheType);\n*/\nexport const allFhevmTypeInfos: readonly Readonly<FhevmTypeInfo>[] = Object.freeze([\n  Object.freeze({\n    type: FhevmType.ebool,\n    fheType: FheType.Bool, // 0\n    name: \"ebool\",\n    solidityTypeName: \"bool\",\n    clearTextBitLength: 1,\n  }),\n  Object.freeze({\n    type: FhevmType.euint4,\n    fheType: FheType.Uint4, // 1 (Deprecated ?)\n    name: \"euint4\",\n    solidityTypeName: \"uint4\",\n    clearTextBitLength: 4,\n  }),\n  Object.freeze({\n    type: FhevmType.euint8,\n    fheType: FheType.Uint8, // 2\n    name: \"euint8\",\n    solidityTypeName: \"uint8\",\n    clearTextBitLength: 8,\n  }),\n  Object.freeze({\n    type: FhevmType.euint16,\n    fheType: FheType.Uint16, // 3\n    name: \"euint16\",\n    solidityTypeName: \"uint16\",\n    clearTextBitLength: 16,\n  }),\n  Object.freeze({\n    type: FhevmType.euint32,\n    fheType: FheType.Uint32, // 4\n    name: \"euint32\",\n    solidityTypeName: \"uint32\",\n    clearTextBitLength: 32,\n  }),\n  Object.freeze({\n    type: FhevmType.euint64,\n    fheType: FheType.Uint64, // 5\n    name: \"euint64\",\n    solidityTypeName: \"uint64\",\n    clearTextBitLength: 64,\n  }),\n  Object.freeze({\n    name: \"euint128\",\n    type: FhevmType.euint128,\n    fheType: FheType.Uint128, // 6\n    solidityTypeName: \"uint128\",\n    clearTextBitLength: 128,\n  }),\n  Object.freeze({\n    name: \"eaddress\",\n    type: FhevmType.eaddress,\n    fheType: FheType.Uint160, // 7\n    solidityTypeName: \"address\",\n    clearTextBitLength: 160,\n  }),\n  Object.freeze({\n    name: \"euint256\",\n    type: FhevmType.euint256,\n    fheType: FheType.Uint256, // 8\n    solidityTypeName: \"uint256\",\n    clearTextBitLength: 256,\n  }),\n  Object.freeze({\n    name: \"ebytes64\",\n    type: FhevmType.ebytes64,\n    fheType: FheType.Uint512, // 9\n    solidityTypeName: \"bytes\",\n    clearTextBitLength: 512,\n  }),\n  Object.freeze({\n    name: \"ebytes128\",\n    type: FhevmType.ebytes128,\n    fheType: FheType.Uint1024, // 10\n    solidityTypeName: \"bytes\",\n    clearTextBitLength: 1024,\n  }),\n  Object.freeze({\n    name: \"ebytes256\",\n    type: FhevmType.ebytes256,\n    fheType: FheType.Uint2048, // 11\n    solidityTypeName: \"bytes\",\n    clearTextBitLength: 2048,\n  }),\n]);\n\n/**\n * Returns `true` if `fhevmType` is a valid `FhevmType`, `false` otherwise\n * @param fhevmType\n */\nexport function isFhevmType(fhevmType: unknown) {\n  if (!isUInt(fhevmType)) {\n    return false;\n  }\n\n  const theFhevmType = fhevmType as bigint | number;\n\n  if (theFhevmType >= allFhevmTypeInfos.length) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Returns `true` if `fhevmType` is a Fhevm bytes type, `false` otherwise\n * @param fhevmType\n */\nexport function isFhevmEbytes(fhevmType: FhevmType) {\n  return fhevmType === FhevmType.ebytes64 || fhevmType === FhevmType.ebytes128 || fhevmType === FhevmType.ebytes256;\n}\n\n/**\n * Returns `true` if `fhevmType` is a Fhevm unsigned integer type, `false` otherwise\n * @param fhevmType\n */\nexport function isFhevmEuint(fhevmType: FhevmType) {\n  return (\n    fhevmType === FhevmType.euint4 ||\n    fhevmType === FhevmType.euint8 ||\n    fhevmType === FhevmType.euint16 ||\n    fhevmType === FhevmType.euint32 ||\n    fhevmType === FhevmType.euint64 ||\n    fhevmType === FhevmType.euint128 ||\n    fhevmType === FhevmType.euint256\n  );\n}\n\n/**\n * Returns `true` if `fhevmType` is a Fhevm bool type, `false` otherwise\n * @param fhevmType\n */\nexport function isFhevmEbool(fhevmType: FhevmType): fhevmType is FhevmType.ebool {\n  return fhevmType === FhevmType.ebool;\n}\n\n/**\n * Returns `true` if `fhevmType` is a Fhevm address type, `false` otherwise\n * @param fhevmType\n */\nexport function isFhevmEaddress(fhevmType: FhevmType): fhevmType is FhevmType.eaddress {\n  return fhevmType === FhevmType.eaddress;\n}\n\n/**\n * Throws an internal error if `fhevmType` is not a valid `FhevmType`\n * @param fhevmType\n */\nexport function checkFhevmType(fhevmType: unknown): asserts fhevmType is FhevmType {\n  if (!isFhevmType(fhevmType)) {\n    throw new FhevmError(`Invalid FhevmType ${fhevmType}`);\n  }\n}\n\nexport function FheTypeToFhevmType(fheType: FheType): FhevmType {\n  checkFheType(fheType);\n  if (fheType >= allFhevmTypeInfos.length) {\n    throw new FhevmError(`Cannot convert FheType ${fheType} to FhevmType`);\n  }\n  return fheType as unknown as FhevmType;\n}\n\nexport function FhevmTypeToFheType(fhevmType: FhevmType): FheType {\n  checkFhevmType(fhevmType);\n  if (fhevmType >= ALL_FHE_TYPES.length) {\n    throw new FhevmError(`Cannot convert FhevmType: ${fhevmType} to FheType`);\n  }\n  return fhevmType as unknown as FheType;\n}\n\nexport function getFhevmTypeInfo(type: FhevmType | FhevmTypeName): FhevmTypeInfo {\n  if (typeof type === \"string\") {\n    return allFhevmTypeInfos[FhevmTypeMap[type]];\n  }\n  return allFhevmTypeInfos[type];\n}\n\n/**\n * Each primitive FHEVM type is encoded into a primitive FHE type.\n * The bit length of a clear (unencrypted) primitive FHEVM type may differ\n * from the number of encrypted bits used by the corresponding FHE type.\n *\n * For example, a clear boolean is typically represented using 1 bit,\n * but its encrypted FHE equivalent may use 2 encrypted bits.\n * @param fhevmType\n * @returns Then number of encrypted bits\n */\nexport function getFhevmTypeFheBitLength(fhevmType: FhevmType): number {\n  const fheType = FhevmTypeToFheType(fhevmType);\n  return getFheTypeBitLength(fheType);\n}\n\nexport function getFhevmTypeMaxClearTextBigInt(fhevmType: FhevmType): bigint {\n  const fhevmTypeInfo = getFhevmTypeInfo(fhevmType);\n  const clearTextBitLen = fhevmTypeInfo.clearTextBitLength;\n  return getMaxBigInt(clearTextBitLen);\n}\n\nexport function tryParseFhevmType(name: string): FhevmType | undefined {\n  if (typeof name !== \"string\") {\n    return undefined;\n  }\n  if (!(name in FhevmTypeMap)) {\n    return undefined;\n  }\n  try {\n    return FhevmTypeMap[name as keyof typeof FhevmTypeMap];\n  } catch {\n    return undefined;\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { FhevmError, assertFhevm, assertIsArray } from \"./error.js\";\nimport { assertIsString, toLowerCaseSet } from \"./string.js\";\n\nexport function assertIsAddress(value: unknown, valueName?: string): asserts value is string {\n  assertIsString(value, valueName);\n  assertFhevm(EthersT.isAddress(value), `${valueName ?? \"value\"}: '${value}' is not a valid address`);\n}\n\nexport function assertIsAddressArray(value: unknown, valueName?: string): asserts value is string[] {\n  assertIsArray(value, valueName);\n  for (let i = 0; i < value.length; ++i) {\n    assertIsAddress(value[i], valueName ? `${valueName}[${i}]` : undefined);\n  }\n}\n\nexport function assertIsAddressProperty<K extends string>(\n  value: unknown,\n  propertyNames: K[],\n  typeName?: string,\n): asserts value is { [P in K]: string } {\n  if (typeof value !== \"object\" || value === null) {\n    throw new FhevmError(`${typeName} must be a non-null object.`);\n  }\n\n  for (const key of propertyNames) {\n    const prop = (value as any)[key];\n    if (typeof prop !== \"string\") {\n      throw new FhevmError(`Expected '${key}' in ${typeName} to be a valid address, but got ${typeof prop} instead.`);\n    }\n    if (!EthersT.isAddress(prop)) {\n      throw new FhevmError(`Expected '${key}' in ${typeName} to be a valid address, but got ${typeof prop} instead.`);\n    }\n  }\n}\n\nexport function addressToBytes(value: string, valueName?: string): Uint8Array {\n  assertIsAddress(value, valueName);\n  // Debug\n  assertFhevm(EthersT.zeroPadValue(value, 20).toLocaleLowerCase() === EthersT.toBeHex(value, 20));\n  // Should use this line of code instead (faster)\n  //return EthersT.getBytes(EthersT.zeroPadValue(value, 20));\n  return EthersT.getBytes(EthersT.toBeHex(value, 20));\n}\n\nexport function addressesInAddressList(addresses: string[], addressList: string[]): boolean {\n  const s = toLowerCaseSet(addressList);\n\n  for (let i = 0; i < addresses.length; ++i) {\n    if (!s.has(addresses[i].toLowerCase())) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import { assertIsAddressProperty } from \"../../utils/address.js\";\nimport { assertIsArrayProperty, assertIsObjectProperty } from \"../../utils/error.js\";\nimport { assertIsStringArrayProperty, assertIsStringProperty } from \"../../utils/string.js\";\n\nexport type RelayerMetadata = {\n  version: string;\n  chainId: number;\n  gatewayChainId: number;\n  ACLAddress: string;\n  CoprocessorAddress: string;\n  DecryptionOracleAddress: string;\n  KMSVerifierAddress: string;\n  InputVerifierAddress: string;\n  relayerSignerAddress: string;\n  // relayerSignerPrivateKey or wallet info\n  // kmsSigners or wallet info\n  // inputVerifierSigners or wallet info\n};\n\nexport type RelayerV1UserDecryptHandleContractPair = {\n  handle: string;\n  contractAddress: string;\n};\n\nexport type RelayerV1InputProofPayload = {\n  contractAddress: string;\n  userAddress: string;\n  ciphertextWithInputVerification: string;\n  contractChainId: string;\n  extraData: string;\n};\n\nexport type RelayerV1InputProofResponse = {\n  handles: string[];\n  signatures: string[];\n};\n\nexport type RelayerV1UserDecryptPayload = {\n  handleContractPairs: RelayerV1UserDecryptHandleContractPair[];\n  requestValidity: RelayerV1UserDecryptValidity;\n  contractsChainId: string;\n  contractAddresses: string[];\n  userAddress: string;\n  signature: string;\n  publicKey: string;\n  extraData: string;\n};\n\nexport type RelayerV1UserDecryptValidity = {\n  startTimestamp: string;\n  durationDays: string;\n};\n\nexport type RelayerV1PublicDecryptPayload = {\n  ciphertextHandles: string[];\n  extraData: string;\n};\n\nexport type RelayerV1PublicDecryptResponse = { decrypted_value: string; signatures: string[] };\n// Try to follow relayer response format. Here signature is always Bytes32(0)\nexport type RelayerV1UserDecryptResponse = { payload: { decrypted_values: string[] }; signature: string };\n\nfunction _assertIsRelayerV1UserDecryptValidity(value: unknown): asserts value is RelayerV1UserDecryptValidity {\n  const stringFields: (keyof RelayerV1UserDecryptValidity)[] = [\"durationDays\", \"startTimestamp\"];\n  assertIsStringProperty(value, stringFields, \"RelayerV1UserDecryptValidity\");\n}\n\nexport function assertIsRelayerV1InputProofPayload(value: unknown): asserts value is RelayerV1InputProofPayload {\n  const stringFields: (keyof RelayerV1InputProofPayload)[] = [\n    \"contractAddress\",\n    \"userAddress\",\n    \"ciphertextWithInputVerification\",\n    \"contractChainId\",\n    \"extraData\",\n  ];\n  assertIsStringProperty(value, stringFields, \"RelayerV1InputProofPayload\");\n}\n\nexport function assertIsRelayerV1InputProofResponse(value: unknown): asserts value is RelayerV1InputProofResponse {\n  const keys: (keyof RelayerV1InputProofResponse)[] = [\"handles\", \"signatures\"];\n  assertIsStringArrayProperty(value, keys, \"RelayerV1InputProofResponse\");\n}\n\nexport function assertIsRelayerV1PublicDecryptPayload(value: unknown): asserts value is RelayerV1PublicDecryptPayload {\n  const arrayKeys: (keyof RelayerV1PublicDecryptPayload)[] = [\"ciphertextHandles\"];\n  const stringKeys: (keyof RelayerV1PublicDecryptPayload)[] = [\"extraData\"];\n  assertIsStringArrayProperty(value, arrayKeys, \"RelayerV1PublicDecryptPayload\");\n  assertIsStringProperty(value, stringKeys, \"RelayerV1PublicDecryptResponse\");\n}\n\nexport function assertIsRelayerV1PublicDecryptResponse(\n  value: unknown,\n): asserts value is RelayerV1PublicDecryptResponse {\n  const arrayKeys: (keyof RelayerV1PublicDecryptResponse)[] = [\"signatures\"];\n  const stringKeys: (keyof RelayerV1PublicDecryptResponse)[] = [\"decrypted_value\"];\n  assertIsStringArrayProperty(value, arrayKeys, \"RelayerV1PublicDecryptResponse\");\n  assertIsStringProperty(value, stringKeys, \"RelayerV1PublicDecryptResponse\");\n}\n\nexport function assertIsRelayerV1UserDecryptResponse(value: unknown): asserts value is RelayerV1UserDecryptResponse {\n  const stringKeys: (keyof RelayerV1UserDecryptResponse)[] = [\"signature\"];\n  const objectKeys: (keyof RelayerV1UserDecryptResponse)[] = [\"payload\"];\n  assertIsStringProperty(value, stringKeys, \"RelayerV1UserDecryptResponse\");\n  assertIsObjectProperty(value, objectKeys, \"RelayerV1UserDecryptResponse\");\n  assertIsStringArrayProperty(value.payload, [\"decrypted_values\"], \"RelayerV1UserDecryptResponse\");\n}\n\nexport function assertIsRelayerV1UserDecryptPayload(value: unknown): asserts value is RelayerV1UserDecryptPayload {\n  const arrayKeys: (keyof RelayerV1UserDecryptPayload)[] = [\"handleContractPairs\", \"contractAddresses\"];\n  const stringKeys: (keyof RelayerV1UserDecryptPayload)[] = [\n    \"contractsChainId\",\n    \"publicKey\",\n    \"signature\",\n    \"userAddress\",\n    \"extraData\",\n  ];\n  const objectKeys: (keyof RelayerV1UserDecryptPayload)[] = [\"requestValidity\"];\n\n  assertIsStringProperty(value, stringKeys, \"RelayerV1UserDecryptPayload\");\n  assertIsArrayProperty(value, arrayKeys, \"RelayerV1UserDecryptPayload\");\n  assertIsObjectProperty(value, objectKeys, \"RelayerV1UserDecryptPayload\");\n\n  _assertIsRelayerV1UserDecryptValidity(value.requestValidity);\n}\n\nexport function assertIsRelayerMetadata(value: unknown): asserts value is RelayerMetadata {\n  const stringKeys: (keyof RelayerMetadata)[] = [\"version\"];\n  assertIsStringProperty(value, stringKeys, \"RelayerMetadata\");\n  const keys: (keyof RelayerMetadata)[] = [\n    \"ACLAddress\",\n    \"CoprocessorAddress\",\n    \"InputVerifierAddress\",\n    \"KMSVerifierAddress\",\n    \"relayerSignerAddress\",\n  ];\n  assertIsAddressProperty(value, keys, \"RelayerMetadata\");\n}\n", "import { assertIsArrayProperty, assertIsObjectProperty } from \"../../utils/error.js\";\nimport { assertIsStringProperty } from \"../../utils/string.js\";\nimport { FheType } from \"../FheType.js\";\nimport { FhevmType } from \"../FhevmType.js\";\nimport type { FhevmDBHandleMetadata } from \"../db/FhevmDB.js\";\nimport { type RelayerV1InputProofPayload, assertIsRelayerV1InputProofPayload } from \"./payloads.js\";\n\nexport type MockRelayerData = {\n  clearTextValuesBigIntHex: string[];\n  metadatas: FhevmDBHandleMetadata[];\n  fheTypes: FheType[];\n  fhevmTypes: FhevmType[];\n  aclContractAddress: string;\n  random32List: string[];\n};\n\nexport type MockRelayerV1InputProofPayload = RelayerV1InputProofPayload & {\n  mockData: MockRelayerData;\n};\n\nexport function assertIsMockRelayerV1InputProofPayload(\n  value: unknown,\n): asserts value is MockRelayerV1InputProofPayload {\n  const objectKeys: (keyof MockRelayerV1InputProofPayload)[] = [\"mockData\"];\n\n  assertIsRelayerV1InputProofPayload(value);\n  assertIsObjectProperty(value, objectKeys, \"MockRelayerV1InputProofPayload\");\n\n  _assertIsMockRelayerData((value as any).mockData);\n}\n\nfunction _assertIsMockRelayerData(value: object): asserts value is MockRelayerData {\n  const arrayKeys: (keyof MockRelayerData)[] = [\n    \"clearTextValuesBigIntHex\",\n    \"metadatas\",\n    \"fheTypes\",\n    \"fhevmTypes\",\n    \"random32List\",\n  ];\n  const stringKeys: (keyof MockRelayerData)[] = [\"aclContractAddress\"];\n  assertIsStringProperty(value, stringKeys, \"MockRelayerData\");\n  assertIsArrayProperty(value, arrayKeys, \"MockRelayerData\");\n}\n", "import { type MinimalProvider, minimalProviderSend } from \"../../ethers/provider.js\";\nimport {\n  FHEVM_AWAIT_DECRYPTION_ORACLE,\n  FHEVM_CREATE_DECRYPTION_SIGNATURES,\n  FHEVM_GET_CLEAR_TEXT,\n  RELAYER_METADATA,\n  RELAYER_V1_INPUT_PROOF,\n  RELAYER_V1_PUBLIC_DECRYPT,\n  RELAYER_V1_USER_DECRYPT,\n} from \"./methods.js\";\nimport { type MockRelayerV1InputProofPayload, assertIsMockRelayerV1InputProofPayload } from \"./mock_payloads.js\";\nimport type {\n  RelayerMetadata,\n  RelayerV1InputProofResponse,\n  RelayerV1PublicDecryptPayload,\n  RelayerV1PublicDecryptResponse,\n  RelayerV1UserDecryptPayload,\n  RelayerV1UserDecryptResponse,\n} from \"./payloads.js\";\nimport {\n  assertIsRelayerMetadata,\n  assertIsRelayerV1InputProofResponse,\n  assertIsRelayerV1PublicDecryptPayload,\n  assertIsRelayerV1PublicDecryptResponse,\n  assertIsRelayerV1UserDecryptPayload,\n  assertIsRelayerV1UserDecryptResponse,\n} from \"./payloads.js\";\n\n// To be changed into a FhevmMockRelayerProvider class\n\n/**\n * Equivalent to const response = await fetch(`${relayerUrl}/v1/input-proof`, options);\n */\nexport async function requestRelayerV1InputProof(\n  relayerProvider: MinimalProvider,\n  payload: MockRelayerV1InputProofPayload,\n): Promise<RelayerV1InputProofResponse> {\n  assertIsMockRelayerV1InputProofPayload(payload);\n  const response = await minimalProviderSend(relayerProvider, RELAYER_V1_INPUT_PROOF, [payload]);\n  assertIsRelayerV1InputProofResponse(response);\n\n  return response;\n}\n\n/**\n * Equivalent to const response = await fetch(`${relayerUrl}/v1/user-decrypt`, options);\n */\nexport async function requestRelayerV1UserDecrypt(\n  relayerProvider: MinimalProvider,\n  payload: RelayerV1UserDecryptPayload,\n): Promise<{ response: RelayerV1UserDecryptResponse[] }> {\n  assertIsRelayerV1UserDecryptPayload(payload);\n  const response = await minimalProviderSend(relayerProvider, RELAYER_V1_USER_DECRYPT, [payload]);\n  assertIsRelayerV1UserDecryptResponse(response);\n\n  return { response: [response] };\n}\n\n/**\n * Equivalent to const response = await fetch(`${relayerUrl}/v1/public-decrypt`, options);\n */\nexport async function requestRelayerV1PublicDecrypt(\n  relayerProvider: MinimalProvider,\n  payload: RelayerV1PublicDecryptPayload,\n): Promise<{ response: RelayerV1PublicDecryptResponse[] }> {\n  assertIsRelayerV1PublicDecryptPayload(payload);\n  const response = await minimalProviderSend(relayerProvider, RELAYER_V1_PUBLIC_DECRYPT, [payload]);\n  assertIsRelayerV1PublicDecryptResponse(response);\n  return { response: [response] };\n}\n\n/**\n * Custom, returns Fhevm addresses expected by the relayer.\n */\nexport async function requestRelayerMetadata(relayerProvider: MinimalProvider): Promise<RelayerMetadata> {\n  const response = await minimalProviderSend(relayerProvider, RELAYER_METADATA, []);\n  assertIsRelayerMetadata(response);\n  return response;\n}\n\nexport async function requestFhevmAwaitDecryptionOracle(relayerProvider: MinimalProvider): Promise<any> {\n  return await minimalProviderSend(relayerProvider, FHEVM_AWAIT_DECRYPTION_ORACLE, []);\n}\n\nexport async function requestFhevmGetClearText(relayerProvider: MinimalProvider, payload: string[]): Promise<any> {\n  return await minimalProviderSend(relayerProvider, FHEVM_GET_CLEAR_TEXT, [payload]);\n}\n\nexport async function requestFhevmCreateDecryptionSignatures(\n  relayerProvider: MinimalProvider,\n  payload: { handlesBytes32Hex: string[]; clearTextValuesHex: string[]; extraData: string },\n): Promise<any> {\n  return await minimalProviderSend(relayerProvider, FHEVM_CREATE_DECRYPTION_SIGNATURES, [payload]);\n}\n", "export { removePrefix, ensureSuffix, ensurePrefix } from \"./string.js\";\nexport { toUIntNumber } from \"./math.js\";\nexport { timestampNow } from \"./time.js\";\nexport { assertIsAddress } from \"./address.js\";\nexport { verifyKeypair } from \"./keypair.js\";\nexport { FhevmError } from \"./error.js\";\n", "export function currentTime(): string {\n  const now = new Date();\n  return now.toLocaleTimeString(\"en-US\", { hour12: true, hour: \"numeric\", minute: \"numeric\", second: \"numeric\" });\n}\n\n// Official timestamp in js/ts\n// Number of seconds elapsed since midnight, January 1, 1970 Universal Coordinated Time (UTC).\nexport function timestampNow(): number {\n  return Math.floor(Date.now() / 1000);\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { FhevmError } from \"./error.js\";\nimport { removePrefix } from \"./string.js\";\n\n// import {\n//     u8vec_to_cryptobox_pk,\n//     u8vec_to_cryptobox_sk,\n// } from 'node-tkms';\n\n/*\n    let pubKey;\n    let privKey;\n    try {\n      pubKey = u8vec_to_cryptobox_pk(fromHexString(publicKey));\n      privKey = u8vec_to_cryptobox_sk(fromHexString(privateKey));\n    } catch (e) {\n      throw new Error('Invalid public or private key', { cause: e });\n    }\n  */\n\nexport function verifyKeypair(keyPair: { publicKey: string; privateKey: string }) {\n  keyPair.publicKey = removePrefix(keyPair.publicKey, \"0x\");\n  keyPair.privateKey = removePrefix(keyPair.privateKey, \"0x\");\n\n  if (!EthersT.isHexString(\"0x\" + keyPair.publicKey, 80)) {\n    throw new FhevmError(\n      `Invalid key pair's publicKey. Call FhevmInstance.generateKeyPair() to generate a valid FHEVM key pair.`,\n    );\n  }\n  if (!EthersT.isHexString(\"0x\" + keyPair.privateKey, 80)) {\n    throw new FhevmError(\n      `Invalid key pair's publicKey. Call FhevmInstance.generateKeyPair() to generate a valid FHEVM key pair.`,\n    );\n  }\n}\n", "import { ACL } from \"./ACL.js\";\nimport { FHEVMExecutor } from \"./FHEVMExecutor.js\";\nimport {\n  FhevmContractWrapper,\n  FhevmCoprocessorContractWrapper,\n  FhevmDecryptionOracleContractWrapper,\n} from \"./FhevmContractWrapper.js\";\nimport { FhevmContractsRepository } from \"./FhevmContractsRepository.js\";\nimport { HCULimit } from \"./HCULimit.js\";\nimport { InputVerifier } from \"./InputVerifier.js\";\nimport { KMSVerifier } from \"./KMSVerifier.js\";\n\nexport type FhevmCoprocessorContractName = \"ACL\" | \"FHEVMExecutor\" | \"InputVerifier\" | \"KMSVerifier\" | \"HCULimit\";\nexport type FhevmDecryptionOracleContractName = \"DecryptionOracle\";\nexport type FhevmContractName = FhevmCoprocessorContractName | FhevmDecryptionOracleContractName;\n\nexport {\n  ACL,\n  HCULimit,\n  FHEVMExecutor,\n  InputVerifier,\n  KMSVerifier,\n  FhevmContractsRepository,\n  FhevmContractWrapper,\n  FhevmCoprocessorContractWrapper,\n  FhevmDecryptionOracleContractWrapper,\n};\n", "import { ethers as EthersT } from \"ethers\";\n\nimport constants from \"../../constants.js\";\nimport type { FhevmContractName, FhevmCoprocessorContractName, FhevmDecryptionOracleContractName } from \"./index.js\";\n\nexport abstract class FhevmContractWrapper {\n  readonly #name: FhevmContractName;\n  constructor(name: FhevmContractName) {\n    this.#name = name;\n  }\n\n  public get name(): FhevmContractName {\n    return this.#name;\n  }\n\n  public abstract get package(): string;\n  public abstract get address(): string;\n  public abstract get interface(): EthersT.Interface;\n  public abstract get readonlyContract(): EthersT.Contract;\n\n  public get properties(): {\n    contractName: FhevmContractName;\n    address: string;\n    contract: EthersT.Contract;\n    package: string;\n  } {\n    return {\n      address: this.address,\n      contract: this.readonlyContract,\n      package: this.package,\n      contractName: this.name,\n    };\n  }\n  protected async _callOrThrow(p: Promise<any>, funcName: string) {\n    try {\n      return await p;\n    } catch (e) {\n      console.error(`invalid deployed ${this.name} contact at ${this.address}. Function ${funcName} does not exist.`);\n      throw e;\n    }\n  }\n}\n\nexport abstract class FhevmCoprocessorContractWrapper extends FhevmContractWrapper {\n  constructor(name: FhevmCoprocessorContractName) {\n    super(name);\n  }\n  public override get package(): string {\n    return constants.FHEVM_CORE_CONTRACTS_PACKAGE_NAME;\n  }\n}\n\nexport abstract class FhevmDecryptionOracleContractWrapper extends FhevmContractWrapper {\n  constructor(name: FhevmDecryptionOracleContractName) {\n    super(name);\n  }\n  public override get package(): string {\n    return constants.ZAMA_FHE_ORACLE_SOLIDITY_PACKAGE_NAME;\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\n// version \"0.8.0-0\"\nexport const ACLInterfaceVersion = \"0.8.0-0\";\n\nexport const ACLPartialInterface: EthersT.Interface = new EthersT.Interface([\n  {\n    inputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"target\",\n        type: \"address\",\n      },\n    ],\n    name: \"AddressEmptyCode\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"delegatee\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"contractAddress\",\n        type: \"address\",\n      },\n    ],\n    name: \"AlreadyDelegated\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ContractAddressesIsEmpty\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ContractAddressesMaxLengthExceeded\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\",\n      },\n    ],\n    name: \"ERC1967InvalidImplementation\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ERC1967NonPayable\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"EnforcedPause\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ExpectedPause\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"FailedCall\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"HandlesListIsEmpty\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidInitialization\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidNullPauser\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"delegatee\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"contractAddress\",\n        type: \"address\",\n      },\n    ],\n    name: \"NotDelegatedYet\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotInitializing\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotInitializingFromEmptyProxy\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n    ],\n    name: \"NotPauser\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnableInvalidOwner\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnableUnauthorizedAccount\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"contractAddress\",\n        type: \"address\",\n      },\n    ],\n    name: \"SenderCannotBeContractAddress\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n    ],\n    name: \"SenderNotAllowed\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"UUPSUnauthorizedCallContext\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"slot\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"UUPSUnsupportedProxiableUUID\",\n    type: \"error\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"handle\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"Allowed\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32[]\",\n        name: \"handlesList\",\n        type: \"bytes32[]\",\n      },\n    ],\n    name: \"AllowedForDecryption\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"uint64\",\n        name: \"version\",\n        type: \"uint64\",\n      },\n    ],\n    name: \"Initialized\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"delegatee\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address[]\",\n        name: \"contractAddresses\",\n        type: \"address[]\",\n      },\n    ],\n    name: \"NewDelegation\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferStarted\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferred\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"Paused\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"delegatee\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address[]\",\n        name: \"contractAddresses\",\n        type: \"address[]\",\n      },\n    ],\n    name: \"RevokedDelegation\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"Unpaused\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newPauser\",\n        type: \"address\",\n      },\n    ],\n    name: \"UpdatePauser\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\",\n      },\n    ],\n    name: \"Upgraded\",\n    type: \"event\",\n  },\n  {\n    inputs: [],\n    name: \"UPGRADE_INTERFACE_VERSION\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"acceptOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"handle\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"allow\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32[]\",\n        name: \"handlesList\",\n        type: \"bytes32[]\",\n      },\n    ],\n    name: \"allowForDecryption\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"handle\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"allowTransient\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"delegatee\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"handle\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"address\",\n        name: \"contractAddress\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"allowedOnBehalf\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"handle\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"allowedTransient\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"cleanTransientStorage\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"delegatee\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address[]\",\n        name: \"contractAddresses\",\n        type: \"address[]\",\n      },\n    ],\n    name: \"delegateAccount\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getFHEVMExecutorAddress\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getPauser\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"pauser\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getVersion\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"initialPauser\",\n        type: \"address\",\n      },\n    ],\n    name: \"initializeFromEmptyProxy\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"handle\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"isAllowed\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"handle\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"isAllowedForDecryption\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"owner\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"paused\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pendingOwner\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"handle\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"persistAllowed\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"proxiableUUID\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"initialPauser\",\n        type: \"address\",\n      },\n    ],\n    name: \"reinitializeV2\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"renounceOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"delegatee\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address[]\",\n        name: \"contractAddresses\",\n        type: \"address[]\",\n      },\n    ],\n    name: \"revokeDelegation\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"transferOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"unpause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"newPauser\",\n        type: \"address\",\n      },\n    ],\n    name: \"updatePauser\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"newImplementation\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"upgradeToAndCall\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n]);\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { assertIsAddress } from \"../../utils/address.js\";\nimport { FhevmError, assertFhevm } from \"../../utils/error.js\";\nimport { assertIsString } from \"../../utils/string.js\";\nimport { FhevmCoprocessorContractWrapper } from \"./FhevmContractWrapper.js\";\nimport { ACLPartialInterface } from \"./interfaces/ACL.itf.js\";\n\nexport type ACLProperties = {\n  fhevmExecutorAddress?: string;\n  version?: string;\n};\n\n// Shareable\nexport class ACL extends FhevmCoprocessorContractWrapper {\n  #aclReadOnlyContract: EthersT.Contract | undefined;\n  #aclContractAddress: string | undefined;\n  #fhevmExecutorAddress: string | undefined;\n  #version: string | undefined;\n\n  constructor() {\n    super(\"ACL\");\n  }\n\n  public static async create(\n    runner: EthersT.ContractRunner,\n    aclContractAddress: string,\n    abi?: EthersT.Interface | EthersT.InterfaceAbi,\n    properties?: ACLProperties,\n  ): Promise<ACL> {\n    assertIsAddress(aclContractAddress, \"aclContractAddress\");\n    const acl = new ACL();\n    acl.#aclContractAddress = aclContractAddress;\n    acl.#aclReadOnlyContract = new EthersT.Contract(aclContractAddress, abi ?? ACLPartialInterface, runner);\n    acl.#fhevmExecutorAddress = properties?.fhevmExecutorAddress;\n    acl.#version = properties?.version;\n    await acl._initialize();\n    return acl;\n  }\n\n  public override get readonlyContract(): EthersT.Contract {\n    assertFhevm(this.#aclReadOnlyContract !== undefined, `ACL wrapper is not yet initialized`);\n    return this.#aclReadOnlyContract;\n  }\n\n  public override get interface(): EthersT.Interface {\n    assertFhevm(this.#aclReadOnlyContract !== undefined, `ACL wrapper is not yet initialized`);\n    return this.#aclReadOnlyContract.interface;\n  }\n\n  public get address(): string {\n    assertFhevm(this.#aclContractAddress !== undefined, `ACL wrapper is not yet initialized`);\n    return this.#aclContractAddress;\n  }\n\n  public get version(): string {\n    assertFhevm(this.#version !== undefined, `ACL wrapper is not yet initialized`);\n    return this.#version;\n  }\n\n  public get fhevmExecutorAddress(): string {\n    assertFhevm(this.#fhevmExecutorAddress !== undefined, `ACL wrapper is not yet initialized`);\n    return this.#fhevmExecutorAddress;\n  }\n\n  private async _initialize() {\n    assertFhevm(this.#aclReadOnlyContract !== undefined, `ACL wrapper is not yet initialized`);\n\n    if (!this.#fhevmExecutorAddress) {\n      this.#fhevmExecutorAddress = await this.#aclReadOnlyContract.getFHEVMExecutorAddress();\n    }\n    assertIsAddress(this.#fhevmExecutorAddress, \"fhemExecutorAddress\");\n\n    if (!this.#version) {\n      this.#version = await this.#aclReadOnlyContract.getVersion();\n    }\n    assertIsString(this.#version, \"version\");\n  }\n\n  public async checkIsAllowedForDecryption(handlesBytes32Hex: string[], readonlyProvider: EthersT.Provider) {\n    assertFhevm(this.#aclReadOnlyContract !== undefined, `ACL wrapper is not yet initialized`);\n    const c = this.#aclReadOnlyContract.connect(readonlyProvider) as EthersT.Contract;\n\n    const isAllowedForDec: boolean[] = await Promise.all(\n      handlesBytes32Hex.map(async (handleBytes32Hex: string) => c.isAllowedForDecryption(handleBytes32Hex)),\n    );\n\n    for (let i = 0; i < isAllowedForDec.length; ++i) {\n      if (!isAllowedForDec[i]) {\n        throw new FhevmError(`Handle ${handlesBytes32Hex[i]} is not authorized for decryption`);\n      }\n    }\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\n// version \"0.8.0-0\"\nexport const FHEVMExecutorInterfaceVersion = \"0.8.0-0\";\n\nexport const FHEVMExecutorPartialInterface: EthersT.Interface = new EthersT.Interface([\n  {\n    inputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"handle\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"ACLNotAllowed\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"target\",\n        type: \"address\",\n      },\n    ],\n    name: \"AddressEmptyCode\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"DivisionByZero\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\",\n      },\n    ],\n    name: \"ERC1967InvalidImplementation\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ERC1967NonPayable\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"FailedCall\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"IncompatibleTypes\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"typeOf\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"length\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"InvalidByteLength\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidInitialization\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidType\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"IsNotScalar\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n    ],\n    name: \"NotHostOwner\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotInitializing\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotInitializingFromEmptyProxy\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotPowerOfTwo\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnableInvalidOwner\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnableUnauthorizedAccount\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"SecondOperandIsNotScalar\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"UUPSUnauthorizedCallContext\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"slot\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"UUPSUnsupportedProxiableUUID\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"UnsupportedType\",\n    type: \"error\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"ct\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"enum FheType\",\n        name: \"toType\",\n        type: \"uint8\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"Cast\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheAdd\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheBitAnd\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheBitOr\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheBitXor\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheDiv\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheEq\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheGe\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheGt\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"control\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"ifTrue\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"ifFalse\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheIfThenElse\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheLe\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheLt\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheMax\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheMin\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheMul\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheNe\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"ct\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheNeg\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"ct\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheNot\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"enum FheType\",\n        name: \"randType\",\n        type: \"uint8\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes16\",\n        name: \"seed\",\n        type: \"bytes16\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheRand\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"upperBound\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"enum FheType\",\n        name: \"randType\",\n        type: \"uint8\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes16\",\n        name: \"seed\",\n        type: \"bytes16\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheRandBounded\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheRem\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheRotl\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheRotr\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheShl\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheShr\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"FheSub\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"uint64\",\n        name: \"version\",\n        type: \"uint64\",\n      },\n    ],\n    name: \"Initialized\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferStarted\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferred\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"pt\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"enum FheType\",\n        name: \"toType\",\n        type: \"uint8\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"TrivialEncrypt\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\",\n      },\n    ],\n    name: \"Upgraded\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"caller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"inputHandle\",\n        type: \"bytes32\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"userAddress\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"inputProof\",\n        type: \"bytes\",\n      },\n      {\n        indexed: false,\n        internalType: \"enum FheType\",\n        name: \"inputType\",\n        type: \"uint8\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"VerifyCiphertext\",\n    type: \"event\",\n  },\n  {\n    inputs: [],\n    name: \"UPGRADE_INTERFACE_VERSION\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"acceptOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"ct\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"enum FheType\",\n        name: \"toType\",\n        type: \"uint8\",\n      },\n    ],\n    name: \"cast\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheAdd\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheBitAnd\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheBitOr\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheBitXor\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheDiv\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheEq\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheGe\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheGt\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"control\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"ifTrue\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"ifFalse\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"fheIfThenElse\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheLe\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheLt\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheMax\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheMin\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheMul\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheNe\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"ct\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"fheNeg\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"ct\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"fheNot\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"randType\",\n        type: \"uint8\",\n      },\n    ],\n    name: \"fheRand\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"upperBound\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"enum FheType\",\n        name: \"randType\",\n        type: \"uint8\",\n      },\n    ],\n    name: \"fheRandBounded\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheRem\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheRotl\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheRotr\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheShl\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheShr\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n    ],\n    name: \"fheSub\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getACLAddress\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getHCULimitAddress\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getHandleVersion\",\n    outputs: [\n      {\n        internalType: \"uint8\",\n        name: \"\",\n        type: \"uint8\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getInputVerifierAddress\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getVersion\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"initializeFromEmptyProxy\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"owner\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pendingOwner\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"proxiableUUID\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"reinitializeV3\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"renounceOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"transferOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"pt\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"enum FheType\",\n        name: \"toType\",\n        type: \"uint8\",\n      },\n    ],\n    name: \"trivialEncrypt\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"newImplementation\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"upgradeToAndCall\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"inputHandle\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"address\",\n        name: \"userAddress\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"inputProof\",\n        type: \"bytes\",\n      },\n      {\n        internalType: \"enum FheType\",\n        name: \"inputType\",\n        type: \"uint8\",\n      },\n    ],\n    name: \"verifyCiphertext\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n]);\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { assertIsAddress } from \"../../utils/address.js\";\nimport { assertFhevm } from \"../../utils/error.js\";\nimport { assertIsString } from \"../../utils/string.js\";\nimport { FhevmCoprocessorContractWrapper } from \"./FhevmContractWrapper.js\";\nimport { FHEVMExecutorPartialInterface } from \"./interfaces/FHEVMExecutor.itf.js\";\n\nexport type FHEVMExecutorProperties = {\n  aclAddress?: string;\n  hcuLimitAddress?: string;\n  inputVerifierAddress?: string;\n  version?: string;\n};\n\n// Shareable\nexport class FHEVMExecutor extends FhevmCoprocessorContractWrapper {\n  #fhevmExecutorReadonlyContract: EthersT.Contract | undefined;\n  #fhevmExecutorContractAddress: string | undefined;\n  #aclAddress: string | undefined;\n  #hcuLimitAddress: string | undefined;\n  #inputVerifierAddress: string | undefined;\n  #version: string | undefined;\n\n  constructor() {\n    super(\"FHEVMExecutor\");\n  }\n\n  public static async create(\n    runner: EthersT.ContractRunner,\n    fhevmExecutorContractAddress: string,\n    abi?: EthersT.Interface | EthersT.InterfaceAbi,\n    properties?: FHEVMExecutorProperties,\n  ): Promise<FHEVMExecutor> {\n    assertIsAddress(fhevmExecutorContractAddress, \"fhevmExecutorContractAddress\");\n    const fhevmExecutor = new FHEVMExecutor();\n    fhevmExecutor.#fhevmExecutorContractAddress = fhevmExecutorContractAddress;\n    fhevmExecutor.#fhevmExecutorReadonlyContract = new EthersT.Contract(\n      fhevmExecutorContractAddress,\n      abi ?? FHEVMExecutorPartialInterface,\n      runner,\n    );\n    fhevmExecutor.#aclAddress = properties?.aclAddress;\n    fhevmExecutor.#hcuLimitAddress = properties?.hcuLimitAddress;\n    fhevmExecutor.#inputVerifierAddress = properties?.inputVerifierAddress;\n    fhevmExecutor.#version = properties?.version;\n    await fhevmExecutor._initialize();\n    return fhevmExecutor;\n  }\n\n  public override get readonlyContract(): EthersT.Contract {\n    assertFhevm(this.#fhevmExecutorReadonlyContract !== undefined, `FHEVMExecutor wrapper is not yet initialized`);\n    return this.#fhevmExecutorReadonlyContract;\n  }\n\n  public override get interface(): EthersT.Interface {\n    assertFhevm(this.#fhevmExecutorReadonlyContract !== undefined, `FHEVMExecutor wrapper is not yet initialized`);\n    return this.#fhevmExecutorReadonlyContract.interface;\n  }\n\n  public get address(): string {\n    assertFhevm(this.#fhevmExecutorContractAddress !== undefined, `FHEVMExecutor wrapper is not yet initialized`);\n    return this.#fhevmExecutorContractAddress;\n  }\n\n  public get version(): string {\n    assertFhevm(this.#version !== undefined, `FHEVMExecutor wrapper is not yet initialized`);\n    return this.#version;\n  }\n\n  public get aclAddress(): string {\n    assertFhevm(this.#aclAddress !== undefined, `FHEVMExecutor wrapper is not yet initialized`);\n    return this.#aclAddress;\n  }\n\n  public get hcuLimitAddress(): string {\n    assertFhevm(this.#hcuLimitAddress !== undefined, `FHEVMExecutor wrapper is not yet initialized`);\n    return this.#hcuLimitAddress;\n  }\n\n  public get inputVerifierAddress(): string {\n    assertFhevm(this.#inputVerifierAddress !== undefined, `FHEVMExecutor wrapper is not yet initialized`);\n    return this.#inputVerifierAddress;\n  }\n\n  private async _initialize() {\n    assertFhevm(this.#fhevmExecutorReadonlyContract !== undefined, `FHEVMExecutor wrapper is not initialized`);\n\n    if (!this.#aclAddress) {\n      this.#aclAddress = await this._callOrThrow(\n        this.#fhevmExecutorReadonlyContract.getACLAddress(),\n        \"getACLAddress()\",\n      );\n    }\n    assertIsAddress(this.#aclAddress, \"aclAddress\");\n\n    if (!this.#hcuLimitAddress) {\n      this.#hcuLimitAddress = await this._callOrThrow(\n        this.#fhevmExecutorReadonlyContract.getHCULimitAddress(),\n        \"getHCULimitAddress()\",\n      );\n    }\n    assertIsAddress(this.#hcuLimitAddress, \"hcuLimitAddress\");\n\n    if (!this.#inputVerifierAddress) {\n      this.#inputVerifierAddress = await this._callOrThrow(\n        this.#fhevmExecutorReadonlyContract.getInputVerifierAddress(),\n        \"getInputVerifierAddress()\",\n      );\n    }\n    assertIsAddress(this.#inputVerifierAddress, \"inputVerifierAddress\");\n\n    if (!this.#version) {\n      this.#version = await this._callOrThrow(this.#fhevmExecutorReadonlyContract.getVersion(), \"getVersion()\");\n    }\n    assertIsString(this.#version, \"version\");\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\n// version \"0.8.0-0\"\nexport const HCULimitInterfaceVersion = \"0.8.0-0\";\n\nexport const HCULimitPartialInterface: EthersT.Interface = new EthersT.Interface([\n  {\n    inputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"target\",\n        type: \"address\",\n      },\n    ],\n    name: \"AddressEmptyCode\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"CallerMustBeFHEVMExecutorContract\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\",\n      },\n    ],\n    name: \"ERC1967InvalidImplementation\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ERC1967NonPayable\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"FailedCall\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"HCUTransactionDepthLimitExceeded\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"HCUTransactionLimitExceeded\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidInitialization\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n    ],\n    name: \"NotHostOwner\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotInitializing\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotInitializingFromEmptyProxy\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"OnlyScalarOperationsAreSupported\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnableInvalidOwner\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnableUnauthorizedAccount\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"UUPSUnauthorizedCallContext\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"slot\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"UUPSUnsupportedProxiableUUID\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"UnsupportedOperation\",\n    type: \"error\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"uint64\",\n        name: \"version\",\n        type: \"uint64\",\n      },\n    ],\n    name: \"Initialized\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferStarted\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferred\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\",\n      },\n    ],\n    name: \"Upgraded\",\n    type: \"event\",\n  },\n  {\n    inputs: [],\n    name: \"UPGRADE_INTERFACE_VERSION\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"acceptOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"ct\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForCast\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheAdd\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheBitAnd\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheBitOr\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheBitXor\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheDiv\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheEq\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheGe\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheGt\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheLe\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheLt\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheMax\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheMin\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheMul\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheNe\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"ct\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheNeg\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"ct\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheNot\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheRand\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheRandBounded\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheRem\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheRotl\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheRotr\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheShl\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheShr\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes1\",\n        name: \"scalarByte\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForFheSub\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"lhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"middle\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rhs\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForIfThenElse\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"enum FheType\",\n        name: \"resultType\",\n        type: \"uint8\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"result\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"checkHCUForTrivialEncrypt\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getFHEVMExecutorAddress\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getVersion\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"initializeFromEmptyProxy\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"owner\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pendingOwner\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"proxiableUUID\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"reinitializeV4\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"renounceOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"transferOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"newImplementation\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"upgradeToAndCall\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n]);\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { assertIsAddress } from \"../../utils/address.js\";\nimport { FhevmError, assertFhevm } from \"../../utils/error.js\";\nimport { assertIsString } from \"../../utils/string.js\";\nimport { FhevmCoprocessorContractWrapper } from \"./FhevmContractWrapper.js\";\nimport { HCULimitPartialInterface } from \"./interfaces/HCULimit.itf.js\";\n\nexport type HCULimitProperties = {\n  fhemExecutorAddress?: string;\n  version?: string;\n};\n\nexport class HCULimit extends FhevmCoprocessorContractWrapper {\n  #hcuLimitContract: EthersT.Contract | undefined;\n  #hcuLimitContractAddress: string | undefined;\n  #fhemExecutorAddress: string | undefined;\n  #version: string | undefined;\n\n  constructor() {\n    super(\"HCULimit\");\n  }\n\n  public static async create(\n    runner: EthersT.ContractRunner,\n    hcuLimitContractAddress: string,\n    abi?: EthersT.Interface | EthersT.InterfaceAbi,\n    properties?: HCULimitProperties,\n  ): Promise<HCULimit> {\n    assertIsAddress(hcuLimitContractAddress, \"hcuLimitContractAddress\");\n\n    if (properties !== undefined) {\n      throw new FhevmError(\"Not yet implemented\");\n    }\n\n    const hcuLimit = new HCULimit();\n    hcuLimit.#hcuLimitContractAddress = hcuLimitContractAddress;\n    hcuLimit.#hcuLimitContract = new EthersT.Contract(hcuLimitContractAddress, abi ?? HCULimitPartialInterface, runner);\n    await hcuLimit._initialize();\n    return hcuLimit;\n  }\n\n  public override get readonlyContract(): EthersT.Contract {\n    assertFhevm(this.#hcuLimitContract !== undefined, `HCULimit wrapper is not yet initialized`);\n    return this.#hcuLimitContract;\n  }\n\n  public override get interface(): EthersT.Interface {\n    assertFhevm(this.#hcuLimitContract !== undefined, `HCULimit wrapper is not yet initialized`);\n    return this.#hcuLimitContract.interface;\n  }\n\n  public get address(): string {\n    assertFhevm(this.#hcuLimitContractAddress !== undefined, `HCULimit wrapper is not yet initialized`);\n    return this.#hcuLimitContractAddress;\n  }\n\n  public get version(): string {\n    assertFhevm(this.#version !== undefined, `HCULimit wrapper is not yet initialized`);\n    return this.#version;\n  }\n\n  public get fhemExecutorAddress(): string {\n    assertFhevm(this.#fhemExecutorAddress !== undefined, `HCULimit wrapper is not yet initialized`);\n    return this.#fhemExecutorAddress;\n  }\n\n  private async _initialize() {\n    assertFhevm(this.#hcuLimitContract !== undefined, `HCULimit wrapper is not yet initialized`);\n    assertFhevm(this.#fhemExecutorAddress === undefined, `HCULimit wrapper already initialized`);\n\n    this.#fhemExecutorAddress = await this.#hcuLimitContract.getFHEVMExecutorAddress();\n    assertIsAddress(this.#fhemExecutorAddress, \"fhemExecutorAddress\");\n\n    this.#version = await this.#hcuLimitContract.getVersion();\n    assertIsString(this.#version, \"version\");\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { FhevmError, assertFhevm } from \"../utils/error.js\";\nimport { removePrefix } from \"../utils/string.js\";\n\nexport type EthersEIP712 = {\n  domain: EthersT.TypedDataDomain;\n  message: Record<string, unknown>;\n  types: Record<string, Array<EthersT.TypedDataField>>;\n};\n\nexport type EIP712Domain = {\n  fields: number;\n  name: string;\n  version: string;\n  chainId: bigint;\n  verifyingContract: string;\n  salt: EthersT.BytesLike;\n};\n\nexport async function signEIP712(\n  signer: EthersT.Signer,\n  domain: EthersT.TypedDataDomain,\n  types: Record<string, Array<EthersT.TypedDataField>>,\n  message: Record<string, unknown>,\n): Promise<string> {\n  const signature = await signer.signTypedData(domain, types, message);\n  const sigRSV = EthersT.Signature.from(signature);\n  const v = 27 + sigRSV.yParity;\n  const r = sigRSV.r;\n  const s = sigRSV.s;\n\n  const result = r + removePrefix(s, \"0x\") + v.toString(16);\n  return result;\n}\n\nexport async function multiSignEIP712(\n  signers: EthersT.Signer[],\n  domain: EthersT.TypedDataDomain,\n  types: Record<string, Array<EthersT.TypedDataField>>,\n  message: Record<string, unknown>,\n): Promise<string[]> {\n  const signatures: string[] = [];\n  for (let idx = 0; idx < signers.length; idx++) {\n    const signer = signers[idx];\n    const signature = await signEIP712(signer!, domain, types, message);\n    signatures.push(signature);\n  }\n  return signatures;\n}\n\nexport function assertIsEIP712Domain(\n  eip712Domain: unknown[],\n  name: string,\n  expectedDomain: { name: string; version: string; chainId: bigint; verifyingContract: string },\n): asserts eip712Domain is [unknown, string, string, bigint, string] {\n  assertFhevm(Array.isArray(eip712Domain), `Invalid ${name} EIP712 domain`);\n  assertFhevm(eip712Domain.length >= 5, `Invalid ${name} EIP712 domain`);\n  assertFhevm(\n    eip712Domain[1] === expectedDomain.name,\n    `Invalid ${name} EIP712 domain name. Got ${eip712Domain[1]}, expected ${expectedDomain.name}`,\n  );\n  assertFhevm(\n    eip712Domain[2] === expectedDomain.version,\n    `Invalid ${name} EIP712 domain name. Got ${eip712Domain[2]}, expected ${expectedDomain.version}`,\n  );\n  assertFhevm(\n    eip712Domain[3] === expectedDomain.chainId,\n    `Invalid ${name} EIP712 domain name. Got ${eip712Domain[3]}, expected ${expectedDomain.chainId}`,\n  );\n  assertFhevm(\n    eip712Domain[4] === expectedDomain.verifyingContract,\n    `Invalid ${name} EIP712 domain name. Got ${eip712Domain[4]}, expected ${expectedDomain.verifyingContract}`,\n  );\n}\n\nexport function isThresholdReached(\n  signersAddress: string[],\n  recoveredAddresses: string[],\n  threshold: number,\n  signerType: string,\n): boolean {\n  const addressMap = new Map<string, number>();\n  recoveredAddresses.forEach((address, index) => {\n    if (addressMap.has(address)) {\n      const duplicateValue = address;\n      throw new FhevmError(\n        `Duplicate ${signerType} signer address found: ${duplicateValue} appears multiple times in recovered addresses`,\n      );\n    }\n    addressMap.set(address, index);\n  });\n\n  for (const address of recoveredAddresses) {\n    if (!signersAddress.includes(address)) {\n      throw new FhevmError(`Invalid address found: ${address} is not in the list of ${signerType} signers`);\n    }\n  }\n\n  return recoveredAddresses.length >= threshold;\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { assertFhevm } from \"./error.js\";\nimport { assertIsString } from \"./string.js\";\n\nexport function assertIsUint8Array(value: unknown, valueName?: string): asserts value is Uint8Array {\n  assertFhevm(value instanceof Uint8Array, `${valueName ?? \"value\"} is not of type Uint8Array`);\n}\n\nexport function assertIsBytesLike(value: unknown, valueName?: string): asserts value is EthersT.BytesLike {\n  assertFhevm(\n    EthersT.isBytesLike(value),\n    `${valueName ?? \"value\"} is not bytes-like (expected a hex string or Uint8Array)`,\n  );\n}\n\nexport function assertIsBytes32String(value: unknown, valueName?: string): asserts value is string {\n  assertIsBytesString(value, 32, valueName);\n}\n\nexport function assertIsBytesString(value: unknown, width?: number, valueName?: string): asserts value is string {\n  assertIsString(value, valueName);\n  if (width === undefined) {\n    assertFhevm(EthersT.isBytesLike(value), `${valueName ?? \"value\"} : ${value} is not a valid bytes string`);\n  } else {\n    assertFhevm(\n      value === EthersT.toBeHex(value, width),\n      `${valueName ?? \"value\"} : ${value} is not a valid bytes${width} string`,\n    );\n  }\n}\n\nexport function assertIsBytes1(value: unknown, valueName?: string): asserts value is Uint8Array {\n  assertIsBytes(value, 1, valueName);\n}\nexport function assertIsBytes8(value: unknown, valueName?: string): asserts value is Uint8Array {\n  assertIsBytes(value, 8, valueName);\n}\nexport function assertIsBytes20(value: unknown, valueName?: string): asserts value is Uint8Array {\n  assertIsBytes(value, 20, valueName);\n}\nexport function assertIsBytes32(value: unknown, valueName?: string): asserts value is Uint8Array {\n  assertIsBytes(value, 32, valueName);\n}\n\nexport function assertIsBytes(value: unknown, width?: number, valueName?: string): asserts value is Uint8Array {\n  assertIsUint8Array(value, valueName);\n  if (width === undefined) {\n    assertFhevm(EthersT.isBytesLike(value), `${valueName ?? \"value\"} : ${value} is not a valid bytes string`);\n  } else {\n    assertFhevm(\n      value.length === width,\n      `${valueName ?? \"value\"} : ${value} is not a valid bytes${width} Uint8Array. Expecting length ${width}, got ${value.length} instead`,\n    );\n  }\n}\n\nexport function bytesToBigInt(byteArray: Uint8Array): bigint {\n  if (!byteArray || byteArray.length === 0) {\n    return BigInt(0);\n  }\n\n  /*\n  \n    Equivalent to: \n    ==============\n\n    // faster: using C/C++ lib bigint-buffer\n    import { toBigIntBE } from \"bigint-buffer\";\n    // Buffer: Node only\n    const buffer = Buffer.from(byteArray);\n    const result = toBigIntBE(buffer);\n    return new Uint8Array(toBufferBE(value, 64));\n\n  */\n\n  return EthersT.toBigInt(byteArray);\n}\n\nexport function uintToBytes(value: EthersT.BigNumberish, width: number): Uint8Array {\n  // May be using EthersT.toBeArray(value) is more efficient.\n  return EthersT.getBytes(EthersT.toBeHex(value, width));\n}\n\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n\n  return result;\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { assertFhevm } from \"./error.js\";\nimport { assertIsString } from \"./string.js\";\n\nexport function uint8ArrayToHexNoPrefix(uint8Array: Uint8Array): string {\n  //return EthersT.hexlify(uint8Array).slice(2);\n  return Array.from(uint8Array)\n    .map((byte) => byte.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n}\n\nexport function numberToHexNoPrefix(num: number): string {\n  const hex = num.toString(16);\n  return hex.length % 2 ? \"0\" + hex : hex;\n}\n\n// Unused\nexport function numberToEvenHexString(num: number): string {\n  if (typeof num !== \"number\" || num < 0) {\n    throw new Error(\"Input should be a non-negative number.\");\n  }\n  let hexString = num.toString(16);\n  if (hexString.length % 2 !== 0) {\n    hexString = \"0\" + hexString;\n  }\n  return hexString;\n}\n\n// To be removed\nexport const fromHexString = (hexString: string): Uint8Array => {\n  const arr = hexString.replace(/^(0x)/, \"\").match(/.{1,2}/g);\n  if (!arr) return new Uint8Array();\n  return Uint8Array.from(arr.map((byte) => parseInt(byte, 16)));\n};\n\n// To be removed\nexport const toHexString = (bytes: Uint8Array): `0x${string}` =>\n  `0x${bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\")}`;\n\nexport function assertIsHexString(value: unknown, valueName?: string): asserts value is string {\n  assertIsString(value, valueName);\n  assertFhevm(EthersT.isHexString(value), `${valueName ?? \"value\"}: ${value} is not a valid hex string.`);\n}\n", "import { ethers as EthersT } from \"ethers\";\n\n// version \"0.8.0-0\"\nexport const InputVerifierInterfaceVersion = \"0.8.0-0\";\n\nexport const InputVerifierPartialInterface: EthersT.Interface = new EthersT.Interface([\n  {\n    inputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"target\",\n        type: \"address\",\n      },\n    ],\n    name: \"AddressEmptyCode\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"AlreadySigner\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"AtLeastOneSignerIsRequired\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"DeserializingInputProofFail\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ECDSAInvalidSignature\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"length\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"ECDSAInvalidSignatureLength\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"s\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"ECDSAInvalidSignatureS\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\",\n      },\n    ],\n    name: \"ERC1967InvalidImplementation\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ERC1967NonPayable\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"EmptyInputProof\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"FailedCall\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InitialSignersSetIsEmpty\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidChainId\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidHandleVersion\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidIndex\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidInitialization\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidInputHandle\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"signerRecovered\",\n        type: \"address\",\n      },\n    ],\n    name: \"InvalidSigner\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotASigner\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n    ],\n    name: \"NotHostOwner\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotInitializing\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotInitializingFromEmptyProxy\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnableInvalidOwner\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnableUnauthorizedAccount\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"numSignatures\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"SignatureThresholdNotReached\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"SignaturesVerificationFailed\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"SignerNull\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"UUPSUnauthorizedCallContext\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"slot\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"UUPSUnsupportedProxiableUUID\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ZeroSignature\",\n    type: \"error\",\n  },\n  {\n    anonymous: false,\n    inputs: [],\n    name: \"EIP712DomainChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"uint64\",\n        name: \"version\",\n        type: \"uint64\",\n      },\n    ],\n    name: \"Initialized\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferStarted\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferred\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"signer\",\n        type: \"address\",\n      },\n    ],\n    name: \"SignerAdded\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"signer\",\n        type: \"address\",\n      },\n    ],\n    name: \"SignerRemoved\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\",\n      },\n    ],\n    name: \"Upgraded\",\n    type: \"event\",\n  },\n  {\n    inputs: [],\n    name: \"EIP712_INPUT_VERIFICATION_TYPE\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"EIP712_INPUT_VERIFICATION_TYPEHASH\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"UPGRADE_INTERFACE_VERSION\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"acceptOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"signer\",\n        type: \"address\",\n      },\n    ],\n    name: \"addSigner\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"cleanTransientStorage\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"eip712Domain\",\n    outputs: [\n      {\n        internalType: \"bytes1\",\n        name: \"fields\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"string\",\n        name: \"name\",\n        type: \"string\",\n      },\n      {\n        internalType: \"string\",\n        name: \"version\",\n        type: \"string\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"chainId\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"address\",\n        name: \"verifyingContract\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"salt\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"extensions\",\n        type: \"uint256[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getCoprocessorSigners\",\n    outputs: [\n      {\n        internalType: \"address[]\",\n        name: \"\",\n        type: \"address[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getHandleVersion\",\n    outputs: [\n      {\n        internalType: \"uint8\",\n        name: \"\",\n        type: \"uint8\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getThreshold\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getVersion\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"verifyingContractSource\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint64\",\n        name: \"chainIDSource\",\n        type: \"uint64\",\n      },\n      {\n        internalType: \"address[]\",\n        name: \"initialSigners\",\n        type: \"address[]\",\n      },\n    ],\n    name: \"initializeFromEmptyProxy\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"isSigner\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"owner\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pendingOwner\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"proxiableUUID\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"reinitializeV3\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"signer\",\n        type: \"address\",\n      },\n    ],\n    name: \"removeSigner\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"renounceOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"transferOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"newImplementation\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"upgradeToAndCall\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: \"address\",\n            name: \"userAddress\",\n            type: \"address\",\n          },\n          {\n            internalType: \"address\",\n            name: \"contractAddress\",\n            type: \"address\",\n          },\n        ],\n        internalType: \"struct FHEVMExecutor.ContextUserInputs\",\n        name: \"context\",\n        type: \"tuple\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"inputHandle\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"inputProof\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"verifyCiphertext\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n]);\n", "import { ethers as EthersT } from \"ethers\";\n\nimport constants from \"../../constants.js\";\nimport type { EIP712Domain, EthersEIP712 } from \"../../ethers/eip712.js\";\nimport { isThresholdReached } from \"../../ethers/eip712.js\";\nimport { assertIsAddress, assertIsAddressArray } from \"../../utils/address.js\";\nimport { assertIsBytes32String } from \"../../utils/bytes.js\";\nimport { FhevmError, assertFhevm, assertIsArray } from \"../../utils/error.js\";\nimport { numberToHexNoPrefix } from \"../../utils/hex.js\";\nimport { assertIsBigUint8, assertIsBigUint256 } from \"../../utils/math.js\";\nimport { assertIsString, ensure0x, removePrefix } from \"../../utils/string.js\";\nimport { FhevmCoprocessorContractWrapper } from \"./FhevmContractWrapper.js\";\nimport { InputVerifierPartialInterface } from \"./interfaces/InputVerifier.itf.js\";\n\nexport type InputVerifierProperties = {\n  signersAddresses?: string[];\n  threshold?: number;\n  eip712Domain?: EIP712Domain;\n};\n\n// Shareable\nexport class InputVerifier extends FhevmCoprocessorContractWrapper {\n  #inputVerifierReadonlyContract: EthersT.Contract | undefined;\n  #inputVerifierContractAddress: string | undefined;\n  #signersAddresses: string[] | undefined;\n  #threshold: number | undefined;\n  #eip712Domain: EIP712Domain | undefined;\n\n  constructor() {\n    super(\"InputVerifier\");\n  }\n\n  public static async create(\n    runner: EthersT.ContractRunner,\n    inputVerifierContractAddress: string,\n    abi?: EthersT.Interface | EthersT.InterfaceAbi,\n    properties?: InputVerifierProperties,\n  ): Promise<InputVerifier> {\n    assertIsAddress(inputVerifierContractAddress, \"inputVerifierContractAddress\");\n\n    const inputVerifier = new InputVerifier();\n    inputVerifier.#inputVerifierContractAddress = inputVerifierContractAddress;\n    inputVerifier.#inputVerifierReadonlyContract = new EthersT.Contract(\n      inputVerifierContractAddress,\n      abi ?? InputVerifierPartialInterface,\n      runner,\n    );\n    inputVerifier.#eip712Domain = properties?.eip712Domain;\n    inputVerifier.#signersAddresses = properties?.signersAddresses;\n    inputVerifier.#threshold = properties?.threshold;\n\n    await inputVerifier._initialize();\n    return inputVerifier;\n  }\n\n  public override get readonlyContract(): EthersT.Contract {\n    assertFhevm(this.#inputVerifierReadonlyContract !== undefined, `InputVerifier wrapper is not initialized`);\n    return this.#inputVerifierReadonlyContract;\n  }\n\n  public override get interface(): EthersT.Interface {\n    assertFhevm(this.#inputVerifierReadonlyContract !== undefined, `InputVerifier wrapper is not yet initialized`);\n    return this.#inputVerifierReadonlyContract.interface;\n  }\n\n  private async _initialize() {\n    assertFhevm(this.#inputVerifierReadonlyContract !== undefined, `InputVerifier wrapper is not initialized`);\n\n    if (!this.#signersAddresses) {\n      const signers = await this.#inputVerifierReadonlyContract.getCoprocessorSigners();\n      this.#signersAddresses = signers;\n    }\n    assertIsAddressArray(this.#signersAddresses);\n\n    if (this.#threshold === undefined) {\n      const threshold = await this.#inputVerifierReadonlyContract.getThreshold();\n      assertIsBigUint8(threshold);\n      this.#threshold = Number(threshold);\n    }\n\n    if (this.#eip712Domain === undefined) {\n      // ignore extensions\n      const eip712Domain = await this.#inputVerifierReadonlyContract.eip712Domain();\n\n      // Add extra checks (in case EIP712 are changing)\n      assertFhevm(eip712Domain.length === 7);\n      assertIsString(eip712Domain[0], \"eip712Domain[0]\");\n      assertIsString(eip712Domain[1], \"eip712Domain[1]\");\n      assertIsString(eip712Domain[2], \"eip712Domain[2]\");\n      assertIsBigUint256(eip712Domain[3], \"eip712Domain[3]\");\n      assertIsAddress(eip712Domain[4], \"eip712Domain[4]\");\n      assertIsBytes32String(eip712Domain[5], \"eip712Domain[5]\");\n      assertFhevm(Array.isArray(eip712Domain[6]) && eip712Domain[6].length === 0, \"eip712Domain[6]\");\n\n      this.#eip712Domain = {\n        fields: Number(BigInt(eip712Domain[0])),\n        name: eip712Domain[1],\n        version: eip712Domain[2],\n        chainId: eip712Domain[3],\n        verifyingContract: eip712Domain[4],\n        salt: eip712Domain[5],\n        // last field is ignored\n      };\n    }\n\n    // Add extra checks (in case EIP712 are chanbging)\n    assertFhevm(this.#eip712Domain.fields === Number(0x0f));\n    assertFhevm(this.#eip712Domain.salt === EthersT.ZeroHash);\n    assertFhevm(this.#eip712Domain.name === constants.INPUT_VERIFICATION_EIP712.domain.name);\n    assertFhevm(this.#eip712Domain.version === constants.INPUT_VERIFICATION_EIP712.domain.version);\n  }\n\n  public get address(): string {\n    assertFhevm(this.#inputVerifierContractAddress !== undefined, `InputVerifier wrapper not initialized`);\n    return this.#inputVerifierContractAddress;\n  }\n\n  // The InputVerifier is always using the gatewayChainId in its eip712 domain\n  public get gatewayChainId(): bigint {\n    assertFhevm(this.#eip712Domain !== undefined, `InputVerifier wrapper not initialized`);\n    return this.#eip712Domain.chainId;\n  }\n\n  // The InputVerifier is always using the address of the \"InputVerification.sol\" contract deployed\n  // on the gateway chainId in its eip712 domain\n  public get gatewayInputVerificationAddress(): string {\n    assertFhevm(this.#eip712Domain !== undefined, `InputVerifier wrapper not initialized`);\n    return this.#eip712Domain.verifyingContract;\n  }\n\n  public get eip712Domain(): EIP712Domain {\n    assertFhevm(this.#eip712Domain !== undefined, `InputVerifier wrapper not initialized`);\n    return this.#eip712Domain;\n  }\n\n  public getCoprocessorSigners(): string[] {\n    assertFhevm(this.#signersAddresses !== undefined, `InputVerifier wrapper not initialized`);\n    return this.#signersAddresses;\n  }\n\n  public getThreshold(): number {\n    assertFhevm(this.#threshold !== undefined, `InputVerifier wrapper not initialized`);\n    return this.#threshold;\n  }\n\n  public async assertMatchCoprocessorSigners(signers: EthersT.Signer[]) {\n    const addresses = this.getCoprocessorSigners();\n\n    assertIsArray(signers, \"signers\");\n    assertFhevm(signers.length === addresses.length, \"signers.length === addresses.length\");\n\n    for (let i = 0; i < addresses.length; ++i) {\n      const s = await signers[i].getAddress();\n      assertFhevm(addresses[i] === s, `addresses[${i}] === await signers[${i}].getAddress()`);\n    }\n  }\n\n  public verifySignatures(\n    handlesBytes32List: EthersT.BytesLike[],\n    userAddress: string,\n    contractAddress: string,\n    contractChainId: number,\n    extraData: string,\n    signatures: string[],\n  ) {\n    assertIsArray(signatures);\n\n    const domain = this.eip712Domain;\n\n    const recoveredAddresses: string[] = signatures.map((signature: string) => {\n      const sig = ensure0x(signature);\n      const recoveredAddress = EthersT.verifyTypedData(\n        {\n          name: domain.name,\n          version: domain.version,\n          chainId: domain.chainId,\n          verifyingContract: domain.verifyingContract,\n        },\n        constants.INPUT_VERIFICATION_EIP712.types,\n        {\n          ctHandles: handlesBytes32List,\n          userAddress,\n          contractAddress,\n          contractChainId,\n          extraData,\n        },\n        sig,\n      );\n      return recoveredAddress;\n    });\n\n    if (!isThresholdReached(this.getCoprocessorSigners(), recoveredAddresses, this.getThreshold(), \"coprocessor\")) {\n      throw new FhevmError(\"Coprocessor signers threshold is not reached\");\n    }\n  }\n\n  // See: fhevm-gateway/contracts/InputVerification.sol\n  public createCiphertextVerificationEIP712(\n    handlesBytes32List: EthersT.BigNumberish[],\n    contractChainId: number,\n    contractAddress: string,\n    userAddress: string,\n    extraData: string,\n  ): EthersEIP712 {\n    assertIsAddress(userAddress, \"userAddress\");\n    assertIsAddress(contractAddress, \"contractAddress\");\n\n    const domain = this.eip712Domain;\n\n    const eip712: EthersEIP712 = {\n      domain: {\n        chainId: domain.chainId,\n        name: domain.name,\n        version: domain.version,\n        verifyingContract: domain.verifyingContract,\n      },\n      types: constants.INPUT_VERIFICATION_EIP712.types,\n      message: {\n        ctHandles: handlesBytes32List.map((handle) => EthersT.zeroPadValue(EthersT.toBeHex(handle), 32)),\n        userAddress: userAddress,\n        contractAddress: contractAddress,\n        contractChainId: contractChainId,\n        extraData,\n      },\n    };\n\n    return eip712;\n  }\n}\n\nexport function computeInputProofHex(\n  handlesBytes32Hex: string[],\n  coprocessorsSignaturesHex: string[],\n  extraData: string,\n): string {\n  const numHandles = handlesBytes32Hex.length;\n  const numCoprocessorSigners = coprocessorsSignaturesHex.length;\n\n  const numHandlesHexByte1 = numberToHexNoPrefix(numHandles);\n  assertFhevm(numHandlesHexByte1.length === 2); // 1 byte\n\n  const numCoprocessorSignersHexByte1 = numberToHexNoPrefix(numCoprocessorSigners);\n  assertFhevm(numCoprocessorSignersHexByte1.length === 2); // 1 byte\n\n  // Compute inputProof\n  let inputProofHex = \"0x\" + numHandlesHexByte1 + numCoprocessorSignersHexByte1;\n\n  // Append the list of handles\n  for (let i = 0; i < numHandles; ++i) {\n    const handlesBytes32HexNoPrefix = removePrefix(handlesBytes32Hex[i], \"0x\");\n    assertFhevm(handlesBytes32HexNoPrefix.length === 2 * 32);\n    inputProofHex += handlesBytes32HexNoPrefix;\n  }\n\n  // Append list of coprocessor signatures\n  coprocessorsSignaturesHex.map((signatureHex) => {\n    const signatureBytes65HexNoPrefix = removePrefix(signatureHex, \"0x\");\n    if (signatureBytes65HexNoPrefix.length !== 2 * 65) {\n      throw new FhevmError(`Invalid coprocessor signature: ${signatureBytes65HexNoPrefix}. Invalid length.`);\n    }\n    inputProofHex += signatureBytes65HexNoPrefix;\n  });\n\n  // Append the extra data to the input proof\n  inputProofHex = EthersT.concat([inputProofHex, extraData]);\n\n  return inputProofHex;\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport constants from \"../constants.js\";\nimport { addressToBytes, assertIsAddress } from \"../utils/address.js\";\nimport {\n  assertIsBytes1,\n  assertIsBytes20,\n  assertIsBytes32,\n  assertIsBytes32String,\n  concatBytes,\n  uintToBytes,\n} from \"../utils/bytes.js\";\nimport { FhevmError, assertFhevm } from \"../utils/error.js\";\nimport { MAX_UINT64, assertIsNumber, toUIntNumber } from \"../utils/math.js\";\nimport { FheType, type FheTypeInfo, checkFheType, getFheTypeInfo } from \"./FheType.js\";\nimport { FhevmType, type FhevmTypeInfo, checkFhevmType, getFhevmTypeInfo } from \"./FhevmType.js\";\n\nexport class FhevmHandle {\n  #hash21: string;\n  #chainId: number;\n  #fhevmType: FhevmType;\n  #fheType: FheType;\n  #version: number;\n  #computed: boolean;\n  #index?: number;\n\n  constructor(\n    hash21: string,\n    chainId: number,\n    fhevmType: FhevmType,\n    fheType: FheType,\n    version: number,\n    computed: boolean,\n    index?: number,\n  ) {\n    this.#hash21 = hash21;\n    this.#chainId = chainId;\n    this.#fhevmType = fhevmType;\n    this.#fheType = fheType;\n    this.#version = version;\n    this.#computed = computed;\n    if (index !== undefined) {\n      this.#index = index;\n    }\n  }\n\n  public get hash21(): string {\n    return this.#hash21;\n  }\n  public get chainId(): number {\n    return this.#chainId;\n  }\n  public get fhevmType(): FhevmType {\n    return this.#fhevmType;\n  }\n  public get fheType(): FheType {\n    return this.#fheType;\n  }\n  public get version(): number {\n    return this.#version;\n  }\n  public get computed(): boolean {\n    return this.#computed;\n  }\n  public get index(): number | undefined {\n    return this.#index;\n  }\n  public get fhevmTypeInfo(): FhevmTypeInfo {\n    return getFhevmTypeInfo(this.#fhevmType);\n  }\n  public get fheTypeInfo(): FheTypeInfo {\n    return getFheTypeInfo(this.#fheType);\n  }\n\n  /**\n   * Handles have the following format:\n   * [21 first random bytes from hashing] | index_21 | chainID_22...29 | type_30 | version_31\n   *\n   * Handle format for user inputs and ops results are as such:\n   * keccak256(keccak256(CiphertextFHEList)||index_handle)[0:20] || index_handle[21] || chainID [22:29] ||  handle_type [30] || handle_version [31]\n   * If the handle stems from computation, the index_handle must be set to 0xff.\n   * The CiphertextFHEList actually contains: 1 byte (= N) for size of handles_list, N bytes for the handles_types : 1 per handle, then the original fhe160list raw ciphertext\n   */\n  public static fromBytes32Hex(handleBytes32Hex: string): FhevmHandle {\n    assertFhevm(\n      typeof handleBytes32Hex === \"string\",\n      `handle argument type mismatch. Got a ${typeof handleBytes32Hex}, expecting a string.`,\n    );\n\n    if (!EthersT.isHexString(handleBytes32Hex, 32)) {\n      throw new FhevmError(`Invalid handle ${handleBytes32Hex}, handle length sould be 66`);\n    }\n\n    const hash21 = handleBytes32Hex.slice(0, 44);\n\n    // Byte 21 = index\n    const handleIndexHex = handleBytes32Hex.slice(44, 46);\n    let handleIndex: number = 0;\n    try {\n      handleIndex = toUIntNumber(\"0x\" + handleIndexHex);\n    } catch {\n      throw new FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 21 does not contain a valid index`);\n    }\n\n    // If the handle stems from computation, the index_handle must be set to 0xff.\n    const computed: boolean = handleIndex === 255;\n\n    // Bytes 22-29 must be the chainId\n    const handleChainIdHex = handleBytes32Hex.slice(46, 62);\n    let chainId: number = 0;\n    try {\n      chainId = toUIntNumber(\"0x\" + handleChainIdHex);\n    } catch {\n      throw new FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 22-29 does not contain a valid chainId`);\n    }\n\n    // Byte30: type\n    const handleTypeHex = handleBytes32Hex.slice(62, 64);\n\n    let fheType: FheType | undefined = undefined;\n    let fhevmType: FhevmType | undefined = undefined;\n    try {\n      const t = toUIntNumber(\"0x\" + handleTypeHex);\n      fheType = t;\n      fhevmType = t;\n    } catch {\n      throw new FhevmError(\n        `Invalid handle ${handleBytes32Hex}, Byte 30 does not contain the a valid (got 0x${handleTypeHex}).`,\n      );\n    }\n\n    checkFheType(fheType);\n    checkFhevmType(fhevmType);\n\n    // Byte31: handle version is 0 at this point\n    const handleVersionHex = handleBytes32Hex.slice(64, 66);\n\n    let version: number = 0;\n    try {\n      version = toUIntNumber(\"0x\" + handleVersionHex);\n    } catch {\n      throw new FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 31 does not contain a valid version number.`);\n    }\n\n    if (version !== constants.FHEVM_HANDLE_VERSION) {\n      throw new FhevmError(\n        `Invalid handle ${handleBytes32Hex}, Byte 31 does not contain the expected version=${constants.FHEVM_HANDLE_VERSION}, got ${version} instead`,\n      );\n    }\n\n    const fhevmHandle = new FhevmHandle(\n      hash21,\n      chainId,\n      fhevmType,\n      fheType,\n      version,\n      computed,\n      handleIndex < 255 ? handleIndex : undefined,\n    );\n\n    // For debug purpose\n    // const _h = fhevmHandle.toHandleBytes32Hex();\n    // if (_h !== handleBytes32Hex) {\n    //   assertFhevmFailed(`${_h} === ${handleBytes32Hex}`);\n    // }\n\n    return fhevmHandle;\n  }\n\n  static verify(\n    handleBytes32: string,\n    expected?: {\n      fhevmType?: FhevmType;\n      fheType?: FheType;\n      chainId?: number;\n    },\n  ): FhevmHandle {\n    assertIsBytes32String(handleBytes32, \"handleBytes32\");\n\n    if (handleBytes32 === EthersT.ZeroHash) {\n      throw new FhevmError(\"Handle is not initialized\");\n    }\n\n    const fhevmHandle = FhevmHandle.fromBytes32Hex(handleBytes32);\n\n    if (expected?.chainId !== undefined) {\n      if (fhevmHandle.chainId !== expected.chainId) {\n        throw new FhevmError(\n          `Chain ID mismatch for handle ${handleBytes32}, expected ${expected.chainId}, but got ${fhevmHandle.chainId} instead.`,\n        );\n      }\n    }\n\n    if (expected?.fhevmType !== undefined) {\n      if (fhevmHandle.fhevmType !== expected.fhevmType) {\n        const fhevmTypeInfo = fhevmHandle.fhevmTypeInfo;\n        const expectedFhevmTypeInfo = getFhevmTypeInfo(expected.fhevmType);\n        throw new FhevmError(\n          `Type mismatch for handle '${handleBytes32}': expected '${expectedFhevmTypeInfo.name}', but got '${fhevmTypeInfo.name}' instead.`,\n        );\n      }\n    }\n\n    if (expected?.fheType !== undefined) {\n      if (fhevmHandle.fheType !== expected.fheType) {\n        const fheTypeInfo = fhevmHandle.fheTypeInfo;\n        const expectedFheTypeInfo = getFheTypeInfo(expected.fheType);\n        throw new FhevmError(\n          `Type mismatch for handle '${handleBytes32}': expected '${expectedFheTypeInfo.type}', but got '${fheTypeInfo.type}' instead.`,\n        );\n      }\n    }\n\n    return fhevmHandle;\n  }\n\n  public toHandleBytes32(): Uint8Array {\n    assertFhevm(Number(this.#fheType) === Number(this.#fhevmType));\n    assertFhevm(\n      (this.#index === undefined && this.#computed) ||\n        (this.#index !== undefined && this.#index < 255 && !this.#computed),\n    );\n\n    const chainId32Bytes = uintToBytes(this.#chainId, 32);\n    const chainId8Bytes = chainId32Bytes.subarray(24, 32);\n\n    assertFhevm(chainId32Bytes.length === 32);\n    assertFhevm(chainId8Bytes.length === 8);\n\n    //const encryptionIndex1Byte = [this.#index === undefined ? 255 : this.#index];\n    const handleHash = EthersT.getBytes(this.#hash21);\n\n    const handleBytes32AsBytes = new Uint8Array(32);\n    handleBytes32AsBytes.set(handleHash, 0);\n    handleBytes32AsBytes[21] = this.#index === undefined ? 255 : this.#index;\n    handleBytes32AsBytes.set(chainId8Bytes, 22);\n    handleBytes32AsBytes[30] = this.#fheType;\n    handleBytes32AsBytes[31] = this.#version;\n\n    return handleBytes32AsBytes;\n  }\n\n  public toHandleBytes32Hex(): string {\n    return EthersT.hexlify(this.toHandleBytes32());\n  }\n\n  public static createInputHandle(\n    blobHashBytes32: Uint8Array,\n    aclAddress: string,\n    chainId: number,\n    fhevmType: FhevmType,\n    ciphertextVersion: number,\n    index: number,\n  ) {\n    const hash21 = FhevmHandle._computeInputHash21(blobHashBytes32, aclAddress, chainId, index);\n    return new FhevmHandle(\n      hash21,\n      chainId,\n      fhevmType,\n      fhevmType as unknown as FheType,\n      ciphertextVersion,\n      false,\n      index,\n    );\n  }\n\n  /**\n   * blobHashBytes32 = keccak256(ciphertextWithZKProof)\n   */\n  private static _computeInputHash21(blobHashBytes32: Uint8Array, aclAddress: string, chainId: number, index: number) {\n    /*\n\n        handle_hash = blobHash 32 Bytes + index 1 Byte + aclAddress 20 Bytes + chainId 32 bytes\n        =======================================================================================\n\n        let mut handle_hash = Keccak256::new();\n        handle_hash.update(blob_hash);\n        handle_hash.update([ct_idx as u8]);\n        handle_hash.update(\n            Address::from_str(&aux_data.acl_contract_address)\n                .expect(\"valid acl_contract_address\")\n                .into_array(),\n        );\n        handle_hash.update(chain_id_bytes);\n        let mut handle = handle_hash.finalize().to_vec();\n\n    */\n    assertIsBytes32(blobHashBytes32, \"blobHash\");\n    assertIsAddress(aclAddress, \"aclAddress\");\n    assertIsNumber(index, \"index\");\n    assertIsNumber(chainId, \"chainId\");\n\n    const encryptionIndex1Byte = new Uint8Array([index]);\n    const aclContractAddress20Bytes = addressToBytes(aclAddress, \"ACL address\");\n    const chainId32Bytes = uintToBytes(chainId, 32);\n\n    assertIsBytes1(encryptionIndex1Byte);\n    assertIsBytes20(aclContractAddress20Bytes);\n    assertIsBytes32(chainId32Bytes);\n\n    return EthersT.keccak256(\n      concatBytes(blobHashBytes32, encryptionIndex1Byte, aclContractAddress20Bytes, chainId32Bytes),\n    );\n  }\n\n  public static computeHandlesHex(\n    ciphertextWithZKProof: Uint8Array,\n    fhevmTypes: FhevmType[],\n    aclContractAddress: string,\n    chainId: number,\n    ciphertextVersion: number,\n  ): string[] {\n    const handlesAsBytes: Uint8Array[] = FhevmHandle.computeHandles(\n      ciphertextWithZKProof,\n      fhevmTypes,\n      aclContractAddress,\n      chainId,\n      ciphertextVersion,\n    );\n    return handlesAsBytes.map(EthersT.hexlify);\n  }\n\n  public static computeHandles(\n    ciphertextWithZKProof: Uint8Array,\n    fhevmTypes: FhevmType[],\n    aclContractAddress: string,\n    chainId: number,\n    ciphertextVersion: number,\n  ): Uint8Array[] {\n    if (BigInt(chainId) > MAX_UINT64) {\n      throw new FhevmError(\"ChainId exceeds maximum allowed value (8 bytes)\"); // fhevm assumes chainID is only taking up to 8 bytes\n    }\n\n    // Should be identical to:\n    // https://github.com/zama-ai/fhevm-backend/blob/bae00d1b0feafb63286e94acdc58dc88d9c481bf/fhevm-engine/zkproof-worker/src/verifier.rs#L301\n    const blobHashBytes32Hex = EthersT.keccak256(ciphertextWithZKProof);\n\n    const blobHashBytes32: Uint8Array = EthersT.getBytes(blobHashBytes32Hex);\n    assertFhevm(blobHashBytes32.length === 32);\n\n    /*\n\n    const ENCRYPTION_TYPES = {\n      1: 0, // ebool takes 2 encrypted bits\n      8: 2,\n      16: 3,\n      32: 4,\n      64: 5,\n      128: 6,\n      160: 7,\n      256: 8,\n      512: 9,\n      1024: 10,\n      2048: 11,\n    };\n\n    */\n    const handles = fhevmTypes.map((fhevmType, encryptionIndex) => {\n      const fhevmHandle = FhevmHandle.createInputHandle(\n        blobHashBytes32,\n        aclContractAddress,\n        chainId,\n        fhevmType,\n        ciphertextVersion,\n        encryptionIndex,\n      );\n      return fhevmHandle.toHandleBytes32();\n    });\n\n    return handles;\n  }\n}\n\n/*\nprivate static computeMockCiphertextWithZKProof(\n    clearTextValuesBigInt: bigint[],\n    fheTypes: FheType[],\n    rand32BufferList: Buffer[],\n  ): Uint8Array {\n    let encrypted = Buffer.alloc(0);\n\n    const numHandles = clearTextValuesBigInt.length;\n\n    assertHHFhevm(rand32BufferList.length === numHandles);\n    assertHHFhevm(fheTypes.length === numHandles);\n\n    // 1. Build the typed values hash\n    for (let i = 0; i < numHandles; ++i) {\n      //type + value as bigint + random(32)\n      const clearTextValueBigInt = clearTextValuesBigInt[i];\n      const fheByteLen = getFheTypeByteLength(fheTypes[i]);\n\n      const fheTypeBuffer = Buffer.from([fheTypes[i]]);\n      const clearTextValueBuffer = toBufferBE(clearTextValueBigInt, fheByteLen);\n      const rand32Buffer = rand32BufferList[i];\n\n      // concatenate 32 random bytes at the end of buffer to simulate encryption noise\n      const encBuffer = Buffer.concat([fheTypeBuffer, clearTextValueBuffer, rand32Buffer]);\n\n      encrypted = Buffer.concat([encrypted, encBuffer]);\n    }\n\n    return new Uint8Array(new Keccak(256).update(Buffer.from(new Uint8Array(encrypted))).digest());\n  }\n\n*/\n\n/*\nconst closestPP = getClosestPP();\n      const pp = publicParams[closestPP]!.publicParams;\n      const buffContract = fromHexString(contractAddress);\n      const buffUser = fromHexString(userAddress);\n      const buffAcl = fromHexString(aclContractAddress);\n      const buffChainId = fromHexString(chainId.toString(16).padStart(64, '0'));\n      const auxData = new Uint8Array(\n        buffContract.length + buffUser.length + buffAcl.length + 32, // buffChainId.length,\n      );\n      auxData.set(buffContract, 0);\n      auxData.set(buffUser, 20);\n      auxData.set(buffAcl, 40);\n      auxData.set(buffChainId, auxData.length - buffChainId.length);\n      const encrypted = builder.build_with_proof_packed(\n        pp,\n        auxData,\n        ZkComputeLoad.Verify,\n      );\n      ciphertextWithZKProof = encrypted.safe_serialize(\n        SERIALIZED_SIZE_LIMIT_CIPHERTEXT,\n      );\n      return ciphertextWithZKProof;\n*/\n\n/*\n\n// Compute input handle\nexport function computeInputHandlesBytes32AsBytes(\n  ciphertextWithZKProof: Uint8Array | string,\n  encryptionTypes: FheType[],\n  chainId: number,\n  aclContractAddress: string,\n  ciphertextVersion: number,\n): Uint8Array[] {\n  const ciphertextWithZKProofUint8Array: Uint8Array =\n    typeof ciphertextWithZKProof === \"string\" ? EthersT.toBeArray(aclContractAddress) : ciphertextWithZKProof;\n\n  const blobHash = new Keccak(256).update(Buffer.from(ciphertextWithZKProofUint8Array)).digest();\n  const aclContractAddress20Bytes = Buffer.from(EthersT.toBeArray(aclContractAddress));\n\n  const chainId32Bytes = Buffer.from(new Uint8Array(toBufferBE(BigInt(chainId), 32)));\n  const chainId8Bytes = chainId32Bytes.subarray(24, 32);\n\n  const handlesBytes32AsBytes: Uint8Array[] = encryptionTypes.map(\n    (encryptionType: FheType, encryptionIndex: number) => {\n      const encryptionIndex1Byte = Buffer.from([encryptionIndex]);\n\n      const handleHashBuffer = Buffer.concat([\n        blobHash,\n        encryptionIndex1Byte,\n        aclContractAddress20Bytes,\n        chainId32Bytes,\n      ]);\n      const handleHash = new Keccak(256).update(handleHashBuffer).digest();\n\n      const handleBytes32AsBytes = new Uint8Array(32);\n      handleBytes32AsBytes.set(handleHash, 0);\n\n      handleBytes32AsBytes[21] = encryptionIndex;\n      chainId8Bytes.copy(handleBytes32AsBytes, 22);\n      handleBytes32AsBytes[30] = encryptionType;\n      handleBytes32AsBytes[31] = ciphertextVersion;\n\n      return handleBytes32AsBytes;\n    },\n  );\n\n  return handlesBytes32AsBytes;\n}\n\n\n*/\n\n/*\n  public static computeHandles(\n    ciphertextWithZKProof: Uint8Array,\n    fhevmTypes: FhevmType[],\n    aclContractAddress: string,\n    chainId: number,\n    ciphertextVersion: number,\n  ): Uint8Array[] {\n\n// Compute input handle (used by provider, must be moved to base)\nexport function computeInputHandlesBytes32AsBytes(\n  ciphertextWithZKProof: Uint8Array | string,\n  encryptionTypes: FheType[],\n  chainId: number,\n  aclContractAddress: string,\n  ciphertextVersion: number,\n): Uint8Array[] {\n  const ciphertextWithZKProofUint8Array: Uint8Array =\n    typeof ciphertextWithZKProof === \"string\" ? EthersT.toBeArray(aclContractAddress) : ciphertextWithZKProof;\n\n  const blobHash = new Keccak(256).update(Buffer.from(ciphertextWithZKProofUint8Array)).digest();\n  const aclContractAddress20Bytes = Buffer.from(EthersT.toBeArray(aclContractAddress));\n\n  const chainId32Bytes = Buffer.from(new Uint8Array(toBufferBE(BigInt(chainId), 32)));\n  const chainId8Bytes = chainId32Bytes.subarray(24, 32);\n\n  const handlesBytes32AsBytes: Uint8Array[] = encryptionTypes.map(\n    (encryptionType: FheType, encryptionIndex: number) => {\n      const encryptionIndex1Byte = Buffer.from([encryptionIndex]);\n\n      const handleHashBuffer = Buffer.concat([\n        blobHash,\n        encryptionIndex1Byte,\n        aclContractAddress20Bytes,\n        chainId32Bytes,\n      ]);\n      const handleHash = new Keccak(256).update(handleHashBuffer).digest();\n\n      const handleBytes32AsBytes = new Uint8Array(32);\n      handleBytes32AsBytes.set(handleHash, 0);\n\n      handleBytes32AsBytes[21] = encryptionIndex;\n      chainId8Bytes.copy(handleBytes32AsBytes, 22);\n      handleBytes32AsBytes[30] = encryptionType;\n      handleBytes32AsBytes[31] = ciphertextVersion;\n\n      return handleBytes32AsBytes;\n    },\n  );\n\n  return handlesBytes32AsBytes;\n}\n\n*/\n", "import { ethers as EthersT } from \"ethers\";\n\n// version \"0.8.0-0\"\nexport const KMSVerifierInterfaceVersion = \"0.8.0-0\";\n\nexport const KMSVerifierPartialInterface: EthersT.Interface = new EthersT.Interface([\n  {\n    inputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"target\",\n        type: \"address\",\n      },\n    ],\n    name: \"AddressEmptyCode\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"DeserializingDecryptionProofFail\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ECDSAInvalidSignature\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"length\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"ECDSAInvalidSignatureLength\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"s\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"ECDSAInvalidSignatureS\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\",\n      },\n    ],\n    name: \"ERC1967InvalidImplementation\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ERC1967NonPayable\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"EmptyDecryptionProof\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"FailedCall\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"InvalidInitialization\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"KMSAlreadySigner\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"invalidSigner\",\n        type: \"address\",\n      },\n    ],\n    name: \"KMSInvalidSigner\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"numSignatures\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"KMSSignatureThresholdNotReached\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"KMSSignerNull\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"KMSZeroSignature\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\",\n      },\n    ],\n    name: \"NotHostOwner\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotInitializing\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"NotInitializingFromEmptyProxy\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnableInvalidOwner\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnableUnauthorizedAccount\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"SignersSetIsEmpty\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ThresholdIsAboveNumberOfSigners\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"ThresholdIsNull\",\n    type: \"error\",\n  },\n  {\n    inputs: [],\n    name: \"UUPSUnauthorizedCallContext\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"slot\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"UUPSUnsupportedProxiableUUID\",\n    type: \"error\",\n  },\n  {\n    anonymous: false,\n    inputs: [],\n    name: \"EIP712DomainChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"uint64\",\n        name: \"version\",\n        type: \"uint64\",\n      },\n    ],\n    name: \"Initialized\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"address[]\",\n        name: \"newKmsSignersSet\",\n        type: \"address[]\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"newThreshold\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"NewContextSet\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferStarted\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferred\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\",\n      },\n    ],\n    name: \"Upgraded\",\n    type: \"event\",\n  },\n  {\n    inputs: [],\n    name: \"DECRYPTION_RESULT_TYPEHASH\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"EIP712_PUBLIC_DECRYPT_TYPE\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"UPGRADE_INTERFACE_VERSION\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"acceptOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address[]\",\n        name: \"newSignersSet\",\n        type: \"address[]\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"newThreshold\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"defineNewContext\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"eip712Domain\",\n    outputs: [\n      {\n        internalType: \"bytes1\",\n        name: \"fields\",\n        type: \"bytes1\",\n      },\n      {\n        internalType: \"string\",\n        name: \"name\",\n        type: \"string\",\n      },\n      {\n        internalType: \"string\",\n        name: \"version\",\n        type: \"string\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"chainId\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"address\",\n        name: \"verifyingContract\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"salt\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"extensions\",\n        type: \"uint256[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getKmsSigners\",\n    outputs: [\n      {\n        internalType: \"address[]\",\n        name: \"\",\n        type: \"address[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getThreshold\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"getVersion\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\",\n      },\n    ],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"verifyingContractSource\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint64\",\n        name: \"chainIDSource\",\n        type: \"uint64\",\n      },\n      {\n        internalType: \"address[]\",\n        name: \"initialSigners\",\n        type: \"address[]\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"initialThreshold\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"initializeFromEmptyProxy\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\",\n      },\n    ],\n    name: \"isSigner\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"owner\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pendingOwner\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"proxiableUUID\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"reinitializeV3\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"renounceOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"threshold\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"setThreshold\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"transferOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"newImplementation\",\n        type: \"address\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"upgradeToAndCall\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32[]\",\n        name: \"handlesList\",\n        type: \"bytes32[]\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"decryptedResult\",\n        type: \"bytes\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"decryptionProof\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"verifyDecryptionEIP712KMSSignatures\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\",\n      },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n]);\n", "import { ethers as EthersT } from \"ethers\";\n\nimport constants from \"../../constants.js\";\nimport type { EIP712Domain, EthersEIP712 } from \"../../ethers/eip712.js\";\nimport { multiSignEIP712 } from \"../../ethers/eip712.js\";\nimport { assertIsAddress, assertIsAddressArray } from \"../../utils/address.js\";\nimport { assertIsBytes32String } from \"../../utils/bytes.js\";\nimport { FhevmError, assertFhevm, assertIsArray } from \"../../utils/error.js\";\nimport { assertIsBigUint8, assertIsBigUint256 } from \"../../utils/math.js\";\nimport { assertIsString } from \"../../utils/string.js\";\nimport { FhevmHandle } from \"../FhevmHandle.js\";\nimport { FhevmType, type FhevmTypeInfo } from \"../FhevmType.js\";\nimport { FhevmCoprocessorContractWrapper } from \"./FhevmContractWrapper.js\";\nimport { KMSVerifierPartialInterface } from \"./interfaces/KMSVerifier.itf.js\";\n\nexport type KMSVerifierProperties = {\n  signersAddresses?: string[];\n  threshold?: number;\n  eip712Domain?: EIP712Domain;\n};\n\n// Shareable\nexport class KMSVerifier extends FhevmCoprocessorContractWrapper {\n  #kmsVerifierContract: EthersT.Contract | undefined;\n  #kmsVerifierContractAddress: string | undefined;\n  #signersAddresses: string[] | undefined;\n  #threshold: number | undefined;\n  #eip712Domain: EIP712Domain | undefined;\n\n  constructor() {\n    super(\"KMSVerifier\");\n  }\n\n  public static async create(\n    runner: EthersT.ContractRunner,\n    kmsVerifierContractAddress: string,\n    abi?: EthersT.Interface | EthersT.InterfaceAbi,\n    properties?: KMSVerifierProperties,\n  ): Promise<KMSVerifier> {\n    assertIsAddress(kmsVerifierContractAddress, \"kmsVerifierContractAddress\");\n\n    if (properties !== undefined) {\n      throw new FhevmError(\"Not yet implemented\");\n    }\n\n    const kmsVerifier = new KMSVerifier();\n    kmsVerifier.#kmsVerifierContractAddress = kmsVerifierContractAddress;\n    kmsVerifier.#kmsVerifierContract = new EthersT.Contract(\n      kmsVerifierContractAddress,\n      abi ?? KMSVerifierPartialInterface,\n      runner,\n    );\n    await kmsVerifier._initialize();\n    return kmsVerifier;\n  }\n\n  public override get readonlyContract(): EthersT.Contract {\n    assertFhevm(this.#kmsVerifierContract !== undefined, `KMSVerifier wrapper is not initialized`);\n    return this.#kmsVerifierContract;\n  }\n\n  public override get interface(): EthersT.Interface {\n    assertFhevm(this.#kmsVerifierContract !== undefined, `KMSVerifier wrapper is not yet initialized`);\n    return this.#kmsVerifierContract.interface;\n  }\n\n  private async _initialize() {\n    assertFhevm(this.#kmsVerifierContract !== undefined, `KMSVerifier wrapper is not initialized`);\n    assertFhevm(this.#signersAddresses === undefined, `KMSVerifier wrapper already initialized`);\n    assertFhevm(this.#threshold === undefined, `KMSVerifier wrapper already initialized`);\n\n    const signers = await this.#kmsVerifierContract.getKmsSigners();\n    assertIsAddressArray(signers);\n    this.#signersAddresses = signers;\n\n    const threshold = await this.#kmsVerifierContract.getThreshold();\n    assertIsBigUint8(threshold);\n    this.#threshold = Number(threshold);\n\n    if (this.#eip712Domain === undefined) {\n      // ignore extensions\n      const eip712Domain = await this.#kmsVerifierContract.eip712Domain();\n      assertFhevm(eip712Domain.length === 7);\n      assertIsString(eip712Domain[0], \"eip712Domain[0]\");\n      assertIsString(eip712Domain[1], \"eip712Domain[1]\");\n      assertIsString(eip712Domain[2], \"eip712Domain[2]\");\n      assertIsBigUint256(eip712Domain[3], \"eip712Domain[3]\");\n      assertIsAddress(eip712Domain[4], \"eip712Domain[4]\");\n      assertIsBytes32String(eip712Domain[5], \"eip712Domain[5]\");\n\n      this.#eip712Domain = {\n        fields: Number(BigInt(eip712Domain[0])),\n        name: eip712Domain[1],\n        version: eip712Domain[2],\n        chainId: eip712Domain[3],\n        verifyingContract: eip712Domain[4],\n        salt: eip712Domain[5],\n        // last field is ignored\n      };\n    }\n\n    // Add extra checks (in case EIP712 are chanbging)\n    assertFhevm(this.#eip712Domain.fields === Number(0x0f));\n    assertFhevm(this.#eip712Domain.salt === EthersT.ZeroHash);\n    assertFhevm(this.#eip712Domain.name === constants.PUBLIC_DECRYPT_EIP712.domain.name);\n    assertFhevm(this.#eip712Domain.version === constants.PUBLIC_DECRYPT_EIP712.domain.version);\n  }\n\n  public get address(): string {\n    assertFhevm(this.#kmsVerifierContractAddress !== undefined, `KMSVerifier wrapper not initialized`);\n    return this.#kmsVerifierContractAddress;\n  }\n\n  // The KMSVerifier is always using the gatewayChainId in its eip712 domain\n  public get gatewayChainId(): bigint {\n    assertFhevm(this.#eip712Domain !== undefined, `KMSVerifier wrapper not initialized`);\n    return this.#eip712Domain.chainId;\n  }\n\n  // The KMSVerifier is always using the address of the \"Decryption.sol\" contract deployed\n  // on the gateway chainId in its eip712 domain\n  public get gatewayDecryptionAddress(): string {\n    assertFhevm(this.#eip712Domain !== undefined, `KMSVerifier wrapper not initialized`);\n    return this.#eip712Domain.verifyingContract;\n  }\n\n  public get eip712Domain(): EIP712Domain {\n    assertFhevm(this.#eip712Domain !== undefined, `KMSVerifier wrapper not initialized`);\n    return this.#eip712Domain;\n  }\n\n  public getKmsSignersAddresses(): string[] {\n    assertFhevm(this.#signersAddresses !== undefined, `KMSVerifier wrapper not initialized`);\n    return this.#signersAddresses;\n  }\n\n  public async assertMatchKmsSigners(signers: EthersT.Signer[]) {\n    const addresses = this.getKmsSignersAddresses();\n\n    assertIsArray(signers, \"signers\");\n    assertFhevm(signers.length === addresses.length, \"signers.length === addresses.length\");\n\n    for (let i = 0; i < addresses.length; ++i) {\n      const s = await signers[i].getAddress();\n      assertFhevm(addresses[i] === s, `addresses[${i}] === await signers[${i}].getAddress()`);\n    }\n  }\n\n  public getThreshold(): number {\n    assertFhevm(this.#threshold !== undefined, `KMSVerifier wrapper not initialized`);\n    return this.#threshold;\n  }\n\n  public createPublicDecryptVerificationEIP712(\n    handlesBytes32List: EthersT.BigNumberish[],\n    decryptedResult: string,\n    extraData: string,\n  ): EthersEIP712 {\n    const domain = this.eip712Domain;\n    const eip712: EthersEIP712 = {\n      domain: {\n        chainId: domain.chainId,\n        name: domain.name,\n        version: domain.version,\n        verifyingContract: domain.verifyingContract,\n      },\n      types: constants.PUBLIC_DECRYPT_EIP712.types,\n      message: {\n        ctHandles: handlesBytes32List,\n        decryptedResult: decryptedResult,\n        extraData,\n      },\n    };\n\n    return eip712;\n  }\n}\n\nexport async function computeDecryptionSignatures(\n  handlesBytes32Hex: string[],\n  clearTextValues: (string | bigint | boolean)[],\n  extraData: string,\n  abiCoder: EthersT.AbiCoder,\n  kmsVerifier: KMSVerifier,\n  kmsSigners: EthersT.Signer[],\n): Promise<{\n  signatures: string[];\n  types: ReadonlyArray<string | EthersT.ParamType>;\n  values: ReadonlyArray<any>;\n  decryptedResult: string;\n}> {\n  const fhevmHandles: FhevmHandle[] = handlesBytes32Hex.map((handleBytes32Hex) =>\n    FhevmHandle.fromBytes32Hex(handleBytes32Hex),\n  );\n\n  assertFhevm(handlesBytes32Hex.length === clearTextValues.length);\n\n  const abiTypes: string[] = [];\n  const abiValues: (string | bigint)[] = [];\n\n  for (let i = 0; i < handlesBytes32Hex.length; ++i) {\n    let clearTextValue: string | bigint | boolean = clearTextValues[i];\n    if (typeof clearTextValue === \"boolean\") {\n      clearTextValue = clearTextValue ? \"0x01\" : \"0x00\";\n    }\n    const clearTextValueBigInt = BigInt(clearTextValue);\n    const fhevmTypeInfo: FhevmTypeInfo = fhevmHandles[i].fhevmTypeInfo;\n\n    abiTypes.push(fhevmTypeInfo.solidityTypeName);\n\n    switch (fhevmTypeInfo.type) {\n      case FhevmType.eaddress: {\n        // string\n        abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(40, \"0\")}`);\n        break;\n      }\n      case FhevmType.ebool: {\n        // bigint (0 or 1)\n        abiValues.push(clearTextValueBigInt);\n        break;\n      }\n      case FhevmType.euint4:\n      case FhevmType.euint8:\n      case FhevmType.euint16:\n      case FhevmType.euint32:\n      case FhevmType.euint64:\n      case FhevmType.euint128:\n      case FhevmType.euint256: {\n        // bigint\n        abiValues.push(clearTextValueBigInt);\n        break;\n      }\n      case FhevmType.ebytes64: {\n        // string\n        abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(128, \"0\")}`);\n        break;\n      }\n      case FhevmType.ebytes128: {\n        // string\n        abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(256, \"0\")}`);\n        break;\n      }\n      case FhevmType.ebytes256: {\n        // string\n        abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(512, \"0\")}`);\n        break;\n      }\n      default: {\n        throw new FhevmError(\n          `Unsupported Fhevm primitive type id: ${fhevmTypeInfo.type}, name: ${fhevmTypeInfo.name}, solidity: ${fhevmTypeInfo.solidityTypeName}`,\n        );\n      }\n    }\n  }\n\n  // 1. 31 is just a dummy uint256 requestID to get correct abi encoding for the remaining arguments\n  //    (i.e everything except the requestID)\n  // 2. Adding also a dummy empty array of bytes for correct abi-encoding when used with signatures\n  const encodedData = abiCoder.encode([\"uint256\", ...abiTypes, \"bytes[]\"], [31, ...abiValues, []]);\n\n  // 1. We pop the dummy requestID to get the correct value to pass for `decryptedCts`\n  // 2. We also pop the last 32 bytes (empty bytes[])\n  const decryptedResult = \"0x\" + encodedData.slice(66).slice(0, -64);\n  assertFhevm(\n    decryptedResult === \"0x\" + encodedData.slice(66, -64),\n    \"decryptedResult === '0x' + encodedData.slice(66, -64)\",\n  );\n\n  const eip712 = kmsVerifier.createPublicDecryptVerificationEIP712(handlesBytes32Hex, decryptedResult, extraData);\n\n  const decryptResultsEIP712signatures: string[] = await multiSignEIP712(\n    kmsSigners,\n    eip712.domain,\n    eip712.types,\n    eip712.message,\n  );\n\n  return { signatures: decryptResultsEIP712signatures, types: abiTypes, values: abiValues, decryptedResult };\n}\n\nexport async function computeDecryptionCallbackSignaturesAndCalldata(\n  handlesBytes32Hex: string[],\n  clearTextValuesString: string[],\n  extraData: string,\n  requestID: bigint,\n  callbackSelectorBytes4Hex: string,\n  abiCoder: EthersT.AbiCoder,\n  kmsVerifier: KMSVerifier,\n  kmsSigners: EthersT.Signer[],\n): Promise<{ calldata: string }> {\n  assertFhevm(extraData === EthersT.solidityPacked([\"uint8\"], [0]), \"extraData must be 0x00\");\n\n  const { signatures, types, values } = await computeDecryptionSignatures(\n    handlesBytes32Hex,\n    clearTextValuesString,\n    extraData,\n    abiCoder,\n    kmsVerifier,\n    kmsSigners,\n  );\n\n  // Build the decryptionProof as numSigners + KMS signatures + extraData\n  const packedNumSigners = EthersT.solidityPacked([\"uint8\"], [signatures.length]);\n  const packedSignatures = EthersT.solidityPacked(Array(signatures.length).fill(\"bytes\"), signatures);\n  const decryptionProof = EthersT.concat([packedNumSigners, packedSignatures, extraData]);\n\n  // ABI encode the list of values in order to pass them in the callback\n  const encodedCleartexts = abiCoder.encode([...types], [...values]);\n\n  const calldata =\n    callbackSelectorBytes4Hex +\n    abiCoder.encode([\"uint256\", \"bytes\", \"bytes\"], [requestID, encodedCleartexts, decryptionProof]).slice(2);\n\n  return { calldata };\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { assertIsAddress } from \"../../utils/address.js\";\nimport { assertFhevm } from \"../../utils/error.js\";\nimport { FhevmDecryptionOracleContractWrapper } from \"./FhevmContractWrapper.js\";\nimport { KMSVerifierPartialInterface } from \"./interfaces/KMSVerifier.itf.js\";\n\n// Shareable\nexport class ZamaFheDecryptionOracle extends FhevmDecryptionOracleContractWrapper {\n  #zamaFheDecryptionOracleContract: EthersT.Contract | undefined;\n  #zamaFheDecryptionOracleContractAddress: string | undefined;\n\n  constructor() {\n    super(\"DecryptionOracle\");\n  }\n\n  public static async create(\n    runner: EthersT.ContractRunner,\n    zamaFheDecryptionOracleContractAddress: string,\n    abi?: EthersT.Interface | EthersT.InterfaceAbi,\n  ): Promise<ZamaFheDecryptionOracle> {\n    assertIsAddress(zamaFheDecryptionOracleContractAddress, \"zamaFheDecryptionOracleContractAddress\");\n\n    const decryptionOracle = new ZamaFheDecryptionOracle();\n    decryptionOracle.#zamaFheDecryptionOracleContractAddress = zamaFheDecryptionOracleContractAddress;\n    decryptionOracle.#zamaFheDecryptionOracleContract = new EthersT.Contract(\n      zamaFheDecryptionOracleContractAddress,\n      abi ?? KMSVerifierPartialInterface,\n      runner,\n    );\n    await decryptionOracle._initialize();\n    return decryptionOracle;\n  }\n\n  public override get readonlyContract(): EthersT.Contract {\n    assertFhevm(\n      this.#zamaFheDecryptionOracleContract !== undefined,\n      `ZamaFheDecryptionOracle wrapper is not yet initialized`,\n    );\n    return this.#zamaFheDecryptionOracleContract;\n  }\n\n  public override get interface(): EthersT.Interface {\n    assertFhevm(\n      this.#zamaFheDecryptionOracleContract !== undefined,\n      `ZamaFheDecryptionOracle wrapper is not yet initialized`,\n    );\n    return this.#zamaFheDecryptionOracleContract.interface;\n  }\n\n  private async _initialize() {\n    assertFhevm(\n      this.#zamaFheDecryptionOracleContract !== undefined,\n      `ZamaFheDecryptionOracle wrapper is not initialized`,\n    );\n  }\n\n  public get address(): string {\n    assertFhevm(\n      this.#zamaFheDecryptionOracleContractAddress !== undefined,\n      `ZamaFheDecryptionOracle wrapper not initialized`,\n    );\n    return this.#zamaFheDecryptionOracleContractAddress;\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport type { FhevmInstanceConfig } from \"../../relayer-sdk/types.js\";\nimport { FhevmError, assertFhevm } from \"../../utils/error.js\";\nimport { ACL, type ACLProperties } from \"./ACL.js\";\nimport { FHEVMExecutor, type FHEVMExecutorProperties } from \"./FHEVMExecutor.js\";\nimport type {\n  FhevmContractWrapper,\n  FhevmCoprocessorContractWrapper,\n  FhevmDecryptionOracleContractWrapper,\n} from \"./FhevmContractWrapper.js\";\nimport { HCULimit, type HCULimitProperties } from \"./HCULimit.js\";\nimport { InputVerifier, type InputVerifierProperties } from \"./InputVerifier.js\";\nimport { KMSVerifier, type KMSVerifierProperties } from \"./KMSVerifier.js\";\nimport { ZamaFheDecryptionOracle } from \"./ZamaFheDecryptionOracle.js\";\nimport {\n  type FhevmContractName,\n  type FhevmCoprocessorContractName,\n  type FhevmDecryptionOracleContractName,\n} from \"./index.js\";\n\nexport class FhevmContractsRepository {\n  #acl: ACL | undefined;\n  #fhevmExecutor: FHEVMExecutor | undefined;\n  #inputVerifier: InputVerifier | undefined;\n  #kmsVerifier: KMSVerifier | undefined;\n  #hcuLimit: HCULimit | undefined;\n  #zamaFheDecryptionOracle: ZamaFheDecryptionOracle | undefined;\n  #addressToContract: Record<string, FhevmContractWrapper> | undefined;\n\n  constructor() {}\n\n  public static async create(\n    ethersReadonlyProvider: EthersT.Provider,\n    config: {\n      aclContractAddress: string;\n      kmsContractAddress: string;\n      zamaFheDecryptionOracleAddress?: string;\n      aclAbi?: EthersT.Interface | EthersT.InterfaceAbi;\n      fhevmExecutorAbi?: EthersT.Interface | EthersT.InterfaceAbi;\n      hcuLimitAbi?: EthersT.Interface | EthersT.InterfaceAbi;\n      kmsVerifierAbi?: EthersT.Interface | EthersT.InterfaceAbi;\n      inputVerifierAbi?: EthersT.Interface | EthersT.InterfaceAbi;\n      zamaFheDecryptionOracleAbi?: EthersT.Interface | EthersT.InterfaceAbi;\n      aclProperties?: ACLProperties;\n      fhevmExecutorProperties?: FHEVMExecutorProperties;\n      inputVerifierProperties?: InputVerifierProperties;\n      kmsVerifierProperties?: KMSVerifierProperties;\n      hcuLimitProperties?: HCULimitProperties;\n    },\n  ): Promise<FhevmContractsRepository> {\n    if (!EthersT.isAddress(config.aclContractAddress)) {\n      throw new FhevmError(`Invalid ACL contract address ${config.aclContractAddress}`);\n    }\n    if (!EthersT.isAddress(config.kmsContractAddress)) {\n      throw new FhevmError(`Invalid KMSVerifier contract address ${config.kmsContractAddress}`);\n    }\n    if (config.zamaFheDecryptionOracleAddress !== undefined) {\n      if (!EthersT.isAddress(config.zamaFheDecryptionOracleAddress)) {\n        throw new FhevmError(`Invalid DecryptionOracle contract address ${config.zamaFheDecryptionOracleAddress}`);\n      }\n    }\n\n    const repo = new FhevmContractsRepository();\n\n    repo.#acl = await ACL.create(\n      ethersReadonlyProvider,\n      config.aclContractAddress,\n      config.aclAbi,\n      config.aclProperties,\n    );\n    repo.#fhevmExecutor = await FHEVMExecutor.create(\n      ethersReadonlyProvider,\n      repo.#acl.fhevmExecutorAddress,\n      config.fhevmExecutorAbi,\n      config.fhevmExecutorProperties,\n    );\n    repo.#inputVerifier = await InputVerifier.create(\n      ethersReadonlyProvider,\n      repo.#fhevmExecutor.inputVerifierAddress,\n      config.inputVerifierAbi,\n    );\n    repo.#kmsVerifier = await KMSVerifier.create(\n      ethersReadonlyProvider,\n      config.kmsContractAddress,\n      config.kmsVerifierAbi,\n    );\n    repo.#hcuLimit = await HCULimit.create(\n      ethersReadonlyProvider,\n      repo.#fhevmExecutor.hcuLimitAddress,\n      config.hcuLimitAbi,\n    );\n    if (config.zamaFheDecryptionOracleAddress !== undefined) {\n      repo.#zamaFheDecryptionOracle = await ZamaFheDecryptionOracle.create(\n        ethersReadonlyProvider,\n        config.zamaFheDecryptionOracleAddress,\n        config.zamaFheDecryptionOracleAbi,\n      );\n    }\n\n    if (repo.#inputVerifier.gatewayChainId !== repo.#kmsVerifier.gatewayChainId) {\n      throw new FhevmError(\n        `gateway chainId mismatch. InputVerifier.gatewayChainId=${repo.#inputVerifier.gatewayChainId} differs from KMSVerifier.gatewayChainId=${repo.#kmsVerifier.gatewayChainId}`,\n      );\n    }\n\n    repo.#addressToContract = {};\n\n    repo.#addressToContract[repo.#acl.address.toLowerCase()] = repo.#acl;\n    repo.#addressToContract[repo.#fhevmExecutor.address.toLowerCase()] = repo.#fhevmExecutor;\n    if (repo.#zamaFheDecryptionOracle) {\n      repo.#addressToContract[repo.#zamaFheDecryptionOracle.address.toLowerCase()] = repo.#zamaFheDecryptionOracle;\n    }\n    repo.#addressToContract[repo.#inputVerifier.address.toLowerCase()] = repo.#inputVerifier;\n    repo.#addressToContract[repo.#kmsVerifier.address.toLowerCase()] = repo.#kmsVerifier;\n    repo.#addressToContract[repo.#hcuLimit.address.toLowerCase()] = repo.#hcuLimit;\n\n    Object.freeze(repo.#addressToContract);\n\n    return repo;\n  }\n\n  public addressToContractMap(): Record<string, FhevmContractWrapper> {\n    assertFhevm(this.#addressToContract !== undefined, \"FhevmContractsRepository is not initialized\");\n    return this.#addressToContract;\n  }\n\n  public getContractFromAddress(address: string): FhevmContractWrapper | undefined {\n    const a = address.toLowerCase();\n    if (a === this.acl.address.toLowerCase()) {\n      return this.acl;\n    }\n    if (a === this.fhevmExecutor.address.toLowerCase()) {\n      return this.fhevmExecutor;\n    }\n    if (a === this.inputVerifier.address.toLowerCase()) {\n      return this.inputVerifier;\n    }\n    if (a === this.kmsVerifier.address.toLowerCase()) {\n      return this.kmsVerifier;\n    }\n    if (a === this.hcuLimit.address.toLowerCase()) {\n      return this.hcuLimit;\n    }\n    if (this.zamaFheDecryptionOracle) {\n      if (a === this.zamaFheDecryptionOracle.address.toLowerCase()) {\n        return this.zamaFheDecryptionOracle;\n      }\n    }\n    return undefined;\n  }\n\n  public getContractFromName(name: FhevmContractName): FhevmContractWrapper | undefined {\n    switch (name) {\n      case \"ACL\":\n        return this.acl;\n      case \"FHEVMExecutor\":\n        return this.fhevmExecutor;\n      case \"InputVerifier\":\n        return this.inputVerifier;\n      case \"KMSVerifier\":\n        return this.kmsVerifier;\n      case \"HCULimit\":\n        return this.hcuLimit;\n      case \"DecryptionOracle\":\n        return this.zamaFheDecryptionOracle;\n      default: {\n        throw new FhevmError(`Unsupported contract ${name}`);\n      }\n    }\n  }\n\n  public getCoprocessorContractFromName(name: FhevmCoprocessorContractName): FhevmCoprocessorContractWrapper {\n    switch (name) {\n      case \"ACL\":\n        return this.acl;\n      case \"FHEVMExecutor\":\n        return this.fhevmExecutor;\n      case \"InputVerifier\":\n        return this.inputVerifier;\n      case \"KMSVerifier\":\n        return this.kmsVerifier;\n      case \"HCULimit\":\n        return this.hcuLimit;\n      default: {\n        throw new FhevmError(`Unsupported coprocessor contract ${name}`);\n      }\n    }\n  }\n\n  public getDecryptionOracleContractFromName(\n    name: FhevmDecryptionOracleContractName,\n  ): FhevmDecryptionOracleContractWrapper | undefined {\n    switch (name) {\n      case \"DecryptionOracle\":\n        return this.zamaFheDecryptionOracle;\n      default: {\n        throw new FhevmError(`Unsupported decryption oracle contract ${name}`);\n      }\n    }\n  }\n\n  public getCoprocessorInterfaceFromName(name: FhevmCoprocessorContractName): EthersT.Interface {\n    return this.getCoprocessorContractFromName(name).interface;\n  }\n\n  public getDecryptionOracleInterfaceFromName(name: FhevmDecryptionOracleContractName): EthersT.Interface | undefined {\n    const c = this.getDecryptionOracleContractFromName(name);\n    if (c === undefined) {\n      return undefined;\n    }\n    return c.interface;\n  }\n\n  public get zamaFheDecryptionOracle(): ZamaFheDecryptionOracle | undefined {\n    return this.#zamaFheDecryptionOracle;\n  }\n\n  public get acl(): ACL {\n    assertFhevm(this.#acl !== undefined, \"FhevmContractsRepository is not initialized\");\n    return this.#acl;\n  }\n\n  public get fhevmExecutor(): FHEVMExecutor {\n    assertFhevm(this.#fhevmExecutor !== undefined, \"FhevmContractsRepository is not initialized\");\n    return this.#fhevmExecutor;\n  }\n\n  public get inputVerifier(): InputVerifier {\n    assertFhevm(this.#inputVerifier !== undefined, \"FhevmContractsRepository is not initialized\");\n    return this.#inputVerifier;\n  }\n\n  public get kmsVerifier(): KMSVerifier {\n    assertFhevm(this.#kmsVerifier !== undefined, \"FhevmContractsRepository is not initialized\");\n    return this.#kmsVerifier;\n  }\n\n  public get hcuLimit(): HCULimit {\n    assertFhevm(this.#hcuLimit !== undefined, \"FhevmContractsRepository is not initialized\");\n    return this.#hcuLimit;\n  }\n\n  public getFhevmInstanceConfig(params: {\n    chainId: number;\n    relayerUrl: string;\n  }): FhevmInstanceConfig & { fhevmExecutorContractAddress: string; decryptionOracleAddress?: string } {\n    assertFhevm(this.#acl !== undefined, \"FhevmContractsRepository is not initialized\");\n    assertFhevm(this.#fhevmExecutor !== undefined, \"FhevmContractsRepository is not initialized\");\n    assertFhevm(this.#kmsVerifier !== undefined, \"FhevmContractsRepository is not initialized\");\n    assertFhevm(this.#inputVerifier !== undefined, \"FhevmContractsRepository is not initialized\");\n\n    const decryptionOracleAddress = this.#zamaFheDecryptionOracle?.address;\n\n    return {\n      aclContractAddress: this.#acl.address,\n      fhevmExecutorContractAddress: this.#fhevmExecutor?.address,\n      chainId: params.chainId,\n      gatewayChainId: Number(this.#kmsVerifier.gatewayChainId),\n      inputVerifierContractAddress: this.#inputVerifier.address,\n      kmsContractAddress: this.#kmsVerifier.address,\n      verifyingContractAddressDecryption: this.#kmsVerifier.gatewayDecryptionAddress,\n      verifyingContractAddressInputVerification: this.#inputVerifier.gatewayInputVerificationAddress,\n      relayerUrl: params.relayerUrl,\n      ...(decryptionOracleAddress && { decryptionOracleAddress }),\n    };\n  }\n}\n", "import { assertIsAddress } from \"../utils/address.js\";\nimport { assertIsBytesString } from \"../utils/bytes.js\";\nimport { FhevmError, assertFhevm } from \"../utils/error.js\";\nimport { assertIsBigUint8, assertIsBigUint256 } from \"../utils/math.js\";\n\nexport function assertEventArgIsBigUint8(value: unknown, eventName: string, argIndex: number): asserts value is bigint {\n  assertIsBigUint8(value, `${eventName} event arg #${argIndex}`);\n}\n\nexport function assertEventArgIsBigUint256(\n  value: unknown,\n  eventName: string,\n  argIndex: number,\n): asserts value is bigint {\n  assertIsBigUint256(value, `${eventName} event arg #${argIndex}`);\n}\n\nexport function assertEventArgIsBytes1String(\n  value: unknown,\n  eventName: string,\n  argIndex: number,\n): asserts value is string {\n  _assertEventArgIsBytesString(value, eventName, argIndex, 1);\n}\n\nexport function assertEventArgIsBytes4String(\n  value: unknown,\n  eventName: string,\n  argIndex: number,\n): asserts value is string {\n  _assertEventArgIsBytesString(value, eventName, argIndex, 4);\n}\n\nexport function assertEventArgIsBytes8String(\n  value: unknown,\n  eventName: string,\n  argIndex: number,\n): asserts value is string {\n  _assertEventArgIsBytesString(value, eventName, argIndex, 8);\n}\n\nexport function assertEventArgIsBytes16String(\n  value: unknown,\n  eventName: string,\n  argIndex: number,\n): asserts value is string {\n  _assertEventArgIsBytesString(value, eventName, argIndex, 16);\n}\n\nexport function assertEventArgIsBytes32String(\n  value: unknown,\n  eventName: string,\n  argIndex: number,\n): asserts value is string {\n  _assertEventArgIsBytesString(value, eventName, argIndex, 32);\n}\n\nexport function assertEventArgIsBytesString(\n  value: unknown,\n  eventName: string,\n  argIndex: number,\n): asserts value is string {\n  _assertEventArgIsBytesString(value, eventName, argIndex);\n}\n\nfunction _assertEventArgIsBytesString(\n  value: unknown,\n  eventName: string,\n  argIndex: number,\n  width?: number,\n): asserts value is string {\n  assertIsBytesString(value, width, `${eventName} event arg #${argIndex}`);\n}\n\nexport function assertEventArgIsAddress(value: unknown, eventName: string, argIndex: number): asserts value is string {\n  assertIsAddress(value, `${eventName} event arg #${argIndex}`);\n}\n\nexport class BlockLogCursor {\n  #blockNumber: number = -1;\n  #blockLogIndex: number = -1;\n\n  constructor(fromBlockNumber: number) {\n    // We want the next block number to be `fromBlockNumber`\n    // This usually happens when running tests in Anvil. The node is running with\n    // plenty of old handles. So we need to start parsing events at a specific block number.\n    // All events prior to this block number should be ignored\n    this.#blockNumber = fromBlockNumber <= 0 ? -1 : fromBlockNumber - 1;\n  }\n\n  static check(blockNumber: number, blockLogIndex: number) {\n    if (blockNumber < 0 || blockLogIndex < 0) {\n      throw new FhevmError(`Invalid event at blockNumber=${blockNumber}, logIndex=${blockLogIndex}.`);\n    }\n  }\n\n  public get isEmpty(): boolean {\n    const empty = this.#blockNumber < 0;\n    if (empty) {\n      assertFhevm(this.#blockLogIndex < 0);\n    } else {\n      assertFhevm(this.#blockLogIndex >= 0);\n    }\n    return empty;\n  }\n\n  public get nextBlockNumber(): number {\n    if (this.#blockNumber < 0) {\n      return 0;\n    }\n    return this.#blockNumber + 1;\n  }\n\n  public get blockNumber(): number {\n    return this.#blockNumber;\n  }\n\n  public get blockLogIndex(): number {\n    return this.#blockLogIndex;\n  }\n\n  /*\n    Returns `true` if this > {blockNumber, blockLogIndex}\n  */\n  gt(blockNumber: number, blockLogIndex: number) {\n    BlockLogCursor.check(blockNumber, blockLogIndex);\n    if (this.#blockNumber === blockNumber) {\n      return this.#blockLogIndex > blockLogIndex;\n    }\n    return this.#blockNumber > blockNumber;\n  }\n\n  /*\n    Returns `true` if this == {blockNumber, blockLogIndex}\n  */\n  eq(blockNumber: number, blockLogIndex: number) {\n    BlockLogCursor.check(blockNumber, blockLogIndex);\n    return this.#blockNumber === blockNumber && this.#blockLogIndex === blockLogIndex;\n  }\n\n  /*\n    Returns `true` if this >= {blockNumber, blockLogIndex}\n  */\n  ge(blockNumber: number, blockLogIndex: number) {\n    return this.gt(blockNumber, blockLogIndex) || this.eq(blockNumber, blockLogIndex);\n  }\n\n  /*\n    throws an error if this >= {blockNumber, blockLogIndex}\n  */\n  updateForward(blockNumber: number, blockLogIndex: number) {\n    BlockLogCursor.check(blockNumber, blockLogIndex);\n    if (this.ge(blockNumber, blockLogIndex)) {\n      throw new FhevmError(\n        `Parse event at blockNumber=${blockNumber}, logIndex=${blockLogIndex} in backward order. Current blockNumber=${this.#blockNumber}, logIndex=${this.#blockLogIndex}`,\n      );\n    }\n    this.#blockNumber = blockNumber;\n    this.#blockLogIndex = blockLogIndex;\n  }\n\n  /*\n    throws an error if this == {blockNumber, blockLogIndex}\n  */\n  updateForwardOrBackward(blockNumber: number, blockLogIndex: number) {\n    BlockLogCursor.check(blockNumber, blockLogIndex);\n    if (this.eq(blockNumber, blockLogIndex)) {\n      throw new FhevmError(\n        `Expecting event at a different position (blockNumber=${blockNumber}, logIndex=${blockLogIndex}).`,\n      );\n    }\n    this.#blockNumber = blockNumber;\n    this.#blockLogIndex = blockLogIndex;\n  }\n\n  update(blockNumber: number, blockLogIndex: number) {\n    BlockLogCursor.check(blockNumber, blockLogIndex);\n    this.#blockNumber = blockNumber;\n    this.#blockLogIndex = blockLogIndex;\n  }\n}\n", "import { assertIsBytes32String } from \"../../utils/bytes.js\";\nimport { FhevmError } from \"../../utils/error.js\";\nimport { assertIsHexString } from \"../../utils/hex.js\";\nimport { assertIsUintNumber } from \"../../utils/math.js\";\nimport type { FhevmDBEntry, FhevmDBHandleMetadata } from \"./FhevmDB.js\";\n\nexport function checkInsertArgs(handleBytes32Hex: string, clearText: bigint | string, metadata: FhevmDBHandleMetadata) {\n  assertIsBytes32String(handleBytes32Hex);\n  assertIsBytes32String(metadata.transactionHash);\n  assertIsUintNumber(metadata.blockNumber);\n  assertIsUintNumber(metadata.index);\n\n  if (typeof clearText !== \"bigint\" && typeof clearText !== \"string\") {\n    throw new FhevmError(`Invalid clearText argument, expecting bigint or string, got ${typeof clearText} instead`);\n  }\n\n  if (typeof clearText === \"string\") {\n    assertIsHexString(clearText, \"clearText argument\");\n  }\n}\n\nexport function checkQueryArgs(handleBytes32Hex: string) {\n  assertIsBytes32String(handleBytes32Hex);\n}\n\nexport function fhevmDBEntryToString(entry: FhevmDBEntry) {\n  return `${entry.metadata.blockNumber}:${entry.metadata.index}:${entry.metadata.transactionHash}:${entry.clearTextHex}`;\n}\n\nexport function stringToFhevmDBEntry(str: string): FhevmDBEntry {\n  const elements = str.split(\":\");\n  return {\n    clearTextHex: elements[3],\n    metadata: {\n      blockNumber: Number.parseInt(elements[0]),\n      index: Number.parseInt(elements[1]),\n      transactionHash: elements[2],\n    },\n  };\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { BlockLogCursor } from \"../../ethers/event.js\";\nimport { FhevmError } from \"../../utils/error.js\";\nimport type { FhevmDB, FhevmDBEntry, FhevmDBHandleMetadata } from \"./FhevmDB.js\";\nimport { checkInsertArgs, checkQueryArgs, fhevmDBEntryToString, stringToFhevmDBEntry } from \"./utils.js\";\n\nconst __STRICT__: boolean = false;\n\nexport class FhevmDBMap implements FhevmDB {\n  #handleBytes32HexToClearText: Map<string, string> | undefined;\n  #counter: BlockLogCursor | undefined;\n  #randomCounter: number = 0;\n  #fromBlockNumber: number = -1;\n\n  public constructor() {}\n\n  incRand(): void {\n    this.#randomCounter++;\n  }\n\n  get randomCounter(): number {\n    return this.#randomCounter;\n  }\n\n  get fromBlockNumber(): number {\n    return this.#fromBlockNumber;\n  }\n\n  get countHandles(): number {\n    if (!this.#handleBytes32HexToClearText) {\n      throw new FhevmError(`FhevmDB not yet initialized`);\n    }\n    return this.#handleBytes32HexToClearText.size;\n  }\n\n  private _get(): Map<string, string> {\n    if (!this.#handleBytes32HexToClearText) {\n      throw new FhevmError(`FhevmDB not yet initialized`);\n    }\n    return this.#handleBytes32HexToClearText;\n  }\n\n  public async init(fromBlockNumber: number): Promise<boolean> {\n    if (this.#handleBytes32HexToClearText) {\n      throw new FhevmError(`FhevmDB already initialized`);\n    }\n    this.#fromBlockNumber = fromBlockNumber;\n    this.#counter = new BlockLogCursor(fromBlockNumber);\n    this.#handleBytes32HexToClearText = new Map();\n    return true;\n  }\n\n  /**\n   * Reset can be usefull to test deterministic handles like trivialEncrypt.\n   */\n  public async reset(): Promise<void> {\n    this._get().clear();\n  }\n\n  private async _insertHandleBytes32(\n    handleBytes32Hex: string,\n    clearTextBigIntOrHex: bigint | string,\n    metadata: FhevmDBHandleMetadata,\n    options?: { replace?: boolean },\n  ): Promise<void> {\n    if (!this.#counter) {\n      throw new FhevmError(`FhevmDB not yet initialized`);\n    }\n    const map: Map<string, string> = this._get();\n    if (__STRICT__) {\n      if (options?.replace !== true) {\n        if (map.has(handleBytes32Hex)) {\n          throw new FhevmError(`Handle ${handleBytes32Hex} already exists.`);\n        }\n      }\n    }\n\n    if (typeof clearTextBigIntOrHex !== \"string\") {\n      clearTextBigIntOrHex = clearTextBigIntOrHex.toString();\n    }\n\n    const entryStr = fhevmDBEntryToString({ clearTextHex: clearTextBigIntOrHex, metadata });\n\n    map.set(handleBytes32Hex, entryStr);\n\n    if (metadata.transactionHash !== EthersT.ZeroHash) {\n      if (__STRICT__) {\n        // Always insert forward\n        this.#counter.updateForward(metadata.blockNumber, metadata.index);\n      } else {\n        this.#counter.update(metadata.blockNumber, metadata.index);\n      }\n    }\n\n    //console.log(\"insert handleBytes32Hex=\" + handleBytes32Hex);\n  }\n\n  private async _queryHandleBytes32(handleBytes32Hex: string): Promise<FhevmDBEntry> {\n    const map: Map<string, string> = this._get();\n\n    const entryStr = map.get(handleBytes32Hex);\n    if (entryStr === undefined) {\n      throw new FhevmError(`Handle ${handleBytes32Hex} does not exist.`);\n    }\n\n    return stringToFhevmDBEntry(entryStr);\n  }\n\n  public async insertHandleBytes32(\n    handleBytes32Hex: string,\n    clearText: bigint | string,\n    metadata: FhevmDBHandleMetadata,\n    options?: { replace?: boolean },\n  ): Promise<void> {\n    checkInsertArgs(handleBytes32Hex, clearText, metadata);\n    await this._insertHandleBytes32(handleBytes32Hex, clearText, metadata, options);\n  }\n\n  async queryHandleBytes32(handleBytes32Hex: string): Promise<FhevmDBEntry> {\n    checkQueryArgs(handleBytes32Hex);\n    return await this._queryHandleBytes32(handleBytes32Hex);\n  }\n\n  public async tryInsertHandleBytes32(\n    handleBytes32Hex: string,\n    clearText: bigint | string,\n    metadata: FhevmDBHandleMetadata,\n    options?: {\n      replace?: boolean;\n    },\n  ): Promise<boolean> {\n    checkInsertArgs(handleBytes32Hex, clearText, metadata);\n    try {\n      await this._insertHandleBytes32(handleBytes32Hex, clearText, metadata, options);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  public async tryQueryHandleBytes32(handleBytes32Hex: string): Promise<FhevmDBEntry | undefined> {\n    checkQueryArgs(handleBytes32Hex);\n    try {\n      return await this._queryHandleBytes32(handleBytes32Hex);\n    } catch {\n      return undefined;\n    }\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport constants from \"../constants.js\";\nimport { FhevmError } from \"../utils/error.js\";\nimport { FheType } from \"./FheType.js\";\nimport { FhevmHandle } from \"./FhevmHandle.js\";\n\nexport enum FhevmOperator {\n  fheAdd = 0,\n  fheSub = 1,\n  fheMul = 2,\n  fheDiv = 3,\n  fheRem = 4,\n  fheBitAnd = 5,\n  fheBitOr = 6,\n  fheBitXor = 7,\n  fheShl = 8,\n  fheShr = 9,\n  fheRotl = 10,\n  fheRotr = 11,\n  fheEq = 12,\n  fheNe = 13,\n  fheGe = 14,\n  fheGt = 15,\n  fheLe = 16,\n  fheLt = 17,\n  fheMin = 18,\n  fheMax = 19,\n  fheNeg = 20,\n  fheNot = 21,\n  verifyCiphertext = 22,\n  cast = 23,\n  trivialEncrypt = 24,\n  fheIfThenElse = 25,\n  fheRand = 26,\n  fheRandBounded = 27,\n}\n\nexport class FhevmHandleCoder {\n  #aclAddress: string;\n  #chainId: number;\n\n  constructor(aclAddress: string, chainId: number) {\n    if (!EthersT.isAddress(aclAddress)) {\n      throw new FhevmError(`Invalid ACL address`);\n    }\n    if (typeof chainId !== \"number\") {\n      throw new FhevmError(`Invalid chainId`);\n    }\n    this.#aclAddress = aclAddress;\n    this.#chainId = chainId;\n  }\n  public fheAdd(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createNumericalOpHandle(\n      FhevmOperator.fheAdd,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheSub(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createNumericalOpHandle(\n      FhevmOperator.fheSub,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheMul(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createNumericalOpHandle(\n      FhevmOperator.fheMul,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheDiv(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createNumericalOpHandle(\n      FhevmOperator.fheDiv,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheRem(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createNumericalOpHandle(\n      FhevmOperator.fheRem,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheBitAnd(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createBitwiseOpHandle(\n      FhevmOperator.fheBitAnd,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheBitOr(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createBitwiseOpHandle(\n      FhevmOperator.fheBitOr,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheBitXor(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createBitwiseOpHandle(\n      FhevmOperator.fheBitXor,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheShl(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createBitwiseOpHandle(\n      FhevmOperator.fheShl,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheShr(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createBitwiseOpHandle(\n      FhevmOperator.fheShr,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheRotl(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createBitwiseOpHandle(\n      FhevmOperator.fheRotl,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheRotr(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createBitwiseOpHandle(\n      FhevmOperator.fheRotr,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheEq(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createCompareOpHandle(\n      FhevmOperator.fheEq,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheNe(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createCompareOpHandle(\n      FhevmOperator.fheNe,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheGe(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createCompareOpHandle(\n      FhevmOperator.fheGe,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheGt(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createCompareOpHandle(\n      FhevmOperator.fheGt,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheLe(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createCompareOpHandle(\n      FhevmOperator.fheLe,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n  public fheLt(lhsBytes32Hex: string, rhsBytes32Hex: string, scalar: boolean) {\n    return createCompareOpHandle(\n      FhevmOperator.fheLt,\n      lhsBytes32Hex,\n      rhsBytes32Hex,\n      scalar,\n      this.#aclAddress,\n      this.#chainId,\n    );\n  }\n}\n\n/*\n    function _appendMetadataToPrehandle(\n        bytes32 prehandle,\n        FheType handleType\n    ) internal view virtual returns (bytes32 result) {\n        /// @dev Clear bytes 21-31.\n        result = prehandle & 0xffffffffffffffffffffffffffffffffffffffffff0000000000000000000000;\n        /// @dev Set byte 21 to 0xff since the new handle comes from computation.\n        result = result | (bytes32(uint256(0xff)) << 80);\n        /// @dev chainId is cast to uint64 first to make sure it does not take more than 8 bytes before shifting.\n        /// If EIP2294 gets approved, it will force the chainID's size to be lower than MAX_UINT64.\n        result = result | (bytes32(uint256(uint64(block.chainid))) << 16);\n        /// @dev Insert handleType into byte 30.\n        result = result | (bytes32(uint256(uint8(handleType))) << 8);\n        /// @dev Insert HANDLE_VERSION into byte 31.\n        result = result | bytes32(uint256(HANDLE_VERSION));\n    }\n\n*/\n\nfunction _appendMetadataToPrehandle(prehandle: bigint, handleType: FheType, chainId: bigint): bigint {\n  let result: bigint = prehandle & 0xffffffffffffffffffffffffffffffffffffffffff0000000000000000000000n;\n  result = result | (0xffn << 80n);\n  result = result | (chainId << 16n);\n  result = result | (BigInt(handleType) << 8n);\n  result = result | BigInt(constants.FHEVM_HANDLE_VERSION);\n  return result;\n}\n\nexport function createBinaryOpHandle(\n  op: FhevmOperator,\n  lhs: string,\n  rhs: string,\n  scalar: string | boolean,\n  type: FheType,\n  aclAddress: string,\n  chainId: number,\n): string {\n  if (typeof scalar === \"boolean\") {\n    scalar = scalar ? \"0x01\" : \"0x00\";\n  }\n  const enc = EthersT.solidityPacked(\n    [\"uint8\", \"bytes32\", \"bytes32\", \"bytes1\", \"address\", \"uint256\"],\n    [op, lhs, rhs, scalar, aclAddress, chainId],\n  );\n  const prehandle = BigInt(EthersT.keccak256(enc));\n  return EthersT.toBeHex(_appendMetadataToPrehandle(prehandle, type, BigInt(chainId)));\n}\n\nexport function createNumericalOpHandle(\n  op: FhevmOperator,\n  lhs: string,\n  rhs: string,\n  scalar: string | boolean,\n  aclAddress: string,\n  chainId: number,\n): string {\n  const handleLhs = FhevmHandle.fromBytes32Hex(lhs);\n  return createBinaryOpHandle(op, lhs, rhs, scalar, handleLhs.fheType, aclAddress, chainId);\n}\n\nexport function createBitwiseOpHandle(\n  op: FhevmOperator,\n  lhs: string,\n  rhs: string,\n  scalar: string | boolean,\n  aclAddress: string,\n  chainId: number,\n): string {\n  const handleLhs = FhevmHandle.fromBytes32Hex(lhs);\n  return createBinaryOpHandle(op, lhs, rhs, scalar, handleLhs.fheType, aclAddress, chainId);\n}\n\nexport function createCompareOpHandle(\n  op: FhevmOperator,\n  lhs: string,\n  rhs: string,\n  scalar: string | boolean,\n  aclAddress: string,\n  chainId: number,\n): string {\n  return createBinaryOpHandle(op, lhs, rhs, scalar, FheType.Bool, aclAddress, chainId);\n}\n", "export type CoprocessorEventName =\n  | \"VerifyCiphertext\"\n  | \"TrivialEncrypt\"\n  | \"TrivialEncryptBytes\"\n  | \"FheAdd\"\n  | \"FheSub\"\n  | \"FheMul\"\n  | \"FheDiv\"\n  | \"FheRem\"\n  | \"FheBitAnd\"\n  | \"FheBitOr\"\n  | \"FheBitXor\"\n  | \"FheShl\"\n  | \"FheShr\"\n  | \"FheRotl\"\n  | \"FheRotr\"\n  | \"FheEq\"\n  | \"FheEqBytes\"\n  | \"FheNe\"\n  | \"FheNeBytes\"\n  | \"FheGe\"\n  | \"FheGt\"\n  | \"FheLe\"\n  | \"FheLt\"\n  | \"FheMin\"\n  | \"FheMax\"\n  | \"FheRand\"\n  | \"FheRandBounded\"\n  | \"FheNot\"\n  | \"FheNeg\"\n  | \"Cast\"\n  | \"FheIfThenElse\";\n\n/**\n * Coprocessor Solidity event emitted by a\n * [`FHEVMExecutor.sol`](https://github.com/zama-ai/fhevm-backend/blob/main/contracts/contracts/FHEVMExecutor.sol)\n * contract from `@fhevm/core-contracts`.\n */\nexport type CoprocessorEvent = {\n  eventName: CoprocessorEventName;\n  args: object;\n  index: number;\n  blockNumber: number;\n  transactionHash: string;\n  transactionIndex: number;\n};\n\nexport function isCoprocessorEventName(value: unknown): value is CoprocessorEventName {\n  return (\n    value === \"VerifyCiphertext\" ||\n    value === \"TrivialEncrypt\" ||\n    value === \"TrivialEncryptBytes\" ||\n    value === \"FheAdd\" ||\n    value === \"FheSub\" ||\n    value === \"FheMul\" ||\n    value === \"FheDiv\" ||\n    value === \"FheRem\" ||\n    value === \"FheBitAnd\" ||\n    value === \"FheBitOr\" ||\n    value === \"FheBitXor\" ||\n    value === \"FheShl\" ||\n    value === \"FheShr\" ||\n    value === \"FheRotl\" ||\n    value === \"FheRotr\" ||\n    value === \"FheEq\" ||\n    value === \"FheEqBytes\" ||\n    value === \"FheNe\" ||\n    value === \"FheNeBytes\" ||\n    value === \"FheGe\" ||\n    value === \"FheGt\" ||\n    value === \"FheLe\" ||\n    value === \"FheLt\" ||\n    value === \"FheMin\" ||\n    value === \"FheMax\" ||\n    value === \"FheRand\" ||\n    value === \"FheRandBounded\" ||\n    value === \"FheNot\" ||\n    value === \"FheNeg\" ||\n    value === \"Cast\" ||\n    value === \"FheIfThenElse\"\n  );\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { BlockLogCursor } from \"../../ethers/event.js\";\nimport { FhevmError } from \"../../utils/error.js\";\nimport { FHEVMExecutorPartialInterface } from \"../contracts/interfaces/FHEVMExecutor.itf.js\";\nimport { type CoprocessorEvent, isCoprocessorEventName } from \"./CoprocessorEvents.js\";\n\nexport async function getCoprocessorEvents(\n  coprocessorContractInterface: EthersT.Interface,\n  coprocessorContractAddress: string,\n  readonlyProvider: EthersT.Provider,\n  options: {\n    fromBlockNumber?: number;\n    fromBlockLogIndex?: number;\n    toBlockNumber?: number;\n  },\n): Promise<{ events: CoprocessorEvent[]; cursor: BlockLogCursor }> {\n  let currentBlockNumber: number = -1;\n  let toBlock: number;\n\n  if (options.toBlockNumber !== undefined) {\n    toBlock = options.toBlockNumber;\n  } else {\n    currentBlockNumber = await readonlyProvider.getBlockNumber();\n    toBlock = currentBlockNumber;\n  }\n\n  let fromBlock: number;\n  if (options.fromBlockNumber !== undefined) {\n    fromBlock = options.fromBlockNumber;\n  } else {\n    fromBlock = toBlock;\n  }\n\n  if (fromBlock > toBlock) {\n    throw new FhevmError(`Invalid block filter fromBlock=${fromBlock} toBlock=${toBlock}`);\n  }\n\n  // Fetch all events emitted by the contract\n  const filter = {\n    address: coprocessorContractAddress,\n    fromBlock,\n    toBlock,\n  };\n\n  const logs = await readonlyProvider.getLogs(filter);\n\n  const cursor = new BlockLogCursor(-1);\n  const events: CoprocessorEvent[] = logs\n    .map((log) => {\n      try {\n        cursor.updateForward(log.blockNumber, log.index);\n\n        const parsedLog = coprocessorContractInterface.parseLog(log)!;\n\n        if (log.blockNumber === fromBlock) {\n          if (options.fromBlockLogIndex !== undefined) {\n            if (log.index < options.fromBlockLogIndex) {\n              return null;\n            }\n          }\n        }\n\n        if (!isCoprocessorEventName(parsedLog.name)) {\n          return null;\n        }\n\n        const evt: CoprocessorEvent = {\n          eventName: parsedLog.name,\n          args: parsedLog.args,\n          index: log.index,\n          blockNumber: log.blockNumber,\n          transactionHash: log.transactionHash,\n          transactionIndex: log.transactionIndex,\n        };\n\n        return evt;\n      } catch {\n        // If the log cannot be parsed, skip it\n        return null;\n      }\n    })\n    .filter((event) => event !== null);\n\n  return { events, cursor };\n}\n\nexport function parseCoprocessorEventsFromLogs(\n  logs: (EthersT.EventLog | EthersT.Log)[] | null | undefined,\n): CoprocessorEvent[] {\n  // flexible\n  if (!logs) {\n    return [];\n  }\n\n  const events: CoprocessorEvent[] = [];\n  for (const log of logs) {\n    const event: EthersT.LogDescription | null = FHEVMExecutorPartialInterface.parseLog(log);\n\n    if (!event) {\n      continue;\n    }\n    if (!isCoprocessorEventName(event.name)) {\n      continue;\n    }\n\n    const ce: CoprocessorEvent = {\n      eventName: event.name,\n      args: event.args,\n      blockNumber: log.blockNumber,\n      index: log.index,\n      transactionHash: log.transactionHash,\n      transactionIndex: log.transactionIndex,\n    };\n\n    events.push(ce);\n  }\n\n  return events;\n}\n", "import { isHardhatError, isHardhatProviderError } from \"../utils/error.js\";\nimport { isNodeRuntime } from \"../utils/runtime.js\";\nimport { type MinimalProvider, minimalProviderSend } from \"./provider.js\";\n\n/**\n * Executes the `anvil_nodeInfo` RPC call on a given provider.\n * @param provider - A `MinimalProvider` that supports either `send` or `request` for RPC interaction.\n * @returns A promise that resolves to the RPC call response.\n */\nexport async function anvilNodeInfo(provider: MinimalProvider) {\n  return minimalProviderSend(provider, \"anvil_nodeInfo\", []);\n}\n\n/**\n * Determines if a given provider is an Anvil instance.\n *\n * @param provider - A `MinimalProvider` that supports either `send` or `request` for RPC interaction.\n * @returns A promise that resolves to one of the following:\n * - `{ isAnvil: true, chainId: number }` if the provider is reachable and reports an Anvil client.\n * - `{ isAnvil: false }` if the provider is reachable but does not report an Anvil client.\n * - `{ couldNotConnect: true }` if the provider is unreachable (e.g. connection refused, timeout).\n *\n * @throws If the provider fails in an unexpected way the function will propagate the error.\n */\nexport async function isAnvilProvider(\n  provider: MinimalProvider,\n): Promise<\n  | { couldNotConnect: true; isAnvil?: undefined; chainId?: undefined }\n  | { couldNotConnect: false; isAnvil: true; chainId: number }\n  | { couldNotConnect: false; isAnvil: false }\n> {\n  try {\n    const nodeInfo = await anvilNodeInfo(provider);\n    if (!(\"environment\" in nodeInfo)) {\n      return { isAnvil: false, couldNotConnect: false };\n    }\n    const env = nodeInfo.environment;\n    if (!(\"chainId\" in env)) {\n      return { isAnvil: false, couldNotConnect: false };\n    }\n    return { isAnvil: true, chainId: Number(BigInt(env.chainId)), couldNotConnect: false };\n  } catch (e) {\n    if (isHardhatProviderError(e)) {\n      // RPC method not supported / method not found\n      if (e.code === -32004 || e.code === -32601) {\n        return { isAnvil: false, couldNotConnect: false };\n      }\n    } else if (isHardhatError(e)) {\n      // HH only: cannot connect to specified network\n      if (e.number === 108) {\n        return { couldNotConnect: true };\n      }\n    } else if (isNodeRuntime()) {\n      if (e instanceof Error && \"code\" in e) {\n        // Connection refused, this error can only be catched from a node runtime\n        if (e.code === \"ECONNREFUSED\") {\n          return { couldNotConnect: true };\n        }\n      }\n    }\n\n    // Propagate the error\n    throw e;\n  }\n}\n", "import { isHardhatError, isHardhatProviderError } from \"../utils/error.js\";\nimport { isNodeRuntime } from \"../utils/runtime.js\";\nimport { type MinimalProvider, minimalProviderSend } from \"./provider.js\";\n\n/**\n * Determines if a given provider is an Hardhat instance.\n *\n * @param provider - A `MinimalProvider` that supports either `send` or `request` for RPC interaction.\n * @returns A promise that resolves to one of the following:\n * - `{ isHardhat: true, chainId: number }` if the provider is reachable and reports an Hardhat client.\n * - `{ isHardhat: false }` if the provider is reachable but does not report an Hardhat client.\n * - `{ couldNotConnect: true }` if the provider is unreachable (e.g. connection refused, timeout).\n *\n * @throws If the provider fails in an unexpected way the function will propagate the error.\n */\nexport async function isHardhatProvider(\n  provider: MinimalProvider,\n): Promise<\n  | { couldNotConnect: true; isHardhat?: undefined; chainId?: undefined }\n  | { couldNotConnect: false; isHardhat: true; chainId: number }\n  | { couldNotConnect: false; isHardhat: false }\n> {\n  try {\n    const metadata = await minimalProviderSend(provider, \"hardhat_metadata\", []);\n    if (!(\"chainId\" in metadata) || metadata.chainId !== 31337) {\n      return { couldNotConnect: false, isHardhat: false };\n    }\n    if (!(\"instanceId\" in metadata) || metadata.instanceId.length !== 66) {\n      return { couldNotConnect: false, isHardhat: false };\n    }\n    return { couldNotConnect: false, isHardhat: true, chainId: Number(BigInt(metadata.chainId)) };\n  } catch (e) {\n    if (isHardhatProviderError(e)) {\n      // RPC method not supported or not found\n      if (e.code === -32004 || e.code === -32601) {\n        return { couldNotConnect: false, isHardhat: false };\n      }\n    } else if (isHardhatError(e)) {\n      // HH only: cannot connect to specified network\n      if (e.number === 108) {\n        return { couldNotConnect: true };\n      }\n    } else if (isNodeRuntime()) {\n      if (e instanceof Error && \"code\" in e) {\n        // Connection refused, this error can only be catched from a node runtime\n        if (e.code === \"ECONNREFUSED\") {\n          return { couldNotConnect: true };\n        }\n      }\n    }\n\n    // Propagate the error\n    throw e;\n  }\n}\n", "import { ethers as EthersT, JsonRpcProvider } from \"ethers\";\n\nimport constants from \"../constants.js\";\nimport { FhevmError, assertFhevm } from \"../utils/error.js\";\nimport { assertIsString } from \"../utils/string.js\";\nimport { isAnvilProvider } from \"./anvil.js\";\nimport { isHardhatProvider } from \"./hardhat.js\";\nimport { type MinimalProvider, connectedChainId, connectedWeb3Client, minimalProviderSend } from \"./provider.js\";\n\n//const debug = setupDebug(\"@fhevm/hardhat:ethers-provider\");\n\nexport enum FhevmMockProviderType {\n  Unknown = 0,\n  Hardhat = 1,\n  HardhatNode = 2,\n  Anvil = 3,\n  SepoliaEthereum = 4,\n}\n\nfunction fhevmMockProviderTypeToString(value: FhevmMockProviderType) {\n  switch (value) {\n    case FhevmMockProviderType.Unknown:\n      return \"Unknown\";\n    case FhevmMockProviderType.Hardhat:\n      return \"Hardhat\";\n    case FhevmMockProviderType.HardhatNode:\n      return \"Hardhat Node\";\n    case FhevmMockProviderType.Anvil:\n      return \"Anvil\";\n    case FhevmMockProviderType.SepoliaEthereum:\n      return \"SepoliaEthereum\";\n  }\n}\n\nexport type FhevmMockProviderMethods = {\n  setCode?: string;\n  impersonateAccount?: string;\n  setBalance?: string;\n};\n\nexport type FhevmMockProviderInfo = {\n  web3ClientVersion: string;\n  chainId: number;\n  url: string | undefined;\n  networkName: string;\n  type: FhevmMockProviderType;\n  methods: FhevmMockProviderMethods;\n};\n\n// WRONG name!!!\nexport class FhevmMockProvider {\n  #minimalProvider: MinimalProvider | undefined;\n  #readonlyEthersProvider: EthersT.Provider | undefined;\n  #info: FhevmMockProviderInfo | undefined;\n  #savedBlockGasLimit: bigint | undefined;\n  #debugFunc: ((message: string) => void) | undefined;\n\n  public static async fromReadonlyProvider(\n    readonlyProvider: EthersT.Provider & MinimalProvider,\n    networkName: string,\n    defaultProviderType: FhevmMockProviderType | undefined,\n    defaultChainId: number | undefined,\n    url: string | undefined,\n  ) {\n    return FhevmMockProvider.create(\n      readonlyProvider,\n      readonlyProvider,\n      networkName,\n      defaultProviderType,\n      defaultChainId,\n      url,\n    );\n  }\n\n  public static async create(\n    minimalProvider: MinimalProvider,\n    readonlyEthersProvider: EthersT.Provider | undefined,\n    networkName: string,\n    defaultProviderType: FhevmMockProviderType | undefined,\n    defaultChainId: number | undefined,\n    url: string | undefined,\n  ) {\n    const info = await _resolveProviderInfo(minimalProvider, networkName, defaultProviderType, defaultChainId, url);\n    const p = new FhevmMockProvider();\n    p.#minimalProvider = minimalProvider;\n    p.#info = info;\n\n    if (readonlyEthersProvider === undefined && info.url !== undefined) {\n      // no need to change the polling interval since\n      // readonlyEthersProvider is read-only and does not listen to events\n      readonlyEthersProvider = new JsonRpcProvider(info.url);\n    }\n\n    p.#readonlyEthersProvider = readonlyEthersProvider;\n\n    return p;\n  }\n\n  public setDebugFunc(debugFunc: (message: string) => void) {\n    assertFhevm(typeof debugFunc === \"function\");\n    this.#debugFunc = debugFunc;\n  }\n\n  // public async getTransaction(txHash: string): Promise<null | EthersT.TransactionResponse> {\n  //   return await this.ethersProvider.getTransaction(txHash);\n  // }\n\n  public get readonlyEthersProvider(): EthersT.Provider {\n    // Make sure it is properly initialize. Use another property since #ethersProvider can be undefined\n    if (!this.#minimalProvider) {\n      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);\n    }\n    if (!this.#readonlyEthersProvider) {\n      throw new FhevmError(`the FhevmMockProvider instance is not able to provide a valid ethers.Provider instance.`);\n    }\n    return this.#readonlyEthersProvider;\n  }\n\n  public get minimalProvider(): MinimalProvider {\n    if (!this.#minimalProvider) {\n      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);\n    }\n    return this.#minimalProvider;\n  }\n\n  public get info(): FhevmMockProviderInfo {\n    if (!this.#info) {\n      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);\n    }\n    return this.#info;\n  }\n\n  public get isMock(): boolean {\n    if (!this.#info) {\n      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);\n    }\n    return (\n      this.#info.type === FhevmMockProviderType.Hardhat ||\n      this.#info.type === FhevmMockProviderType.HardhatNode ||\n      this.#info.type === FhevmMockProviderType.Anvil\n    );\n  }\n\n  public get isSepoliaEthereum(): boolean {\n    if (!this.#info) {\n      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);\n    }\n    return this.#info.type === FhevmMockProviderType.SepoliaEthereum;\n  }\n\n  public get isHardhatWeb3Client(): boolean {\n    if (!this.#info) {\n      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);\n    }\n    return this.#info.type === FhevmMockProviderType.Hardhat || this.#info.type === FhevmMockProviderType.HardhatNode;\n  }\n\n  public get chainId(): number {\n    return this.info.chainId;\n  }\n\n  public async impersonateAddressAndSetBalance(address: string, balance: bigint): Promise<EthersT.Signer | undefined> {\n    if (!this.info.methods.impersonateAccount) {\n      throw new FhevmError(`Network ${this.info.networkName} does not support account impersonation`);\n    }\n    if (!this.info.methods.setBalance) {\n      throw new FhevmError(`Network ${this.info.networkName} does not support account setBalance`);\n    }\n    if (this.info.type === FhevmMockProviderType.Anvil) {\n      if (!this.info.url) {\n        throw new FhevmError(`Unable to impersonate account. Missing Anvil url.`);\n      }\n    }\n\n    // for mocked mode\n    // await provider.request({\n    //   method: \"hardhat_impersonateAccount\",\n    //   params: [address],\n    // });\n    await this.send(this.info.methods.impersonateAccount, [address]);\n    await this.send(this.info.methods.setBalance, [address, EthersT.toBeHex(balance)]);\n\n    if (this.info.type === FhevmMockProviderType.Anvil) {\n      const jsonRpcProvider = new EthersT.JsonRpcProvider(this.info.url);\n      // In dev mode, speedup anvil tx processing by increasing polling frequency.\n      // There is a difference between anvil and HH node. HH node process a tx instantly and tx.wait()\n      // returns instantly. However anvil process the tx slighly later, therefore the first poll fails and\n      // we have to wait for the next poll (4s later by default) to get the tx confirmation.\n      jsonRpcProvider.pollingInterval = 100;\n      return await jsonRpcProvider.getSigner(address);\n    } else if (this.isHardhatWeb3Client) {\n      // HH runtime is in charge to call getSigner with the impersonated `address` as argument\n      // to retrieve the signer object.\n      // Example: await hre.ethers.getSigner(impersonated_address);\n      return undefined;\n    } else {\n      throw new FhevmError(`Network ${this.info.networkName} does not support account impersonation`);\n    }\n  }\n\n  public async setCodeAt(address: string, byteCode: string) {\n    const methodName = this.info.methods.setCode;\n    if (!methodName) {\n      throw new FhevmError(`Network ${this.info.networkName} does not support 'setCode' method.`);\n    }\n    if (typeof byteCode !== \"string\") {\n      throw new FhevmError(`Invalid contract bytecode.`);\n    }\n\n    await this.send(methodName, [address, byteCode]);\n  }\n\n  public send(method: string, params?: any[]): Promise<any> {\n    return minimalProviderSend(this.minimalProvider, method, params ?? []);\n  }\n\n  public async getCodeAt(address: string): Promise<string> {\n    const byteCode = await this.send(\"eth_getCode\", [address, \"latest\"]);\n\n    if (typeof byteCode !== \"string\") {\n      throw new FhevmError(`Unexpected 'eth_getCode' RPC response type.`);\n    }\n\n    return byteCode;\n  }\n\n  public async getBlockNumber(): Promise<number> {\n    const blockNumber = await this.send(\"eth_blockNumber\");\n    return Number(blockNumber);\n  }\n\n  public async unsetTemporaryMinimumBlockGasLimit() {\n    if (!this.#savedBlockGasLimit) {\n      return;\n    }\n\n    try {\n      await this.setBlockGasLimit(this.#savedBlockGasLimit);\n    } finally {\n      this.#savedBlockGasLimit = undefined;\n    }\n  }\n\n  public async setTemporaryMinimumBlockGasLimit(minBlockGasLimit: bigint) {\n    if (this.#savedBlockGasLimit) {\n      throw new FhevmError(`The minimum block gas limit has already been set.`);\n    }\n\n    const currentBlockGasLimit = await this.getBlockGasLimit();\n\n    if (!currentBlockGasLimit) {\n      this._debug(`Unable to setup minimum block gas limit.`);\n      return undefined;\n    }\n\n    if (minBlockGasLimit <= currentBlockGasLimit) {\n      return undefined;\n    }\n\n    this._debug(\n      `Adjust block gas limit to: ${minBlockGasLimit}. Current block gas limit is too low: ${currentBlockGasLimit}`,\n    );\n\n    await this.setBlockGasLimit(minBlockGasLimit);\n\n    this.#savedBlockGasLimit = currentBlockGasLimit;\n  }\n\n  public async setBlockGasLimit(blockGasLimit: bigint) {\n    const blockGasLimitHex = \"0x\" + blockGasLimit.toString(16);\n\n    await this.send(\"evm_setBlockGasLimit\", [blockGasLimitHex]);\n\n    this._debug(`Call evm_setBlockGasLimit ${blockGasLimit}`);\n  }\n\n  public async getBlockGasLimit(): Promise<bigint | undefined> {\n    const res = await this.send(\"eth_getBlockByNumber\", [\"latest\", false]);\n    if (!res) {\n      return undefined;\n    }\n    if (!(\"gasLimit\" in res)) {\n      return undefined;\n    }\n\n    try {\n      return BigInt(res.gasLimit);\n    } catch {\n      return undefined;\n    }\n  }\n\n  private _debug(message: string) {\n    if (this.#debugFunc) {\n      this.#debugFunc(message);\n    }\n  }\n}\n\nasync function _resolveProviderInfo(\n  minimalProvider: MinimalProvider,\n  networkName: string,\n  defaultProviderType: FhevmMockProviderType | undefined,\n  defaultChainId: number | undefined,\n  url?: string,\n): Promise<FhevmMockProviderInfo> {\n  assertIsString(networkName, \"networkName\");\n\n  if (\n    networkName !== \"hardhat\" &&\n    networkName !== \"localhost\" &&\n    defaultChainId === constants.SEPOLIA_ETHEREUM_TESTNET_CHAINID\n  ) {\n    assertFhevm(url !== undefined, \"Missing sepolia url\");\n    return {\n      type: FhevmMockProviderType.SepoliaEthereum,\n      chainId: constants.SEPOLIA_ETHEREUM_TESTNET_CHAINID,\n      methods: {},\n      url,\n      networkName,\n      web3ClientVersion: \"\",\n    };\n  }\n\n  const p = await _resolveProvider(minimalProvider, defaultProviderType, defaultChainId, url);\n  switch (p.type) {\n    case FhevmMockProviderType.Unknown: {\n      return {\n        type: p.type,\n        chainId: p.chainId,\n        methods: {},\n        url,\n        networkName,\n        web3ClientVersion: p.web3ClientVersion,\n      };\n    }\n    case FhevmMockProviderType.Hardhat:\n    case FhevmMockProviderType.HardhatNode: {\n      return {\n        type: p.type,\n        chainId: p.chainId,\n        methods: {\n          setBalance: \"hardhat_setBalance\",\n          setCode: \"hardhat_setCode\",\n          impersonateAccount: \"hardhat_impersonateAccount\",\n        },\n        url,\n        networkName,\n        web3ClientVersion: p.web3ClientVersion,\n      };\n    }\n    case FhevmMockProviderType.Anvil: {\n      return {\n        type: p.type,\n        chainId: p.chainId,\n        methods: {\n          setBalance: \"anvil_setBalance\",\n          setCode: \"anvil_setCode\",\n          impersonateAccount: \"anvil_impersonateAccount\",\n        },\n        url,\n        networkName,\n        web3ClientVersion: p.web3ClientVersion,\n      };\n    }\n    default: {\n      throw new FhevmError(`Unsuppored FhevmMockProviderType enum value '${p.type}'`);\n    }\n  }\n}\n\nasync function _resolveProvider(\n  minimalProvider: MinimalProvider,\n  defaultProviderType: FhevmMockProviderType | undefined,\n  defaultChainId: number | undefined,\n  url?: string,\n): Promise<{ type: FhevmMockProviderType; chainId: number; web3ClientVersion: any }> {\n  if (!url) {\n    if (defaultProviderType !== FhevmMockProviderType.Hardhat) {\n      throw new FhevmError(`Missing provider url`);\n    } else {\n      if (defaultChainId !== 31337) {\n        throw new FhevmError(`Unexpected default chainId. Expecting '31337', got '${defaultChainId}' instead.`);\n      }\n    }\n  } else {\n    if (!URL.canParse(url)) {\n      throw new FhevmError(`Invalid provider url '${url}'`);\n    }\n  }\n\n  const clientRes = await connectedWeb3Client(minimalProvider);\n\n  // Test Anvil first, because Anvil also supports hardhat RPC methods.\n  const anvilRes = await isAnvilProvider(minimalProvider);\n  if (!anvilRes.couldNotConnect) {\n    if (anvilRes.isAnvil) {\n      if (defaultProviderType !== undefined && defaultProviderType !== FhevmMockProviderType.Anvil) {\n        throw new FhevmError(\n          `Provider type mismatch. Expecting ${fhevmMockProviderTypeToString(defaultProviderType)}, got ${fhevmMockProviderTypeToString(FhevmMockProviderType.Anvil)} instead`,\n        );\n      }\n\n      if (defaultChainId !== undefined && defaultChainId !== anvilRes.chainId) {\n        throw new FhevmError(\n          `Anvil chainId mismatch. Expecting chainId=${defaultChainId}, got ${anvilRes.chainId} instead`,\n        );\n      }\n\n      if (!clientRes.client) {\n        throw new FhevmError(`Unable to retrieve Anvil web3 client version.`);\n      }\n\n      return {\n        type: FhevmMockProviderType.Anvil,\n        chainId: anvilRes.chainId,\n        web3ClientVersion: clientRes.client,\n      };\n    }\n    // could connect, but was not identified as an Anvil provider\n  }\n\n  // Test Hardhat last, to avoid misdetecting the client.\n  const hhRes = await isHardhatProvider(minimalProvider);\n  if (!hhRes.couldNotConnect) {\n    if (hhRes.isHardhat) {\n      const providerType = url !== undefined ? FhevmMockProviderType.HardhatNode : FhevmMockProviderType.Hardhat;\n\n      if (defaultProviderType !== undefined && defaultProviderType !== providerType) {\n        throw new FhevmError(\n          `Provider type mismatch. Expecting ${fhevmMockProviderTypeToString(defaultProviderType)}, got ${fhevmMockProviderTypeToString(providerType)} instead`,\n        );\n      }\n\n      if (defaultChainId !== undefined && defaultChainId !== hhRes.chainId) {\n        throw new FhevmError(\n          `Hardhat chainId mismatch. Expecting chainId=${defaultChainId}, got ${hhRes.chainId} instead`,\n        );\n      }\n\n      if (!clientRes.client) {\n        throw new FhevmError(`Unable to retrieve Hardhat web3 client version.`);\n      }\n\n      return {\n        type: providerType,\n        chainId: hhRes.chainId,\n        web3ClientVersion: clientRes.client,\n      };\n    }\n    // could connect, but was not identified as an Hardhat provider\n  }\n\n  // 3 possibilities:\n  // 1- could not connect\n  // 2- could connect, but was not identified as an Anvil provider\n  // 3- could connect, but was not identified as an Hardhat provider\n\n  if (!clientRes.couldNotConnect) {\n    const chainId = await connectedChainId(minimalProvider);\n    if (chainId === undefined) {\n      throw new FhevmError(`Unable to query provider chaindId`);\n    }\n\n    if (defaultProviderType !== undefined && defaultProviderType !== FhevmMockProviderType.Unknown) {\n      throw new FhevmError(\n        `Provider type mismatch. Expecting ${fhevmMockProviderTypeToString(defaultProviderType)}, got ${fhevmMockProviderTypeToString(FhevmMockProviderType.Unknown)} instead`,\n      );\n    }\n\n    if (defaultChainId !== undefined && defaultChainId !== chainId) {\n      throw new FhevmError(`Provider chainId mismatch. Expecting chainId=${defaultChainId}, got ${chainId} instead`);\n    }\n\n    if (!clientRes.client) {\n      throw new FhevmError(`Unable to retrieve provider web3 client version.`);\n    }\n\n    return { type: FhevmMockProviderType.Unknown, chainId, web3ClientVersion: clientRes.client };\n  }\n\n  if (defaultProviderType === undefined) {\n    throw new FhevmError(`Resolve provider failed. Missing default provider type.`);\n  }\n\n  if (defaultChainId === undefined) {\n    throw new FhevmError(`Resolve provider failed. Missing default provider chainId.`);\n  }\n\n  return { type: defaultProviderType, chainId: defaultChainId, web3ClientVersion: undefined };\n}\n", "import {\n  assertEventArgIsAddress,\n  assertEventArgIsBigUint8,\n  assertEventArgIsBigUint256,\n  assertEventArgIsBytes1String,\n  assertEventArgIsBytes16String,\n  assertEventArgIsBytes32String,\n  assertEventArgIsBytesString,\n} from \"../../ethers/event.js\";\nimport { FhevmError, assertFhevm } from \"../../utils/error.js\";\nimport { bitwiseNotUIntBits, getRandomBigInt, log2BigInt } from \"../../utils/math.js\";\nimport { FheType } from \"../FheType.js\";\nimport { FhevmHandle } from \"../FhevmHandle.js\";\nimport type { FhevmDB } from \"../db/FhevmDB.js\";\nimport type { CoprocessorEvent } from \"./CoprocessorEvents.js\";\n\nexport class CoprocessorEventsHandler {\n  #db: FhevmDB;\n  #counterRand: number;\n\n  constructor(db: FhevmDB) {\n    this.#db = db;\n    this.#counterRand = 0;\n  }\n\n  public get counterRand(): number {\n    return this.#counterRand;\n  }\n\n  public async handleEvent(coprocessorEvent: CoprocessorEvent) {\n    // Should be properly handled by the event iterator\n    assertFhevm(\n      coprocessorEvent.blockNumber >= this.#db.fromBlockNumber,\n      \"coprocessorEvent.blockNumber < this.#db.fromBlockNumber\",\n    );\n    // if (coprocessorEvent.blockNumber < this.#db.fromBlockNumber) {\n    //   // ignore, the db exclusively contains handles generated from `firstBlockNumber` and above.\n    //   console.log(\n    //     `coprocessorEvent.blockNumber=${coprocessorEvent.blockNumber} < db.firstBlockNumber=${this.#db.fromBlockNumber}`,\n    //   );\n    //   return;\n    // }\n    if (coprocessorEvent.eventName === \"VerifyCiphertext\") {\n      await this.verifyCipherText(coprocessorEvent.args);\n    } else {\n      const res = await this.executeCoprocessorEvent(coprocessorEvent);\n      if (res) {\n        await this.#db.insertHandleBytes32(\n          res.resultBytes32,\n          res.clearText,\n          {\n            index: coprocessorEvent.index,\n            blockNumber: coprocessorEvent.blockNumber,\n            transactionHash: coprocessorEvent.transactionHash,\n          },\n          res.replace !== undefined ? { replace: res.replace } : undefined,\n        );\n\n        if (coprocessorEvent.eventName === \"FheRandBounded\" || coprocessorEvent.eventName === \"FheRand\") {\n          this.#counterRand++;\n        }\n      }\n    }\n  }\n\n  private async executeCoprocessorEvent(event: CoprocessorEvent): Promise<\n    | {\n        resultBytes32: string;\n        clearText: bigint | string;\n        replace?: boolean;\n      }\n    | undefined\n  > {\n    switch (event.eventName) {\n      case \"TrivialEncrypt\": {\n        // event TrivialEncrypt(address indexed caller, uint256 pt, FheType toType, bytes32 result);\n        const ptUint256: bigint = event.args[1 as keyof typeof event.args];\n        const fheType: bigint = event.args[2 as keyof typeof event.args];\n        const resultBytes32: string = event.args[3 as keyof typeof event.args];\n\n        assertEventArgIsBigUint256(ptUint256, \"TrivialEncrypt\", 1);\n        assertEventArgIsBigUint256(fheType, \"TrivialEncrypt\", 2);\n        assertEventArgIsBytes32String(resultBytes32, \"TrivialEncrypt\", 3);\n\n        return {\n          resultBytes32,\n          clearText: ptUint256,\n        };\n      }\n\n      case \"TrivialEncryptBytes\": {\n        // event TrivialEncryptBytes(address indexed caller, bytes pt, FheType toType, bytes32 result);\n        const ptBytes: string = event.args[1 as keyof typeof event.args];\n        const resultBytes32: string = event.args[3 as keyof typeof event.args];\n\n        assertEventArgIsBytesString(ptBytes, \"TrivialEncryptBytes\", 1);\n        assertEventArgIsBytes32String(resultBytes32, \"TrivialEncrypt\", 3);\n\n        return {\n          resultBytes32,\n          clearText: ptBytes,\n        };\n      }\n\n      case \"FheAdd\": {\n        // event FheAdd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        let clearText: bigint = binaryOp.clearTextLhsBigInt + binaryOp.clearTextRhsBigInt;\n\n        // Clamp\n        clearText = clearText % 2n ** binaryOp.clearTextBitLength;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheSub\": {\n        // event FheSub(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        let clearText: bigint = binaryOp.clearTextLhsBigInt - binaryOp.clearTextRhsBigInt;\n\n        // Clamp\n        if (clearText < 0n) clearText = clearText + 2n ** binaryOp.clearTextBitLength;\n        clearText = clearText % 2n ** binaryOp.clearTextBitLength;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheMul\": {\n        // event FheMul(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        let clearText: bigint = binaryOp.clearTextLhsBigInt * binaryOp.clearTextRhsBigInt;\n\n        // Clamp\n        clearText = clearText % 2n ** binaryOp.clearTextBitLength;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheDiv\": {\n        // event FheDiv(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);\n\n        const binaryOp = await this.parseBinaryOpEvent(event);\n        if (!binaryOp.scalar) {\n          throw new Error(\"Non-scalar div not implemented yet\");\n        }\n\n        // Check division by zero ?\n        const clearText: bigint = binaryOp.clearTextLhsBigInt / binaryOp.clearTextRhsBigInt;\n\n        // No Clamp needed\n        // clearText = clearText % 2n ** binaryOp.numBits;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheRem\": {\n        //event FheRem(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);\n\n        const binaryOp = await this.parseBinaryOpEvent(event);\n        if (!binaryOp.scalar) {\n          throw new Error(\"Non-scalar rem not implemented yet\");\n        }\n\n        // Check division by zero ?\n        const clearText: bigint = binaryOp.clearTextLhsBigInt % binaryOp.clearTextRhsBigInt;\n\n        // No Clamp needed\n        // clearText = clearText % 2n ** binaryOp.numBits;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheBitAnd\": {\n        // event FheBitAnd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        let clearText: bigint = binaryOp.clearTextLhsBigInt & binaryOp.clearTextRhsBigInt;\n\n        // Clamp\n        clearText = clearText % 2n ** binaryOp.clearTextBitLength;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheBitOr\": {\n        // event FheBitOr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        let clearText: bigint = binaryOp.clearTextLhsBigInt | binaryOp.clearTextRhsBigInt;\n\n        // Clamp\n        clearText = clearText % 2n ** binaryOp.clearTextBitLength;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheBitXor\": {\n        // event FheBitXor(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        let clearText: bigint = binaryOp.clearTextLhsBigInt ^ binaryOp.clearTextRhsBigInt;\n\n        // Clamp\n        clearText = clearText % 2n ** binaryOp.clearTextBitLength;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheShl\": {\n        // event FheShl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        let clearText: bigint =\n          binaryOp.clearTextLhsBigInt << binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;\n\n        // Clamp\n        clearText = clearText % 2n ** binaryOp.clearTextBitLength;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheShr\": {\n        // event FheShr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        let clearText: bigint =\n          binaryOp.clearTextLhsBigInt >> binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;\n\n        // Clamp\n        clearText = clearText % 2n ** binaryOp.clearTextBitLength;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheRotl\": {\n        // \"event FheRotl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        const shift = binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;\n\n        let clearText =\n          (binaryOp.clearTextLhsBigInt << shift) |\n          (binaryOp.clearTextLhsBigInt >> (binaryOp.clearTextBitLength - shift));\n\n        // Clamp\n        clearText = clearText % 2n ** binaryOp.clearTextBitLength;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheRotr\": {\n        // \"event FheRotr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        const shift = binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;\n\n        let clearText =\n          (binaryOp.clearTextLhsBigInt >> shift) |\n          (binaryOp.clearTextLhsBigInt << (binaryOp.clearTextBitLength - shift));\n\n        // Clamp\n        clearText = clearText % 2n ** binaryOp.clearTextBitLength;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheEq\": {\n        // \"event FheEq(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 1n : 0n;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheEqBytes\": {\n        // \"event FheEqBytes(address indexed caller, bytes32 lhs, bytes rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryBytesOpEvent(event);\n\n        const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 1n : 0n;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheNe\": {\n        // \"event FheNe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 0n : 1n;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheNeBytes\": {\n        // \"event FheNeBytes(address indexed caller, bytes32 lhs, bytes rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryBytesOpEvent(event);\n\n        const clearText = binaryOp.clearTextLhsBigInt !== binaryOp.clearTextRhsBigInt ? 1n : 0n;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheGe\": {\n        // \"event FheGe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        const clearText = binaryOp.clearTextLhsBigInt >= binaryOp.clearTextRhsBigInt ? 1n : 0n;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheGt\": {\n        // \"event FheGt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        const clearText = binaryOp.clearTextLhsBigInt > binaryOp.clearTextRhsBigInt ? 1n : 0n;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheLe\": {\n        // \"event FheLe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        const clearText = binaryOp.clearTextLhsBigInt <= binaryOp.clearTextRhsBigInt ? 1n : 0n;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheLt\": {\n        // \"event FheLt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        const clearText = binaryOp.clearTextLhsBigInt < binaryOp.clearTextRhsBigInt ? 1n : 0n;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheMin\": {\n        // \"event FheMin(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        const clearText =\n          binaryOp.clearTextLhsBigInt < binaryOp.clearTextRhsBigInt\n            ? binaryOp.clearTextLhsBigInt\n            : binaryOp.clearTextRhsBigInt;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheMax\": {\n        // \"event FheMax(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)\",\n        const binaryOp = await this.parseBinaryOpEvent(event);\n\n        const clearText =\n          binaryOp.clearTextLhsBigInt > binaryOp.clearTextRhsBigInt\n            ? binaryOp.clearTextLhsBigInt\n            : binaryOp.clearTextRhsBigInt;\n\n        return {\n          resultBytes32: binaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheNot\": {\n        // \"event FheNot(address indexed caller, bytes32 ct, bytes32 result)\",\n        const unaryOp = await this.parseUnaryOpEvent(event);\n\n        const clearText: bigint = bitwiseNotUIntBits(unaryOp.clearTextBigInt, unaryOp.clearTextBitLength);\n\n        return {\n          resultBytes32: unaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheNeg\": {\n        // \"event FheNeg(address indexed caller, bytes32 ct, bytes32 result)\",\n        const unaryOp = await this.parseUnaryOpEvent(event);\n\n        let clearText: bigint = bitwiseNotUIntBits(unaryOp.clearTextBigInt, unaryOp.clearTextBitLength);\n\n        // Clamp\n        clearText = (clearText + 1n) % 2n ** unaryOp.clearTextBitLength;\n\n        return {\n          resultBytes32: unaryOp.resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"Cast\": {\n        // \"event Cast(address indexed caller, bytes32 ct, uint8 toType, bytes32 result)\",\n        const ctBytes32: string = event.args[1 as keyof typeof event.args];\n        const toTypeUint8: bigint = event.args[2 as keyof typeof event.args];\n        const resultBytes32: string = event.args[3 as keyof typeof event.args];\n\n        assertEventArgIsBytes32String(ctBytes32, event.eventName, 1);\n        assertEventArgIsBigUint8(toTypeUint8, event.eventName, 2);\n        assertEventArgIsBytes32String(resultBytes32, event.eventName, 3);\n\n        const resultFhevmHandle: FhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);\n        const resultType: FheType = resultFhevmHandle.fheType;\n        const clearTextBitLength = BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength);\n\n        assertFhevm(\n          BigInt(resultType) === toTypeUint8,\n          `Cast type mismatch, (resultType:${resultType}) !== (toTypeUint8:${toTypeUint8})`,\n        );\n\n        const ct: bigint = BigInt((await this.#db.queryHandleBytes32(ctBytes32)).clearTextHex);\n\n        const clearText: bigint = ct % 2n ** clearTextBitLength;\n\n        return {\n          resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheIfThenElse\": {\n        // \"event FheIfThenElse(address indexed caller, bytes32 control, bytes32 ifTrue, bytes32 ifFalse, bytes32 result)\",\n        const controlBytes32: string = event.args[1 as keyof typeof event.args];\n        const ifTrueBytes32: string = event.args[2 as keyof typeof event.args];\n        const ifFalseBytes32: string = event.args[3 as keyof typeof event.args];\n        const resultBytes32: string = event.args[4 as keyof typeof event.args];\n\n        assertEventArgIsBytes32String(controlBytes32, event.eventName, 1);\n        assertEventArgIsBytes32String(ifTrueBytes32, event.eventName, 2);\n        assertEventArgIsBytes32String(ifFalseBytes32, event.eventName, 3);\n        assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);\n\n        const control: bigint = BigInt((await this.#db.queryHandleBytes32(controlBytes32)).clearTextHex);\n        const ifTrue: bigint = BigInt((await this.#db.queryHandleBytes32(ifTrueBytes32)).clearTextHex);\n        const ifFalse: bigint = BigInt((await this.#db.queryHandleBytes32(ifFalseBytes32)).clearTextHex);\n\n        assertFhevm(\n          control === 0n || control === 1n,\n          `Unexpected FheIfThenElse control value. Got ${control}, expecting 0 or 1`,\n        );\n\n        const clearText: bigint = control === 1n ? ifTrue : ifFalse;\n\n        return {\n          resultBytes32,\n          clearText,\n        };\n      }\n\n      case \"FheRand\": {\n        // \"event FheRand(address indexed caller, uint8 randType, bytes16 seed, bytes32 result)\",\n        const randTypeUint8: bigint = event.args[1 as keyof typeof event.args];\n        const seedBytes16: string = event.args[2 as keyof typeof event.args];\n        const resultBytes32: string = event.args[3 as keyof typeof event.args];\n\n        assertEventArgIsBigUint8(randTypeUint8, event.eventName, 1);\n        assertEventArgIsBytes16String(seedBytes16, event.eventName, 2);\n        assertEventArgIsBytes32String(resultBytes32, event.eventName, 3);\n\n        const resultFhevmHandle: FhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);\n        const resultType: FheType = resultFhevmHandle.fheType;\n        const clearTextBitLength = resultFhevmHandle.fhevmTypeInfo.clearTextBitLength;\n\n        assertFhevm(\n          BigInt(resultType) === randTypeUint8,\n          `Rand type mismatch, (resultType:${resultType}) !== (randTypeUint8:${randTypeUint8})`,\n        );\n\n        //EthersT.randomBytes\n        const clearText: bigint = getRandomBigInt(clearTextBitLength);\n\n        return {\n          resultBytes32,\n          clearText,\n          replace: true,\n        };\n      }\n\n      case \"FheRandBounded\": {\n        // \"event FheRandBounded(address indexed caller, uint256 upperBound, uint8 randType, bytes16 seed, bytes32 result)\",\n        const upperBoundUint256: bigint = event.args[1 as keyof typeof event.args];\n        const randTypeUint8: bigint = event.args[2 as keyof typeof event.args];\n        const seedBytes16: string = event.args[3 as keyof typeof event.args];\n        const resultBytes32: string = event.args[4 as keyof typeof event.args];\n\n        assertEventArgIsBigUint256(upperBoundUint256, event.eventName, 1);\n        assertEventArgIsBigUint8(randTypeUint8, event.eventName, 2);\n        assertEventArgIsBytes16String(seedBytes16, event.eventName, 3);\n        assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);\n\n        const resultFhevmHandle: FhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);\n        const resultType: FheType = resultFhevmHandle.fheType;\n\n        assertFhevm(\n          BigInt(resultType) === randTypeUint8,\n          `Rand type mismatch, (resultType:${resultType}) !== (randTypeUint8:${randTypeUint8})`,\n        );\n\n        const clearText: bigint = getRandomBigInt(Number(log2BigInt(upperBoundUint256)));\n\n        return {\n          resultBytes32,\n          clearText,\n          replace: true,\n        };\n      }\n    }\n\n    throw new FhevmError(`Unknown fhevm coprocessor event: ${event.eventName}`);\n  }\n\n  private async verifyCipherText(eventArgs: object) {\n    /*\n      event VerifyCiphertext(\n          address indexed caller,\n          bytes32 inputHandle,\n          address userAddress,\n          bytes inputProof,\n          FheType inputType,\n          bytes32 result\n      );\n    */\n\n    const inputHandleBytes32: string = eventArgs[1 as keyof typeof eventArgs];\n    const userAddress: string = eventArgs[2 as keyof typeof eventArgs];\n    const inputProofBytes: string = eventArgs[3 as keyof typeof eventArgs];\n    const fheType: bigint = eventArgs[4 as keyof typeof eventArgs];\n    const resultBytes32: string = eventArgs[5 as keyof typeof eventArgs];\n\n    assertEventArgIsBytes32String(inputHandleBytes32, \"VerifyCipherText\", 1);\n    assertEventArgIsAddress(userAddress, \"VerifyCipherText\", 2);\n    assertEventArgIsBytesString(inputProofBytes, \"VerifyCipherText\", 3);\n    assertEventArgIsBigUint256(fheType, \"VerifyCipherText\", 4);\n    assertEventArgIsBytes32String(resultBytes32, \"VerifyCipherText\", 5);\n\n    // At this point 'inputHandle' equals 'result'\n    // See FHEVMExectuorNoEvents.sol + InputVerifier.sol\n    assertFhevm(\n      inputHandleBytes32 === resultBytes32,\n      `VerifyCipherText: inputHandleBytes32=${inputHandleBytes32} differs from resultBytes32=${resultBytes32}`,\n    );\n\n    try {\n      await this.#db.queryHandleBytes32(inputHandleBytes32);\n    } catch {\n      throw new FhevmError(`User input was not found in DB inputHandle=${inputHandleBytes32}`);\n    }\n  }\n\n  private async parseUnaryOpEvent(event: CoprocessorEvent) {\n    const ctBytes32: string = event.args[1 as keyof typeof event.args];\n    const resultBytes32: string = event.args[2 as keyof typeof event.args];\n\n    assertEventArgIsBytes32String(ctBytes32, event.eventName, 1);\n    assertEventArgIsBytes32String(resultBytes32, event.eventName, 2);\n\n    const resultFhevmHandle: FhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);\n\n    const clearTextBigInt: bigint = BigInt((await this.#db.queryHandleBytes32(ctBytes32)).clearTextHex);\n\n    return {\n      resultBytes32,\n      clearTextBigInt,\n      clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength),\n    };\n  }\n\n  private async parseBinaryOpEvent(event: CoprocessorEvent) {\n    const lhsBytes32: string = event.args[1 as keyof typeof event.args];\n    const rhsBytes32: string = event.args[2 as keyof typeof event.args];\n    const scalarBytes1: string = event.args[3 as keyof typeof event.args];\n    const resultBytes32: string = event.args[4 as keyof typeof event.args];\n\n    assertEventArgIsBytes32String(lhsBytes32, event.eventName, 1);\n    assertEventArgIsBytes32String(rhsBytes32, event.eventName, 2);\n    assertEventArgIsBytes1String(scalarBytes1, event.eventName, 3);\n    assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);\n\n    const resultFhevmHandle: FhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);\n\n    const scalar: boolean = scalarBytes1 === \"0x01\";\n    const clearTextLhsBigInt: bigint = BigInt((await this.#db.queryHandleBytes32(lhsBytes32)).clearTextHex);\n    const clearTextRhsBigInt: bigint = scalar\n      ? BigInt(rhsBytes32)\n      : BigInt((await this.#db.queryHandleBytes32(rhsBytes32)).clearTextHex);\n\n    return {\n      resultBytes32,\n      clearTextLhsBigInt,\n      clearTextRhsBigInt,\n      scalar,\n      clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength),\n    };\n  }\n\n  private async parseBinaryBytesOpEvent(event: CoprocessorEvent) {\n    const lhsBytes32: string = event.args[1 as keyof typeof event.args];\n    const rhsBytes: string = event.args[2 as keyof typeof event.args];\n    const scalarBytes1: string = event.args[3 as keyof typeof event.args];\n    const resultBytes32: string = event.args[4 as keyof typeof event.args];\n\n    assertEventArgIsBytes32String(lhsBytes32, event.eventName, 1);\n    assertEventArgIsBytesString(rhsBytes, event.eventName, 2);\n    assertEventArgIsBytes1String(scalarBytes1, event.eventName, 3);\n    assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);\n\n    const resultFhevmHandle: FhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);\n\n    const scalar: boolean = scalarBytes1 === \"0x01\";\n    const clearTextLhsBigInt: bigint = BigInt((await this.#db.queryHandleBytes32(lhsBytes32)).clearTextHex);\n    const clearTextRhsBigInt: bigint = scalar\n      ? BigInt(rhsBytes)\n      : BigInt((await this.#db.queryHandleBytes32(rhsBytes)).clearTextHex);\n\n    return {\n      resultBytes32,\n      clearTextLhsBigInt,\n      clearTextRhsBigInt,\n      scalar,\n      clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength),\n    };\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { BlockLogCursor } from \"../../ethers/event.js\";\nimport { assertFhevm } from \"../../utils/error.js\";\nimport type { CoprocessorEvent } from \"./CoprocessorEvents.js\";\nimport { getCoprocessorEvents } from \"./utils.js\";\n\nexport class CoprocessorEventsIterator {\n  #cursor: BlockLogCursor;\n  #coprocessorContractInterface: EthersT.Interface;\n  #coprocessorContractAddress: string;\n  #readonlyProvider: EthersT.Provider;\n\n  constructor(\n    coprocessorContractInterface: EthersT.Interface,\n    coprocessorContractAddress: string,\n    readonlyProvider: EthersT.Provider,\n    fromBlockNumber: number,\n  ) {\n    this.#coprocessorContractInterface = coprocessorContractInterface;\n    this.#coprocessorContractAddress = coprocessorContractAddress;\n    this.#readonlyProvider = readonlyProvider;\n    this.#cursor = new BlockLogCursor(fromBlockNumber);\n  }\n\n  public async next(): Promise<CoprocessorEvent[]> {\n    const currentBlockNumber = await this.#readonlyProvider.getBlockNumber();\n    if (currentBlockNumber === this.#cursor.blockNumber) {\n      return [];\n    }\n\n    const { events, cursor } = await getCoprocessorEvents(\n      this.#coprocessorContractInterface,\n      this.#coprocessorContractAddress,\n      this.#readonlyProvider,\n      {\n        fromBlockNumber: this.#cursor.nextBlockNumber,\n        toBlockNumber: currentBlockNumber,\n      },\n    );\n\n    if (!cursor.isEmpty) {\n      // events can be empty here!\n      this.#cursor.updateForward(cursor.blockNumber, cursor.blockLogIndex);\n    } else {\n      // if the cursor has not progressed, then necessarily the events array\n      // must empty.\n      assertFhevm(events.length === 0);\n    }\n\n    return events;\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { multiSignEIP712 } from \"../../ethers/eip712.js\";\nimport { assertIsBytes32String } from \"../../utils/bytes.js\";\nimport { assertFhevm } from \"../../utils/error.js\";\nimport { removePrefix } from \"../../utils/string.js\";\nimport { InputVerifier } from \"../contracts/InputVerifier.js\";\nimport { FHEVMExecutorPartialInterface } from \"../contracts/interfaces/FHEVMExecutor.itf.js\";\nimport type { FhevmDB, FhevmDBHandleMetadata } from \"../db/FhevmDB.js\";\nimport type { RelayerV1InputProofResponse } from \"../relayer/payloads.js\";\nimport type { Coprocessor } from \"./Coprocessor.js\";\nimport type { CoprocessorEvent } from \"./CoprocessorEvents.js\";\nimport { CoprocessorEventsHandler } from \"./CoprocessorEventsHandler.js\";\nimport { CoprocessorEventsIterator } from \"./CoprocessorEventsIterator.js\";\n\nexport class MockCoprocessor implements Coprocessor {\n  #iterator: CoprocessorEventsIterator | undefined;\n  #handler: CoprocessorEventsHandler | undefined;\n  #db: FhevmDB | undefined;\n  #coprocessorSigners: EthersT.Signer[] | undefined;\n  #inputVerifier: InputVerifier | undefined;\n\n  constructor() {}\n\n  public static async create(\n    readonlyProvider: EthersT.Provider,\n    params: {\n      coprocessorContractAddress: string;\n      coprocessorContractInterface?: EthersT.Interface;\n      coprocessorSigners: EthersT.Signer[];\n      inputVerifierContractAddress: string;\n      db: FhevmDB;\n    },\n  ): Promise<MockCoprocessor> {\n    const mc = new MockCoprocessor();\n    const coprocessorItf = params.coprocessorContractInterface ?? FHEVMExecutorPartialInterface;\n    mc.#iterator = new CoprocessorEventsIterator(\n      coprocessorItf,\n      params.coprocessorContractAddress,\n      readonlyProvider,\n      params.db.fromBlockNumber,\n    );\n    mc.#handler = new CoprocessorEventsHandler(params.db);\n    mc.#db = params.db;\n    mc.#inputVerifier = await InputVerifier.create(readonlyProvider, params.inputVerifierContractAddress);\n    mc.#coprocessorSigners = params.coprocessorSigners;\n    return mc;\n  }\n\n  public getDB(): FhevmDB {\n    assertFhevm(this.#db !== undefined, `MockCoprocessor not initialized`);\n    return this.#db;\n  }\n\n  public async awaitCoprocessor() {\n    assertFhevm(this.#iterator !== undefined, `MockCoprocessor not initialized`);\n    assertFhevm(this.#handler !== undefined, `MockCoprocessor not initialized`);\n\n    // Warning test: solidityCoverageRunning\n    const events: CoprocessorEvent[] = await this.#iterator.next();\n    for (let i = 0; i < events.length; ++i) {\n      await this.#handler.handleEvent(events[i]);\n    }\n  }\n\n  public async clearHandleDB() {\n    assertFhevm(this.#db !== undefined, `MockCoprocessor not initialized`);\n\n    // Call awaitCoprocessor() to flush yet unprocessed events\n    // This is critical otherwise we might have to process input handles that are\n    // no more in the db. This is a scenario that randomly occurs between 2 reset\n    // usually when running tests.\n    await this.awaitCoprocessor();\n    await this.#db.reset();\n  }\n\n  public async handleEvmRevert(newBlockNumber: number) {\n    console.log(\"HANDLE REVERT HERE!! \" + newBlockNumber);\n  }\n\n  public async insertHandleBytes32(handleBytes32Hex: string, clearTextHex: string, metadata: FhevmDBHandleMetadata) {\n    assertFhevm(this.#db !== undefined, `MockCoprocessor not initialized`);\n\n    await this.#db.insertHandleBytes32(handleBytes32Hex, clearTextHex, metadata);\n  }\n\n  public async queryHandlesBytes32AsHex(handlesBytes32: string[]): Promise<string[]> {\n    assertFhevm(this.#db !== undefined, `MockCoprocessor not initialized`);\n\n    await this.awaitCoprocessor();\n\n    const clearTextHexList: string[] = [];\n\n    for (let i = 0; i < handlesBytes32.length; ++i) {\n      assertIsBytes32String(handlesBytes32[i]);\n\n      let clearTextHex: string;\n      try {\n        clearTextHex = (await this.#db.queryHandleBytes32(handlesBytes32[i])).clearTextHex;\n      } catch {\n        clearTextHex = \"0x\";\n      }\n      clearTextHexList.push(clearTextHex);\n    }\n\n    return clearTextHexList;\n  }\n\n  public async computeCoprocessorSignatures(\n    handlesBytes32List: Uint8Array[],\n    contractChainId: number,\n    contractAddress: string,\n    userAddress: string,\n    extraData: string,\n  ): Promise<RelayerV1InputProofResponse> {\n    assertFhevm(this.#inputVerifier !== undefined, `MockCoprocessor not initialized`);\n    assertFhevm(this.#coprocessorSigners !== undefined, `MockCoprocessor not initialized`);\n\n    const numHandles = handlesBytes32List.length;\n\n    const handlesBytes32HexNoPrefixList: string[] = [];\n    const handlesBytes32HexList: string[] = [];\n\n    for (let index = 0; index < numHandles; ++index) {\n      const handleBytes32Hex = EthersT.hexlify(handlesBytes32List[index]);\n      handlesBytes32HexList.push(handleBytes32Hex);\n      handlesBytes32HexNoPrefixList.push(removePrefix(handleBytes32Hex, \"0x\"));\n    }\n\n    const eip712 = this.#inputVerifier.createCiphertextVerificationEIP712(\n      handlesBytes32HexList,\n      contractChainId,\n      contractAddress,\n      userAddress,\n      extraData,\n    );\n\n    const signaturesHex: string[] = await multiSignEIP712(\n      this.#coprocessorSigners,\n      eip712.domain,\n      eip712.types,\n      eip712.message,\n    );\n\n    // Remove 0x prefix\n    const signatureHexNoPrefixList: string[] = signaturesHex.map((sigHex) => removePrefix(sigHex, \"0x\"));\n\n    return {\n      handles: handlesBytes32HexNoPrefixList,\n      signatures: signatureHexNoPrefixList,\n    };\n  }\n}\n", "import type { ethers as EthersT } from \"ethers\";\n\nexport type DecryptionOracleEventName = \"DecryptionRequest\";\n\nexport function isDecryptionOracleEventName(value: unknown): value is DecryptionOracleEventName {\n  return value === \"DecryptionRequest\";\n}\n\nexport type DecryptionOracleEvent = {\n  eventName: DecryptionOracleEventName;\n  args: EthersT.Result;\n  index: number;\n  blockNumber: number;\n  transactionHash: string;\n  transactionIndex: number;\n};\n\nexport type DecryptionRequestEvent = {\n  counter: bigint;\n  requestID: bigint;\n  handlesBytes32Hex: string[];\n  contractCallerAddress: string;\n  callbackSelectorBytes4Hex: string;\n  index: number;\n  blockNumber: number;\n  transactionHash: string;\n  transactionIndex: number;\n};\n", "import { ethers as EthersT } from \"ethers\";\n\nexport const DecryptionOraclePartialInterface: EthersT.Interface = new EthersT.Interface([\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"counter\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"requestID\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32[]\",\n        name: \"cts\",\n        type: \"bytes32[]\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"contractCaller\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes4\",\n        name: \"callbackSelector\",\n        type: \"bytes4\",\n      },\n    ],\n    name: \"DecryptionRequest\",\n    type: \"event\",\n  },\n]);\n", "import { ethers as EthersT } from \"ethers\";\n\nimport {\n  BlockLogCursor,\n  assertEventArgIsAddress,\n  assertEventArgIsBigUint256,\n  assertEventArgIsBytes4String,\n  assertEventArgIsBytes32String,\n} from \"../../ethers/event.js\";\nimport { FhevmError, assertFhevm } from \"../../utils/error.js\";\nimport type { DecryptionOracleEvent, DecryptionRequestEvent } from \"./DecryptionOracleEvents.js\";\nimport { isDecryptionOracleEventName } from \"./DecryptionOracleEvents.js\";\nimport { DecryptionOraclePartialInterface } from \"./abi.js\";\n\nexport async function getDecryptionOracleEvents(\n  decryptionOracleContractInterface: EthersT.Interface,\n  decryptionOracleContractAddress: string,\n  readonlyProvider: EthersT.Provider,\n  options: {\n    fromBlockNumber?: number;\n    fromBlockLogIndex?: number;\n    toBlockNumber?: number;\n  },\n): Promise<{ events: DecryptionOracleEvent[]; cursor: BlockLogCursor }> {\n  let currentBlockNumber: number = -1;\n  let toBlock: number;\n\n  if (options.toBlockNumber !== undefined) {\n    toBlock = options.toBlockNumber;\n  } else {\n    currentBlockNumber = await readonlyProvider.getBlockNumber();\n    toBlock = currentBlockNumber;\n  }\n\n  let fromBlock: number;\n  if (options.fromBlockNumber !== undefined) {\n    fromBlock = options.fromBlockNumber;\n  } else {\n    fromBlock = toBlock;\n  }\n\n  if (fromBlock > toBlock) {\n    throw new FhevmError(`Invalid block filter fromBlock=${fromBlock} toBlock=${toBlock}`);\n  }\n\n  const eventDecryptionFragment: EthersT.EventFragment | null =\n    decryptionOracleContractInterface.getEvent(\"DecryptionRequest\");\n  if (!eventDecryptionFragment) {\n    throw new FhevmError(`Unknown \"DecryptionRequest\" event`);\n  }\n\n  // Wild card\n  const topics = decryptionOracleContractInterface.encodeFilterTopics(eventDecryptionFragment, []);\n\n  const filter: EthersT.Filter = {\n    address: decryptionOracleContractAddress,\n    fromBlock,\n    toBlock,\n    topics,\n  };\n\n  const logs = await readonlyProvider.getLogs(filter);\n\n  const cursor = new BlockLogCursor(-1);\n  const events: DecryptionOracleEvent[] = logs\n    .map((log) => {\n      try {\n        cursor.updateForward(log.blockNumber, log.index);\n\n        const parsedLog = decryptionOracleContractInterface.parseLog(log)!;\n\n        if (!isDecryptionOracleEventName(parsedLog.name)) {\n          return null;\n        }\n\n        if (log.blockNumber === fromBlock) {\n          if (options.fromBlockLogIndex !== undefined) {\n            if (log.index < options.fromBlockLogIndex) {\n              return null;\n            }\n          }\n        }\n\n        const evt: DecryptionOracleEvent = {\n          eventName: parsedLog.name,\n          args: parsedLog.args,\n          index: log.index,\n          blockNumber: log.blockNumber,\n          transactionHash: log.transactionHash,\n          transactionIndex: log.transactionIndex,\n        };\n\n        return evt;\n      } catch {\n        // If the log cannot be parsed, skip it\n        return null;\n      }\n    })\n    .filter((event) => event !== null);\n\n  return { events, cursor };\n}\n\nexport function toDecryptionRequestEvent(e: DecryptionOracleEvent): DecryptionRequestEvent | null {\n  if (e.eventName !== \"DecryptionRequest\") {\n    return null;\n  }\n\n  const counter = e.args[0]; //uint256\n  const requestID = e.args[1]; //uint256\n  const handlesBytes32Hex = e.args[2] as string[]; //bytes32[]\n  const contractCallerAddress = e.args[3] as string; //address\n  const callbackSelectorBytes4Hex = e.args[4] as string; //bytes4\n\n  assertEventArgIsBigUint256(counter, \"DecryptionRequest\", 0);\n  assertEventArgIsBigUint256(requestID, \"DecryptionRequest\", 1);\n\n  assertFhevm(handlesBytes32Hex.length > 0);\n  assertEventArgIsBytes32String(handlesBytes32Hex[0], \"DecryptionRequest\", 2);\n  assertEventArgIsAddress(contractCallerAddress, \"DecryptionRequest\", 3);\n  assertEventArgIsBytes4String(callbackSelectorBytes4Hex, \"DecryptionRequest\", 4);\n\n  const evt: DecryptionRequestEvent = {\n    blockNumber: e.blockNumber,\n    index: e.index,\n    transactionHash: e.transactionHash,\n    transactionIndex: e.transactionIndex,\n    counter,\n    requestID,\n    handlesBytes32Hex,\n    contractCallerAddress,\n    callbackSelectorBytes4Hex,\n  };\n\n  return evt;\n}\n\nexport function parseDecryptionRequestEventsFromLogs(\n  logs: (EthersT.EventLog | EthersT.Log)[] | null | undefined,\n): DecryptionRequestEvent[] {\n  // flexible\n  if (!logs) {\n    return [];\n  }\n  const events: DecryptionRequestEvent[] = [];\n  for (const log of logs) {\n    const event: EthersT.LogDescription | null = DecryptionOraclePartialInterface.parseLog(log);\n\n    if (!event) {\n      continue;\n    }\n    if (!isDecryptionOracleEventName(event.name)) {\n      continue;\n    }\n\n    const doe: DecryptionOracleEvent = {\n      eventName: event.name,\n      args: event.args,\n      blockNumber: log.blockNumber,\n      index: log.index,\n      transactionHash: log.transactionHash,\n      transactionIndex: log.transactionIndex,\n    };\n\n    const e = toDecryptionRequestEvent(doe);\n    if (!e) {\n      continue;\n    }\n\n    events.push(e);\n  }\n\n  return events;\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { assertFhevm } from \"../../utils/error.js\";\nimport { KMSVerifier, computeDecryptionCallbackSignaturesAndCalldata } from \"../contracts/KMSVerifier.js\";\nimport type { FhevmDB } from \"../db/FhevmDB.js\";\nimport type { DecryptionRequestEvent } from \"./DecryptionOracleEvents.js\";\n\nexport class DecryptionOracleEventsHandler {\n  #db: FhevmDB;\n  #kmsVerifier: KMSVerifier;\n  #kmsSigners: EthersT.Signer[];\n  #relayerSigner: EthersT.Signer;\n\n  constructor(db: FhevmDB, kmsVerifier: KMSVerifier, kmsSigners: EthersT.Signer[], relayerSigner: EthersT.Signer) {\n    this.#db = db;\n    this.#kmsVerifier = kmsVerifier;\n    this.#kmsSigners = kmsSigners;\n    this.#relayerSigner = relayerSigner;\n  }\n\n  // coproc.await should have been called before\n  public async handleEvent(\n    decryptionRequestEvent: DecryptionRequestEvent,\n  ): Promise<{ tx: EthersT.TransactionResponse; receipt: EthersT.TransactionReceipt | null }> {\n    const clearTextsHex: string[] = [];\n    const handlesBytes32Hex: string[] = [];\n    for (let i = 0; i < decryptionRequestEvent.handlesBytes32Hex.length; ++i) {\n      assertFhevm(\n        decryptionRequestEvent.blockNumber >= this.#db.fromBlockNumber,\n        `Unexpected event blockNumber: decryptionRequestEvent.blockNumber < this.#db.fromBlockNumber`,\n      );\n      // if (decryptionRequestEvent.blockNumber < this.#db.fromBlockNumber) {\n      //   // Ignore. This is an old decryption request. This usually occurs when running\n      //   // tests using Anvil\n      //   continue;\n      // }\n      const entry = await this.#db.queryHandleBytes32(decryptionRequestEvent.handlesBytes32Hex[i]);\n      // should have thrown an exception earlier\n      assertFhevm(entry.clearTextHex !== \"0x\");\n      clearTextsHex.push(entry.clearTextHex);\n      handlesBytes32Hex.push(decryptionRequestEvent.handlesBytes32Hex[i]);\n    }\n\n    const extraDataV0: string = EthersT.solidityPacked([\"uint8\"], [0]);\n\n    const { calldata } = await computeDecryptionCallbackSignaturesAndCalldata(\n      handlesBytes32Hex,\n      clearTextsHex,\n      extraDataV0,\n      decryptionRequestEvent.requestID,\n      decryptionRequestEvent.callbackSelectorBytes4Hex,\n      EthersT.AbiCoder.defaultAbiCoder(),\n      this.#kmsVerifier,\n      this.#kmsSigners,\n    );\n\n    const txData = {\n      to: decryptionRequestEvent.contractCallerAddress,\n      data: calldata,\n    };\n\n    const tx = await this.#relayerSigner.sendTransaction(txData);\n    const receipt = await tx.wait();\n\n    return { tx, receipt };\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { BlockLogCursor } from \"../../ethers/event.js\";\nimport { assertFhevm } from \"../../utils/error.js\";\nimport type { DecryptionOracleEvent } from \"./DecryptionOracleEvents.js\";\nimport { getDecryptionOracleEvents } from \"./utils.js\";\n\nexport class DecryptionOracleEventsIterator {\n  #cursor: BlockLogCursor;\n  #decryptionOracleContractInterface: EthersT.Interface;\n  #decryptionOracleContractAddress: string;\n  #readonlyProvider: EthersT.Provider;\n\n  constructor(\n    decryptionOracleContractInterface: EthersT.Interface,\n    decryptionOracleContractAddress: string,\n    readonlyProvider: EthersT.Provider,\n    fromBlockNumber: number,\n  ) {\n    this.#decryptionOracleContractInterface = decryptionOracleContractInterface;\n    this.#decryptionOracleContractAddress = decryptionOracleContractAddress;\n    this.#readonlyProvider = readonlyProvider;\n    this.#cursor = new BlockLogCursor(fromBlockNumber);\n  }\n\n  public async next(): Promise<{\n    events: DecryptionOracleEvent[];\n    evmHasReverted: boolean;\n    currentBlockNumber: number;\n  }> {\n    // The oracle must detect any evm_revert call.\n    // The coprocessor, however, can run even if evm_revert is called.\n    let evmHasReverted = false;\n    const currentBlockNumber = await this.#readonlyProvider.getBlockNumber();\n    if (currentBlockNumber <= this.#cursor.blockNumber) {\n      evmHasReverted = true;\n      // send cursor backward since evm_revert has been executed\n      this.#cursor.update(currentBlockNumber - 1, 0);\n    }\n\n    const { events, cursor } = await getDecryptionOracleEvents(\n      this.#decryptionOracleContractInterface,\n      this.#decryptionOracleContractAddress,\n      this.#readonlyProvider,\n      {\n        fromBlockNumber: this.#cursor.nextBlockNumber,\n        toBlockNumber: currentBlockNumber,\n      },\n    );\n\n    if (!cursor.isEmpty) {\n      // events can be empty here!\n      this.#cursor.updateForward(cursor.blockNumber, cursor.blockLogIndex);\n    } else {\n      // if the cursor has not progressed, then necessarily the events array\n      // must be empty.\n      assertFhevm(events.length === 0);\n    }\n\n    return { events, evmHasReverted, currentBlockNumber };\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { FhevmError, assertFhevm } from \"../../utils/error.js\";\nimport { ACL } from \"../contracts/ACL.js\";\nimport { KMSVerifier, computeDecryptionSignatures } from \"../contracts/KMSVerifier.js\";\nimport type { Coprocessor } from \"../coprocessor/Coprocessor.js\";\nimport type { FhevmDB } from \"../db/FhevmDB.js\";\nimport type { DecryptionOracle } from \"./DecryptionOracle.js\";\nimport type { DecryptionRequestEvent } from \"./DecryptionOracleEvents.js\";\nimport { DecryptionOracleEventsHandler } from \"./DecryptionOracleEventsHandler.js\";\nimport { DecryptionOracleEventsIterator } from \"./DecryptionOracleEventsIterator.js\";\nimport { DecryptionOraclePartialInterface } from \"./abi.js\";\nimport { toDecryptionRequestEvent } from \"./utils.js\";\n\ntype DecryptionRequestDBEntry = {\n  event: {\n    counter: number;\n    requestID: number;\n    contractCallerAddress: string;\n    index: number;\n    blockNumber: number;\n    transactionHash: string;\n    transactionIndex: number;\n  };\n  callbackBlockNumber: number | undefined;\n  callbackTransactionHash: string | undefined;\n  callbackReverted: boolean | undefined;\n  pending: boolean;\n};\n\nclass MockDecryptionOracleDB {\n  #map: Map<string, DecryptionRequestDBEntry> = new Map<string, DecryptionRequestDBEntry>();\n\n  private static key(event: DecryptionRequestEvent, counterOverride?: bigint | number) {\n    return `${Number(counterOverride ?? event.counter)}}`;\n  }\n\n  public tryQuery(event: DecryptionRequestEvent): DecryptionRequestDBEntry | undefined {\n    return this.#map.get(MockDecryptionOracleDB.key(event));\n  }\n\n  public delete(event: DecryptionRequestEvent) {\n    this.#map.delete(MockDecryptionOracleDB.key(event));\n  }\n\n  public setPending(event: DecryptionRequestEvent, evmHasReverted: boolean): DecryptionRequestDBEntry {\n    if (this.has(event) && !evmHasReverted) {\n      throw new FhevmError(\n        `Decryption Request counter=${event.counter}, requestID=${event.requestID}, contractCaller=${event.contractCallerAddress} already registered`,\n      );\n    }\n    const entry: DecryptionRequestDBEntry = {\n      event: {\n        counter: Number(event.counter),\n        requestID: Number(event.requestID),\n        contractCallerAddress: event.contractCallerAddress,\n        index: event.index,\n        blockNumber: event.blockNumber,\n        transactionHash: event.transactionHash,\n        transactionIndex: event.transactionIndex,\n      },\n      callbackBlockNumber: -1,\n      callbackTransactionHash: undefined,\n      callbackReverted: undefined,\n      pending: true,\n    };\n    this.#map.set(MockDecryptionOracleDB.key(event), entry);\n    return entry;\n  }\n\n  public isPending(event: DecryptionRequestEvent): boolean {\n    const entry = this.#map.get(MockDecryptionOracleDB.key(event));\n    if (!entry) {\n      return false;\n    }\n    return entry.pending;\n  }\n\n  public executed(event: DecryptionRequestEvent): boolean {\n    const entry = this.#map.get(MockDecryptionOracleDB.key(event));\n    if (!entry) {\n      return false;\n    }\n    return !entry.pending;\n  }\n\n  public has(event: DecryptionRequestEvent): boolean {\n    return this.#map.has(MockDecryptionOracleDB.key(event));\n  }\n}\n\nexport class MockDecryptionOracle implements DecryptionOracle {\n  #iterator: DecryptionOracleEventsIterator | undefined;\n  #handler: DecryptionOracleEventsHandler | undefined;\n  #readonlyProvider: EthersT.Provider | undefined;\n  #coprocessor: Coprocessor | undefined;\n  #requestDB: MockDecryptionOracleDB = new MockDecryptionOracleDB();\n  #acl: ACL | undefined;\n  #kmsVerifier: KMSVerifier | undefined;\n  #kmsSigners: EthersT.Signer[] | undefined;\n\n  public static async create(\n    readonlyProvider: EthersT.Provider,\n    params: {\n      decryptionOracleContractAddress: string;\n      decryptionOracleContractInterface?: EthersT.Interface;\n      kmsSigners: EthersT.Signer[];\n      kmsVerifierContractAddress: string;\n      aclContractAddress: string;\n      coprocessor: Coprocessor;\n      relayerSigner: EthersT.Signer;\n    },\n  ): Promise<MockDecryptionOracle> {\n    const mdo = new MockDecryptionOracle();\n    const db: FhevmDB = params.coprocessor.getDB();\n    const decryptionOracleContractItf = params.decryptionOracleContractInterface ?? DecryptionOraclePartialInterface;\n    mdo.#readonlyProvider = readonlyProvider;\n    mdo.#coprocessor = params.coprocessor;\n    mdo.#iterator = new DecryptionOracleEventsIterator(\n      decryptionOracleContractItf,\n      params.decryptionOracleContractAddress,\n      readonlyProvider,\n      db.fromBlockNumber,\n    );\n    mdo.#kmsVerifier = await KMSVerifier.create(readonlyProvider, params.kmsVerifierContractAddress);\n    mdo.#acl = await ACL.create(readonlyProvider, params.aclContractAddress);\n    mdo.#handler = new DecryptionOracleEventsHandler(db, mdo.#kmsVerifier, params.kmsSigners, params.relayerSigner);\n    mdo.#kmsSigners = params.kmsSigners;\n    return mdo;\n  }\n\n  public async createDecryptionSignatures(\n    handlesBytes32Hex: string[],\n    clearTextValues: (bigint | string | boolean)[],\n    extraData: string,\n  ): Promise<{ decryptedResult: string; signatures: string[] }> {\n    assertFhevm(this.#kmsVerifier !== undefined, `MockDecryptionOracle not initialized`);\n    assertFhevm(this.#kmsSigners !== undefined, `MockDecryptionOracle not initialized`);\n\n    const res = await computeDecryptionSignatures(\n      handlesBytes32Hex,\n      clearTextValues,\n      extraData,\n      EthersT.AbiCoder.defaultAbiCoder(),\n      this.#kmsVerifier,\n      this.#kmsSigners,\n    );\n\n    return { decryptedResult: res.decryptedResult, signatures: res.signatures };\n  }\n\n  public async awaitDecryptionOracle(): Promise<void> {\n    assertFhevm(this.#coprocessor !== undefined, `MockDecryptionOracle not initialized`);\n    assertFhevm(this.#iterator !== undefined, `MockDecryptionOracle not initialized`);\n    assertFhevm(this.#readonlyProvider !== undefined, `MockDecryptionOracle not initialized`);\n    assertFhevm(this.#acl !== undefined, `MockDecryptionOracle not initialized`);\n    assertFhevm(this.#handler !== undefined, `MockDecryptionOracle not initialized`);\n\n    // Required (healthier to do it even if events in empty)\n    await this.#coprocessor.awaitCoprocessor();\n\n    // Warning test: solidityCoverageRunning\n    const { events, evmHasReverted } = await this.#iterator.next();\n\n    for (let i = 0; i < events.length; ++i) {\n      const dre: DecryptionRequestEvent | null = toDecryptionRequestEvent(events[i]);\n      if (!dre) {\n        continue;\n      }\n\n      // Should not process an already processed event\n      if (this.#requestDB.isPending(dre)) {\n        throw new FhevmError(\n          `DecryptionRequest requestID=${dre.requestID}, contractCaller=${dre.contractCallerAddress} already being executed.`,\n        );\n      }\n\n      // First throw if ACL permission failed.\n      await this.#acl.checkIsAllowedForDecryption(dre.handlesBytes32Hex, this.#readonlyProvider);\n\n      // This is not formally exact. We pass a flag indicating that the evm has reverted to a given\n      // snapshot id. This can only occur on dev chains.\n      const newEntry = this.#requestDB.setPending(dre, evmHasReverted);\n      assertFhevm(newEntry.pending);\n      assertFhevm(newEntry.callbackBlockNumber === -1);\n      assertFhevm(newEntry.callbackReverted === undefined);\n      assertFhevm(newEntry.callbackTransactionHash === undefined);\n\n      try {\n        const { tx, receipt } = await this.#handler.handleEvent(dre);\n        newEntry.callbackBlockNumber = receipt?.blockNumber;\n        newEntry.callbackReverted = receipt?.status === 0;\n        newEntry.callbackTransactionHash = tx.hash;\n        newEntry.pending = false;\n      } catch (e) {\n        this.#requestDB.delete(dre);\n        throw e;\n      }\n    }\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { FhevmError, assertFhevm } from \"../../utils/error.js\";\nimport { remove0x } from \"../../utils/string.js\";\nimport type { EIP712 } from \"../types.js\";\n\n// Follows relayer-sdk keys lengths\nconst ML_KEM_CT_PK_LENGTH: number = 1568;\nconst ML_KEM_SK_LENGTH: number = 3168;\n\nconst PUBLIC_KEY_LENGTH: number = (ML_KEM_CT_PK_LENGTH + 8) * 2;\nconst PRIVATE_KEY_LENGTH: number = (ML_KEM_SK_LENGTH + 8) * 2;\n\nfunction _verifyKeypair(keyPair: { publicKey: string; privateKey: string }) {\n  keyPair.publicKey = remove0x(keyPair.publicKey);\n  keyPair.privateKey = remove0x(keyPair.privateKey);\n\n  if (!EthersT.isHexString(\"0x\" + keyPair.publicKey, PUBLIC_KEY_LENGTH)) {\n    throw new FhevmError(\n      `Invalid key pair's publicKey. Call FhevmInstance.generateKeyPair() to generate a valid FHEVM key pair.`,\n    );\n  }\n  if (!EthersT.isHexString(\"0x\" + keyPair.privateKey, PRIVATE_KEY_LENGTH)) {\n    throw new FhevmError(\n      `Invalid key pair's publicKey. Call FhevmInstance.generateKeyPair() to generate a valid FHEVM key pair.`,\n    );\n  }\n}\n\nexport function generateKeypair(): {\n  publicKey: string;\n  privateKey: string;\n} {\n  const wallet = EthersT.Wallet.createRandom();\n\n  const walletPublicKeyNoPrefix = remove0x(wallet.publicKey);\n  const walletPrivateKeyNoPrefix = remove0x(wallet.privateKey);\n\n  assertFhevm(walletPublicKeyNoPrefix.length === walletPrivateKeyNoPrefix.length + 2);\n\n  const publicKeyPrefixLen = 2 * PUBLIC_KEY_LENGTH - walletPublicKeyNoPrefix.length;\n  const privateKeyPrefixLen = 2 * PRIVATE_KEY_LENGTH - (2 + walletPrivateKeyNoPrefix.length);\n\n  let n = Math.floor(publicKeyPrefixLen / 8);\n  const publicKeyPrefix = \"deadbeef\".repeat(n) + \"0\".repeat(publicKeyPrefixLen - n * 8);\n\n  n = Math.floor(privateKeyPrefixLen / 8);\n  const privateKeyPrefix = \"deadbeef\".repeat(n) + \"0\".repeat(privateKeyPrefixLen - n * 8);\n\n  const publicKey = \"0x\" + publicKeyPrefix + walletPublicKeyNoPrefix;\n  const privateKey = \"0x\" + privateKeyPrefix + \"00\" + walletPrivateKeyNoPrefix;\n\n  assertFhevm(publicKey.length === 2 + 2 * PUBLIC_KEY_LENGTH);\n  assertFhevm(privateKey.length === 2 + 2 * PRIVATE_KEY_LENGTH);\n  assertFhevm(walletPublicKeyNoPrefix.length === 66);\n  assertFhevm(walletPrivateKeyNoPrefix.length === 64);\n\n  const keypair = {\n    publicKey,\n    privateKey,\n  };\n\n  _verifyKeypair(keypair);\n\n  return keypair;\n}\n\n/*\n  Copy/Paste from https://github.com/zama-ai/relayer-sdk/main/src/sdk/keypair.ts\n*/\n\n/**\n * Creates an EIP712 structure specifically for user decrypt requests\n *\n * @param gatewayChainId - The chain ID of the gateway\n * @param verifyingContract - The address of the contract that will verify the signature\n * @param publicKey - The user's public key as a hex string or Uint8Array\n * @param contractAddresses - Array of contract addresses that can access the decryption\n * @param contractsChainId - The chain ID where the contracts are deployed\n * @param startTimestamp - The timestamp when the decryption permission becomes valid\n * @param durationDays - How many days the decryption permission remains valid\n * @param delegatedAccount - Optional delegated account address\n * @returns EIP712 typed data structure for user decryption\n */\nexport const createEIP712 =\n  (verifyingContract: string, contractsChainId: number) =>\n  (\n    publicKey: string | Uint8Array,\n    contractAddresses: string[],\n    startTimestamp: string | number,\n    durationDays: string | number,\n    delegatedAccount?: string,\n  ): EIP712 => {\n    const extraData: `0x${string}` = \"0x00\";\n    if (delegatedAccount && !EthersT.isAddress(delegatedAccount)) throw new Error(\"Invalid delegated account.\");\n\n    if (!EthersT.isAddress(verifyingContract)) {\n      throw new Error(\"Invalid verifying contract address.\");\n    }\n\n    if (!contractAddresses.every((c) => EthersT.isAddress(c))) {\n      throw new Error(\"Invalid contract address.\");\n    }\n    // Format the public key based on its type\n    const formattedPublicKey =\n      typeof publicKey === \"string\" ? (publicKey.startsWith(\"0x\") ? publicKey : `0x${publicKey}`) : publicKey;\n\n    // Convert timestamps to strings if they're bigints\n    const formattedStartTimestamp = typeof startTimestamp === \"number\" ? startTimestamp.toString() : startTimestamp;\n\n    const formattedDurationDays = typeof durationDays === \"number\" ? durationDays.toString() : durationDays;\n\n    const EIP712Domain = [\n      { name: \"name\", type: \"string\" },\n      { name: \"version\", type: \"string\" },\n      { name: \"chainId\", type: \"uint256\" },\n      { name: \"verifyingContract\", type: \"address\" },\n    ];\n\n    const domain = {\n      name: \"Decryption\",\n      version: \"1\",\n      chainId: contractsChainId,\n      verifyingContract,\n    };\n\n    if (delegatedAccount) {\n      return {\n        types: {\n          EIP712Domain,\n          DelegatedUserDecryptRequestVerification: [\n            { name: \"publicKey\", type: \"bytes\" },\n            { name: \"contractAddresses\", type: \"address[]\" },\n            { name: \"contractsChainId\", type: \"uint256\" },\n            { name: \"startTimestamp\", type: \"uint256\" },\n            { name: \"durationDays\", type: \"uint256\" },\n            { name: \"extraData\", type: \"bytes\" },\n            {\n              name: \"delegatedAccount\",\n              type: \"address\",\n            },\n          ],\n        },\n        primaryType: \"DelegatedUserDecryptRequestVerification\",\n        domain,\n        message: {\n          publicKey: formattedPublicKey,\n          contractAddresses,\n          contractsChainId,\n          startTimestamp: formattedStartTimestamp,\n          durationDays: formattedDurationDays,\n          extraData,\n          delegatedAccount: delegatedAccount,\n        },\n      };\n    }\n\n    return {\n      types: {\n        EIP712Domain,\n        UserDecryptRequestVerification: [\n          { name: \"publicKey\", type: \"bytes\" },\n          { name: \"contractAddresses\", type: \"address[]\" },\n          { name: \"contractsChainId\", type: \"uint256\" },\n          { name: \"startTimestamp\", type: \"uint256\" },\n          { name: \"durationDays\", type: \"uint256\" },\n          { name: \"extraData\", type: \"bytes\" },\n        ],\n      },\n      primaryType: \"UserDecryptRequestVerification\",\n      domain,\n      message: {\n        publicKey: formattedPublicKey,\n        contractAddresses,\n        contractsChainId,\n        startTimestamp: formattedStartTimestamp,\n        durationDays: formattedDurationDays,\n        extraData,\n      },\n    };\n  };\n", "import { ethers as EthersT } from \"ethers\";\n\nimport constants from \"../constants.js\";\nimport type { MinimalProvider } from \"../ethers/provider.js\";\nimport { ENCRYPTION_TYPES, type RelayerEncryptedInput } from \"../relayer-sdk/types.js\";\nimport { concatBytes, uintToBytes } from \"../utils/bytes.js\";\nimport { FhevmError, assertFhevm } from \"../utils/error.js\";\nimport { MAX_UINT64, boolToBigInt, getMaxBigInt } from \"../utils/math.js\";\nimport { FheType, getFheTypeBitLength, getFheTypeByteLength } from \"./FheType.js\";\nimport { FhevmHandle } from \"./FhevmHandle.js\";\nimport { FhevmType, FhevmTypeToFheType, getFhevmTypeInfo, isFhevmEbytes, isFhevmEuint } from \"./FhevmType.js\";\nimport { InputVerifier, computeInputProofHex } from \"./contracts/InputVerifier.js\";\nimport type { FhevmDBHandleMetadata } from \"./db/FhevmDB.js\";\nimport * as relayer from \"./relayer/index.js\";\nimport type { MockRelayerData, MockRelayerV1InputProofPayload } from \"./relayer/mock_payloads.js\";\n\ntype FhevmSdkEncryptionBitWidths = keyof typeof ENCRYPTION_TYPES;\n\nexport class MockRelayerEncryptedInput implements RelayerEncryptedInput {\n  #clearTextValues: (bigint | string)[] = [];\n  #fhevmTypes: FhevmType[] = [];\n  #fheTypes: FheType[] = [];\n  #totalFheBits: number = 0;\n\n  #contractChainId: number;\n  #contractAddress: string;\n  #userAddress: string;\n\n  #relayerProvider: MinimalProvider;\n  #aclContractAddress: string;\n  #inputVerifier: InputVerifier;\n\n  static readonly MAX_FHE_BITS: number = 2048;\n  static readonly MAX_VAR_COUNT: number = 256;\n\n  constructor(\n    relayerProvider: MinimalProvider,\n    contractChainId: number,\n    contractAddress: string,\n    userAddress: string,\n    aclContractAddress: string,\n    inputVerifier: InputVerifier,\n  ) {\n    // Check if chainId exceeds 8 bytes\n    if (BigInt(contractChainId) > MAX_UINT64) {\n      throw new Error(\"ChainId exceeds maximum allowed value (8 bytes)\"); // fhevm assumes chainID is only taking up to 8 bytes\n    }\n\n    this.#relayerProvider = relayerProvider;\n    this.#contractChainId = contractChainId;\n    this.#contractAddress = contractAddress;\n    this.#userAddress = userAddress;\n    this.#aclContractAddress = aclContractAddress;\n    this.#inputVerifier = inputVerifier;\n  }\n\n  public get userAddress(): string {\n    return this.#userAddress;\n  }\n\n  public get contractAddress(): string {\n    return this.#contractAddress;\n  }\n\n  private _checkAddFheBits(fheBitLen: number) {\n    assertFhevm(fheBitLen >= 0);\n    if (this.#totalFheBits + fheBitLen > MockRelayerEncryptedInput.MAX_FHE_BITS) {\n      throw Error(\"Packing more than 2048 bits in a single input ciphertext is unsupported\");\n    }\n    if (this.#clearTextValues.length + 1 > MockRelayerEncryptedInput.MAX_VAR_COUNT) {\n      throw Error(\"Packing more than 256 variables in a single input ciphertext is unsupported\");\n    }\n  }\n\n  private _addClearTextValueFheBitsPair(clearTextValue: string | bigint, fhevmType: FhevmType) {\n    // Bool = 2\n    const fheType = FhevmTypeToFheType(fhevmType);\n    const fheBitLen = getFheTypeBitLength(fheType);\n\n    this._checkAddFheBits(fheBitLen);\n\n    this.#fhevmTypes.push(fhevmType);\n    this.#fheTypes.push(fheType);\n    this.#clearTextValues.push(clearTextValue);\n    this.#totalFheBits += fheBitLen;\n\n    assertFhevm(this.#clearTextValues.length <= MockRelayerEncryptedInput.MAX_VAR_COUNT);\n    assertFhevm(this.#totalFheBits <= MockRelayerEncryptedInput.MAX_FHE_BITS);\n    assertFhevm(this.#clearTextValues.length === this.#fheTypes.length);\n    assertFhevm(this.#clearTextValues.length === this.#fhevmTypes.length);\n  }\n\n  private _addBytes(clearTextValue: Uint8Array, fhevmType: FhevmType): MockRelayerEncryptedInput {\n    assertFhevm(isFhevmEbytes(fhevmType));\n\n    const fhevmTypeInfo = getFhevmTypeInfo(fhevmType);\n    const fheBitLen = getFheTypeBitLength(fhevmTypeInfo.fheType);\n    const clearTextBitLen = fhevmTypeInfo.clearTextBitLength;\n\n    // For bytes, cleatText bit length and cypherText bit length are the same\n    assertFhevm(clearTextBitLen === fheBitLen);\n    assertFhevm(fheBitLen % 8 === 0);\n\n    const fheByteLen = fheBitLen / 8;\n\n    if (clearTextValue.length > fheByteLen) {\n      throw new FhevmError(\n        `Uncorrect length of input Uint8Array, should be ${fheByteLen} for an ${fhevmTypeInfo.name}`,\n      );\n    }\n\n    const clearTextValueBigInt: bigint = EthersT.toBigInt(clearTextValue);\n    const maxClearTextValueBigInt: bigint = getMaxBigInt(clearTextBitLen);\n    //const clearTextValueBigInt : bigint = bytesToBigInt(clearTextValue);\n\n    assertFhevm(clearTextValue.length * 8 === fheBitLen);\n    assertFhevm(clearTextValueBigInt <= maxClearTextValueBigInt);\n\n    this._addClearTextValueFheBitsPair(clearTextValueBigInt, fhevmType);\n\n    return this;\n  }\n\n  private _addUint(clearTextValue: number | bigint, fhevmzType: FhevmType): MockRelayerEncryptedInput {\n    assertFhevm(isFhevmEuint(fhevmzType));\n\n    const fhevmTypeInfo = getFhevmTypeInfo(fhevmzType);\n    const clearTextBitLen = fhevmTypeInfo.clearTextBitLength;\n\n    if (clearTextValue < 0) {\n      throw new FhevmError(`Invalid unsigned integer value ${clearTextValue}`);\n    }\n\n    const clearTextValueBigInt: bigint = BigInt(clearTextValue);\n    const maxClearTextValueBigInt: bigint = getMaxBigInt(clearTextBitLen);\n\n    if (clearTextValueBigInt > maxClearTextValueBigInt) {\n      throw new FhevmError(\n        `Invalid ${fhevmTypeInfo.solidityTypeName} value: ${clearTextValue}, it exceeds the maximum allowed value of ${maxClearTextValueBigInt}.`,\n      );\n    }\n\n    this._addClearTextValueFheBitsPair(clearTextValueBigInt, fhevmzType);\n\n    return this;\n  }\n\n  // Accepts : 0, 1, true, false\n  public addBool(value: number | bigint | boolean) {\n    const zeroOrOneBigInt: 0n | 1n = boolToBigInt(value);\n\n    this._addClearTextValueFheBitsPair(zeroOrOneBigInt, FhevmType.ebool);\n\n    return this;\n  }\n  public add8(value: number | bigint) {\n    return this._addUint(value, FhevmType.euint8);\n  }\n  public add16(value: number | bigint) {\n    return this._addUint(value, FhevmType.euint16);\n  }\n  public add32(value: number | bigint) {\n    return this._addUint(value, FhevmType.euint32);\n  }\n  public add64(value: number | bigint) {\n    return this._addUint(value, FhevmType.euint64);\n  }\n  public add128(value: number | bigint) {\n    return this._addUint(value, FhevmType.euint128);\n  }\n  public addAddress(value: string) {\n    if (!EthersT.isAddress(value)) {\n      throw new Error(\"Invalid address value: ${value}.\");\n    }\n\n    const clearTextValue = EthersT.getAddress(value);\n\n    this._addClearTextValueFheBitsPair(clearTextValue, FhevmType.eaddress);\n\n    return this;\n  }\n  public add256(value: number | bigint): RelayerEncryptedInput {\n    return this._addUint(value, FhevmType.euint256);\n  }\n  public addBytes64(value: Uint8Array): RelayerEncryptedInput {\n    return this._addBytes(value, FhevmType.ebytes64);\n  }\n  public addBytes128(value: Uint8Array): RelayerEncryptedInput {\n    return this._addBytes(value, FhevmType.ebytes128);\n  }\n  public addBytes256(value: Uint8Array): RelayerEncryptedInput {\n    return this._addBytes(value, FhevmType.ebytes256);\n  }\n\n  private _toMockFhevmRelayerV1InputProofPayload(extraData: string): MockRelayerV1InputProofPayload {\n    const numHandles = this.#clearTextValues.length;\n    const clearTextValuesBigIntHex: string[] = [];\n    const clearTextValuesBigInt: bigint[] = [];\n    const rand32BufferList: Uint8Array[] = [];\n    const metadatas: FhevmDBHandleMetadata[] = [];\n    //const randomBytes = EthersT.getBytes(\"0xd3f33f613ae8521e98fe2aa43bd0c6ad37d81c388c93460b78683e692602b981\");\n    for (let i = 0; i < numHandles; ++i) {\n      const clearTextValueBigInt = BigInt(this.#clearTextValues[i]);\n      clearTextValuesBigInt.push(clearTextValueBigInt);\n      clearTextValuesBigIntHex.push(EthersT.toBeHex(clearTextValueBigInt));\n      rand32BufferList.push(EthersT.randomBytes(32));\n      //rand32BufferList.push(randomBytes);\n      metadatas.push({\n        blockNumber: 0,\n        index: 0,\n        transactionHash: EthersT.ZeroHash,\n      });\n    }\n\n    const mockCiphertextWithInputVerification: Uint8Array = MockRelayerEncryptedInput._computeMockCiphertextWithZKProof(\n      clearTextValuesBigInt,\n      this.#fheTypes,\n      rand32BufferList,\n    );\n\n    const mockData: MockRelayerData = {\n      clearTextValuesBigIntHex,\n      metadatas,\n      fheTypes: this.#fheTypes,\n      fhevmTypes: this.#fhevmTypes,\n      aclContractAddress: this.#aclContractAddress,\n      random32List: rand32BufferList.map(EthersT.hexlify),\n    };\n\n    const mockPayload: MockRelayerV1InputProofPayload = {\n      contractAddress: this.#contractAddress,\n      userAddress: this.#userAddress,\n      ciphertextWithInputVerification: EthersT.hexlify(mockCiphertextWithInputVerification),\n      contractChainId: \"0x\" + this.#contractChainId.toString(16),\n      extraData,\n      mockData,\n    };\n\n    return mockPayload;\n  }\n\n  private static _computeMockCiphertextWithZKProof(\n    clearTextValuesBigInt: bigint[],\n    fheTypes: FheType[],\n    rand32BufferList: Uint8Array[],\n  ): Uint8Array {\n    let encrypted: Uint8Array = new Uint8Array(0);\n\n    const numHandles = clearTextValuesBigInt.length;\n\n    assertFhevm(rand32BufferList.length === numHandles);\n    assertFhevm(fheTypes.length === numHandles);\n\n    // 1. Build the typed values hash\n    for (let i = 0; i < numHandles; ++i) {\n      /*\n        type + value as bigint + random(32)\n      */\n      const clearTextValueBigInt = clearTextValuesBigInt[i];\n      const fheByteLen = getFheTypeByteLength(fheTypes[i]);\n\n      const fheType1Byte = new Uint8Array([fheTypes[i]]);\n      const clearTextValueXXBytes = uintToBytes(clearTextValueBigInt, fheByteLen);\n      const rand32Buffer: Uint8Array = rand32BufferList[i];\n\n      // concatenate 32 random bytes at the end of buffer to simulate encryption noise\n      encrypted = concatBytes(encrypted, fheType1Byte, clearTextValueXXBytes, rand32Buffer);\n    }\n\n    return EthersT.getBytes(EthersT.keccak256(encrypted));\n  }\n\n  public async encrypt() {\n    const extraData: `0x${string}` = \"0x00\";\n\n    /*\n      Mock equivalent to https://github.com/zama-ai/fhevm-js/blob/main/src/relayer/sendEncryption.ts\n\n      From sendEncryption.ts:\n      =======================\n\n        const bits = input.getBits();\n        const ciphertext = input.encrypt();\n        const payload = {\n          contractAddress: getAddress(contractAddress),\n          userAddress: getAddress(userAddress),\n          ciphertextWithInputVerification: toHexString(ciphertext),\n          contractChainId: '0x' + chainId.toString(16),\n        };\n\n    */\n    const payload = this._toMockFhevmRelayerV1InputProofPayload(extraData);\n    const mockCiphertextWithZKProof = EthersT.getBytes(payload.ciphertextWithInputVerification);\n\n    /*\n      Mock equivalent to https://github.com/zama-ai/fhevm-js/blob/main/src/relayer/sendEncryption.ts\n\n        const url = `${relayerUrl}/v1/input-proof`;\n        ...\n        const response = await fetch(url, options);\n        ...\n\n      Will add the clear values to the mock database.\n    */\n\n    /*\n      const payload = {\n          contractAddress: getAddress(contractAddress),\n          userAddress: getAddress(userAddress),\n          ciphertextWithInputVerification: toHexString(ciphertext),\n          contractChainId: '0x' + chainId.toString(16),\n        };\n        const options = {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify(payload),\n        };\n    */\n    const response = await relayer.requestRelayerV1InputProof(this.#relayerProvider, payload);\n\n    const handlesBytes32List = FhevmHandle.computeHandles(\n      mockCiphertextWithZKProof,\n      this.#fhevmTypes,\n      this.#aclContractAddress,\n      this.#contractChainId,\n      constants.FHEVM_HANDLE_VERSION,\n    );\n\n    this.#inputVerifier.verifySignatures(\n      handlesBytes32List,\n      this.#userAddress,\n      this.#contractAddress,\n      this.#contractChainId,\n      extraData,\n      response.signatures,\n    );\n\n    const inputProofHex = computeInputProofHex(response.handles, response.signatures, extraData);\n\n    return {\n      handles: handlesBytes32List,\n      inputProof: EthersT.toBeArray(inputProofHex),\n    };\n  }\n\n  public getBits(): FhevmSdkEncryptionBitWidths[] {\n    throw new FhevmError(\"ZKInput interface method: Not supported in mock mode\");\n  }\n}\n", "/*\n    Copy/Paste from https://github.com/zama-ai/relayer-sdk/blob/main/src/relayer/decryptUtils.ts#L18\n*/\n\n// Duplicated code from relayer-sdk/src/relayer/userDecrypt.ts\nconst NumEncryptedBits: Record<number, number> = {\n  0: 2, // ebool\n  2: 8, // euint8\n  3: 16, // euint16\n  4: 32, // euint32\n  5: 64, // euint64\n  6: 128, // euint128\n  7: 160, // eaddress\n  8: 256, // euint256\n} as const;\n\n// Duplicated code from relayer-sdk/src/relayer/userDecrypt.ts\nexport function checkEncryptedBits(handles: string[]) {\n  let total = 0;\n\n  for (const handle of handles) {\n    if (handle.length !== 66) {\n      throw new Error(`Handle ${handle} is not of valid length`);\n    }\n\n    const hexPair = handle.slice(-4, -2).toLowerCase();\n    const typeDiscriminant = parseInt(hexPair, 16);\n\n    if (!(typeDiscriminant in NumEncryptedBits)) {\n      throw new Error(`Handle ${handle} is not of valid type`);\n    }\n\n    total += NumEncryptedBits[typeDiscriminant as keyof typeof NumEncryptedBits];\n\n    // enforce 2048bit limit\n    if (total > 2048) {\n      throw new Error(\"Cannot decrypt more than 2048 encrypted bits in a single request\");\n    }\n  }\n  return total;\n}\n", "/*\n    Copy/Paste from https://github.com/zama-ai/relayer-sdk/blob/main/src/relayer/publicDecrypt.ts\n*/\nimport { ethers as EthersT } from \"ethers\";\n\nimport type { DecryptedResults } from \"../types.js\";\n\n// Duplicated code from relayer-sdk/src/relayer/publicDecrypt.ts\nconst CiphertextType: Record<number, \"bool\" | \"uint256\" | \"address\" | \"bytes\"> = {\n  0: \"bool\",\n  2: \"uint256\",\n  3: \"uint256\",\n  4: \"uint256\",\n  5: \"uint256\",\n  6: \"uint256\",\n  7: \"address\",\n  8: \"uint256\",\n};\n\n// Duplicated code from relayer-sdk/src/relayer/publicDecrypt.ts\nexport function deserializeDecryptedResult(handles: string[], decryptedResult: string): DecryptedResults {\n  let typesList: number[] = [];\n  for (const handle of handles) {\n    const hexPair = handle.slice(-4, -2).toLowerCase();\n    const typeDiscriminant = parseInt(hexPair, 16);\n    typesList.push(typeDiscriminant);\n  }\n\n  const restoredEncoded =\n    \"0x\" +\n    \"00\".repeat(32) + // dummy requestID (ignored)\n    decryptedResult.slice(2) +\n    \"00\".repeat(32); // dummy empty bytes[] length (ignored)\n\n  const abiTypes = typesList.map((t) => {\n    const abiType = CiphertextType[t]; // all types are valid because this was supposedly checked already inside the `checkEncryptedBits` function\n    return abiType;\n  });\n\n  const coder = new EthersT.AbiCoder();\n  const decoded = coder.decode([\"uint256\", ...abiTypes, \"bytes[]\"], restoredEncoded);\n\n  // strip dummy first/last element\n  const rawValues = decoded.slice(1, 1 + typesList.length);\n\n  let results: DecryptedResults = {};\n  handles.forEach((handle, idx) => (results[handle] = rawValues[idx]));\n\n  return results;\n}\n", "/*\n    This file contains duplicated code from relayer-sdk/src/relayer/userDecrypt.ts\n*/\nimport { ethers as EthersT } from \"ethers\";\n\nimport { FhevmError } from \"../../utils/error.js\";\nimport type { DecryptedResults } from \"../types.js\";\n\nconst MAX_USER_DECRYPT_CONTRACT_ADDRESSES: number = 10;\nconst MAX_USER_DECRYPT_DURATION_DAYS: bigint = 365n;\n\n// Duplicated code from relayer-sdk/src/relayer/userDecrypt.ts\nexport function checkDeadlineValidity(startTimestamp: bigint, durationDays: bigint) {\n  if (durationDays === BigInt(0)) {\n    throw new FhevmError(\"durationDays is null\");\n  }\n\n  if (durationDays > MAX_USER_DECRYPT_DURATION_DAYS) {\n    throw new FhevmError(`durationDays is above max duration of ${MAX_USER_DECRYPT_DURATION_DAYS}`);\n  }\n\n  const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));\n  if (startTimestamp > currentTimestamp) {\n    throw new FhevmError(\"startTimestamp is set in the future\");\n  }\n\n  const durationInSeconds = durationDays * BigInt(86400);\n  if (startTimestamp + durationInSeconds < currentTimestamp) {\n    throw new FhevmError(\"User decrypt request has expired\");\n  }\n}\n\n// Duplicated code from relayer-sdk/src/relayer/userDecrypt.ts\nfunction formatAccordingToType(decryptedBigInt: bigint, type: number): boolean | bigint | string {\n  if (type === 0) {\n    // ebool\n    return decryptedBigInt === BigInt(1);\n  } else if (type === 7) {\n    // eaddress\n    return EthersT.getAddress(\"0x\" + decryptedBigInt.toString(16).padStart(40, \"0\"));\n  } else if (type === 9) {\n    // ebytes64\n    return \"0x\" + decryptedBigInt.toString(16).padStart(128, \"0\");\n  } else if (type === 10) {\n    // ebytes128\n    return \"0x\" + decryptedBigInt.toString(16).padStart(256, \"0\");\n  } else if (type === 11) {\n    // ebytes256\n    return \"0x\" + decryptedBigInt.toString(16).padStart(512, \"0\");\n  } // euintXXX\n  return decryptedBigInt;\n}\n\n// Duplicated code from relayer-sdk/src/relayer/userDecrypt.ts\nexport function buildUserDecryptedResult(handles: string[], listBigIntDecryptions: bigint[]): DecryptedResults {\n  let typesList: number[] = [];\n  for (const handle of handles) {\n    const hexPair = handle.slice(-4, -2).toLowerCase();\n    const typeDiscriminant = parseInt(hexPair, 16);\n    typesList.push(typeDiscriminant);\n  }\n\n  let results: DecryptedResults = {};\n  handles.forEach(\n    (handle, idx) => (results[handle] = formatAccordingToType(listBigIntDecryptions[idx], typesList[idx])),\n  );\n\n  return results;\n}\n\nexport function checkMaxContractAddresses(contractAddresses: string[]) {\n  const contractAddressesLength = contractAddresses.length;\n  if (contractAddressesLength === 0) {\n    throw new FhevmError(\"contractAddresses is empty\");\n  }\n  if (contractAddressesLength > MAX_USER_DECRYPT_CONTRACT_ADDRESSES) {\n    throw new FhevmError(`contractAddresses max length of ${MAX_USER_DECRYPT_CONTRACT_ADDRESSES} exceeded`);\n  }\n}\n", "/*\n    WARNING : Never import the \"hardhat\" package!\n*/\nimport { ethers as EthersT } from \"ethers\";\n\nimport constants from \"../constants.js\";\nimport { isThresholdReached } from \"../ethers/eip712.js\";\nimport type { MinimalProvider } from \"../ethers/provider.js\";\nimport { checkEncryptedBits } from \"../relayer-sdk/relayer/decryptUtils.js\";\nimport { deserializeDecryptedResult } from \"../relayer-sdk/relayer/publicDecrypt.js\";\nimport {\n  buildUserDecryptedResult,\n  checkDeadlineValidity,\n  checkMaxContractAddresses,\n} from \"../relayer-sdk/relayer/userDecrypt.js\";\nimport {\n  createEIP712 as fhevmSdkCreateEIP712ForDecryption,\n  generateKeypair as fhevmSdkGenerateKeypair,\n} from \"../relayer-sdk/types.js\";\nimport type {\n  DecryptedResults,\n  EIP712,\n  EIP712Type,\n  FhevmInstance,\n  HandleContractPair,\n  PublicParams,\n} from \"../relayer-sdk/types.js\";\nimport { assertIsAddress, assertIsAddressArray } from \"../utils/address.js\";\nimport { FhevmError, assertFhevm } from \"../utils/error.js\";\nimport { fromHexString, toHexString } from \"../utils/hex.js\";\nimport { assertIsNumber } from \"../utils/math.js\";\nimport { ensure0x, remove0x } from \"../utils/string.js\";\nimport { MockRelayerEncryptedInput } from \"./MockRelayerEncryptedInput.js\";\nimport { InputVerifier } from \"./contracts/InputVerifier.js\";\nimport { KMSVerifier } from \"./contracts/KMSVerifier.js\";\nimport * as relayer from \"./relayer/MockRelayer.js\";\nimport type {\n  RelayerV1PublicDecryptPayload,\n  RelayerV1UserDecryptHandleContractPair,\n  RelayerV1UserDecryptPayload,\n} from \"./relayer/payloads.js\";\n\nexport type MockFhevmInstanceConfigExtra = {\n  relayerProvider: MinimalProvider;\n  readonlyEthersProvider: EthersT.Provider;\n  inputVerifier: InputVerifier;\n  kmsVerifier: KMSVerifier;\n};\n\nexport type MockFhevmInstanceConfig = {\n  verifyingContractAddressDecryption: string;\n  verifyingContractAddressInputVerification: string;\n  kmsContractAddress: string;\n  inputVerifierContractAddress: string;\n  aclContractAddress: string;\n  chainId: number;\n  gatewayChainId: number;\n};\n\n/*\n  Only one instance is created for the whole HH session (including tests)\n*/\nexport class MockFhevmInstance implements FhevmInstance {\n  #relayerProvider: MinimalProvider;\n  #readonlyEthersProvider: EthersT.Provider;\n  #chainId: number; //provider's chainId\n  #gatewayChainId: number;\n  #verifyingContractAddressInputVerification: string;\n  #verifyingContractAddressDecryption: string;\n  #contractsChainId: number;\n  #aclContractAddress: string;\n  #kmsVerifier: KMSVerifier;\n  #inputVerifier: InputVerifier;\n\n  #fhevmSdkCreateEIP712ForDecryptionFunc: (\n    publicKey: string,\n    contractAddresses: string[],\n    startTimestamp: string | number,\n    durationDays: string | number,\n  ) => EIP712;\n\n  private constructor(config: MockFhevmInstanceConfig, extra: MockFhevmInstanceConfigExtra) {\n    assertIsAddress(\n      config.verifyingContractAddressInputVerification,\n      \"config.verifyingContractAddressInputVerification\",\n    );\n    assertIsAddress(config.verifyingContractAddressDecryption, \"config.verifyingContractAddressDecryption\");\n    assertIsNumber(config.gatewayChainId, \"config.gatewayChainId\");\n\n    this.#relayerProvider = extra.relayerProvider;\n    this.#readonlyEthersProvider = extra.readonlyEthersProvider;\n    this.#chainId = config.chainId;\n    this.#gatewayChainId = config.gatewayChainId;\n    this.#verifyingContractAddressInputVerification = config.verifyingContractAddressInputVerification;\n    this.#verifyingContractAddressDecryption = config.verifyingContractAddressDecryption;\n    this.#contractsChainId = config.chainId;\n    this.#aclContractAddress = config.aclContractAddress;\n    this.#kmsVerifier = extra.kmsVerifier;\n    this.#inputVerifier = extra.inputVerifier;\n    this.#fhevmSdkCreateEIP712ForDecryptionFunc = fhevmSdkCreateEIP712ForDecryption(\n      this.#verifyingContractAddressDecryption,\n      this.#contractsChainId,\n    );\n  }\n\n  public get chainId(): number {\n    return this.#chainId;\n  }\n\n  public static async create(\n    relayerProvider: MinimalProvider,\n    readonlyEthersProvider: EthersT.Provider,\n    config: MockFhevmInstanceConfig,\n  ): Promise<MockFhevmInstance> {\n    const kmsVerifier = await KMSVerifier.create(readonlyEthersProvider, config.kmsContractAddress);\n    const inputVerifier = await InputVerifier.create(readonlyEthersProvider, config.inputVerifierContractAddress);\n\n    const instance = new MockFhevmInstance(config, {\n      relayerProvider,\n      readonlyEthersProvider,\n      inputVerifier,\n      kmsVerifier,\n    });\n\n    return instance;\n  }\n\n  public static createEIP712(\n    publicKey: string,\n    contractAddresses: string[],\n    startTimestamp: string | number,\n    durationDays: string | number,\n    verifyingContractAddressDecryption: string,\n    contractsChainId: number,\n  ): EIP712 {\n    assertIsAddressArray(contractAddresses, \"contractAddresses\");\n\n    const eip712Func = fhevmSdkCreateEIP712ForDecryption(verifyingContractAddressDecryption, contractsChainId);\n    const eip712 = eip712Func(publicKey, contractAddresses, startTimestamp, durationDays);\n\n    //Debug Make sure we are in sync with KMSVerifier.sol\n    assertFhevm(eip712.domain.version === constants.PUBLIC_DECRYPT_EIP712.domain.version.toString());\n    assertFhevm(eip712.domain.name === constants.PUBLIC_DECRYPT_EIP712.domain.name);\n\n    return eip712;\n  }\n\n  // Create EIP712 for decryption\n  public createEIP712(\n    publicKey: string,\n    contractAddresses: string[],\n    startTimestamp: string | number,\n    durationDays: string | number,\n  ): EIP712 {\n    assertIsAddressArray(contractAddresses, \"contractAddresses\");\n\n    const eip712 = this.#fhevmSdkCreateEIP712ForDecryptionFunc(\n      publicKey,\n      contractAddresses,\n      startTimestamp,\n      durationDays,\n    );\n\n    //Debug Make sure we are in sync with KMSVerifier.sol\n    assertFhevm(BigInt(this.#gatewayChainId) === this.#kmsVerifier.eip712Domain.chainId);\n    assertFhevm(eip712.domain.verifyingContract === this.#kmsVerifier.eip712Domain.verifyingContract);\n    assertFhevm(eip712.domain.version === this.#kmsVerifier.eip712Domain.version);\n    assertFhevm(eip712.domain.name === this.#kmsVerifier.eip712Domain.name);\n    assertFhevm(BigInt(eip712.domain.chainId) === BigInt(this.#contractsChainId));\n\n    return eip712;\n  }\n\n  public createEncryptedInput(contractAddress: string, userAddress: string): MockRelayerEncryptedInput {\n    //Debug Make sure we are in sync with InputVerifier.sol\n    assertFhevm(this.#verifyingContractAddressInputVerification === this.#inputVerifier.eip712Domain.verifyingContract);\n    assertFhevm(BigInt(this.#gatewayChainId) === this.#inputVerifier.eip712Domain.chainId);\n\n    return new MockRelayerEncryptedInput(\n      this.#relayerProvider,\n      this.#chainId,\n      contractAddress,\n      userAddress,\n      this.#aclContractAddress,\n      this.#inputVerifier,\n    );\n  }\n\n  public generateKeypair(): { publicKey: string; privateKey: string } {\n    return fhevmSdkGenerateKeypair();\n  }\n\n  public getPublicKey(): {\n    publicKeyId: string;\n    publicKey: Uint8Array;\n  } | null {\n    throw new FhevmError(\"Not supported in mock mode\");\n  }\n\n  public getPublicParams(_bits: keyof PublicParams): {\n    publicParams: Uint8Array;\n    publicParamsId: string;\n  } | null {\n    throw new FhevmError(\"Not supported in mock mode\");\n  }\n\n  public async publicDecrypt(handles: (string | Uint8Array)[]): Promise<DecryptedResults> {\n    const extraData: `0x${string}` = \"0x00\";\n\n    // Intercept future type change...\n    for (let i = 0; i < handles.length; ++i) {\n      assertFhevm(\n        typeof handles[i] === \"string\" || handles[i] instanceof Uint8Array,\n        \"handle is not a string or a Uint8Array\",\n      );\n    }\n\n    // Casting handles if string\n    const relayerHandles: `0x${string}`[] = handles.map((h) =>\n      typeof h === \"string\" ? toHexString(fromHexString(h)) : toHexString(h),\n    );\n\n    // relayer-sdk\n    checkEncryptedBits(relayerHandles);\n\n    await MockFhevmInstance.verifyPublicACLPermissions(\n      this.#readonlyEthersProvider,\n      this.#aclContractAddress,\n      relayerHandles,\n    );\n\n    // relayer-sdk\n    const payloadForRequest: RelayerV1PublicDecryptPayload = {\n      ciphertextHandles: relayerHandles,\n      extraData,\n    };\n\n    // Return a json object basically following the @zama-fhe/relayer-sdk format\n    const json = await relayer.requestRelayerV1PublicDecrypt(this.#relayerProvider, payloadForRequest);\n    const result = json.response[0];\n\n    // Add \"0x\" prefix if needed\n    const decryptedResult = ensure0x(result.decrypted_value);\n    const signatures = result.signatures.map(ensure0x);\n\n    // verify signatures on decryption:\n    const domain = {\n      name: constants.PUBLIC_DECRYPT_EIP712.domain.name,\n      version: constants.PUBLIC_DECRYPT_EIP712.domain.version,\n      chainId: this.#gatewayChainId,\n      verifyingContract: this.#verifyingContractAddressDecryption,\n    };\n    const types = constants.PUBLIC_DECRYPT_EIP712.types;\n\n    // The `signedExtraData` variable is following the @zama-fhe/relayer-sdk implementation\n    // TODO: in relayer-sdk, signedExtraData === \"0x\". However, here, we use \"0x00\".\n    const signedExtraData = \"0x00\";\n\n    const recoveredAddresses = signatures.map((signature: `0x${string}`) => {\n      assertFhevm(signature.startsWith(\"0x\"));\n      const recoveredAddress = EthersT.verifyTypedData(\n        domain,\n        types,\n        { ctHandles: handles, decryptedResult, extraData: signedExtraData },\n        signature,\n      );\n      return recoveredAddress;\n    });\n\n    const thresholdReached = isThresholdReached(\n      this.#kmsVerifier.getKmsSignersAddresses(),\n      recoveredAddresses,\n      this.#kmsVerifier.getThreshold(),\n      \"KMS\",\n    );\n\n    if (!thresholdReached) {\n      throw Error(\"KMS signers threshold is not reached\");\n    }\n\n    const results = deserializeDecryptedResult(relayerHandles, decryptedResult);\n\n    return results;\n  }\n\n  public async userDecrypt(\n    handles: HandleContractPair[],\n    _privateKey: string,\n    publicKey: string,\n    signature: string,\n    contractAddresses: string[],\n    userAddress: string,\n    startTimestamp: string | number,\n    durationDays: string | number,\n  ): Promise<DecryptedResults> {\n    const extraData: `0x${string}` = \"0x00\";\n\n    // Intercept future type change...\n    for (let i = 0; i < handles.length; ++i) {\n      assertFhevm(\n        typeof handles[i].handle === \"string\" || handles[i].handle instanceof Uint8Array,\n        \"handle is not a string or a Uint8Array\",\n      );\n    }\n\n    // Casting handles if string\n    const relayerHandles: RelayerV1UserDecryptHandleContractPair[] = handles.map((h) => ({\n      handle: typeof h.handle === \"string\" ? toHexString(fromHexString(h.handle)) : toHexString(h.handle),\n      contractAddress: h.contractAddress,\n    }));\n\n    // relayer-sdk\n    checkEncryptedBits(relayerHandles.map((h) => h.handle));\n\n    // relayer-sdk\n    checkDeadlineValidity(BigInt(startTimestamp), BigInt(durationDays));\n\n    await MockFhevmInstance.verifyUserACLPermissions(\n      this.#readonlyEthersProvider,\n      this.#aclContractAddress,\n      relayerHandles,\n      userAddress,\n    );\n\n    // relayer-sdk\n    checkMaxContractAddresses(contractAddresses);\n\n    MockFhevmInstance.verifyHandleContractAddresses(relayerHandles, contractAddresses);\n\n    // Redundant: the mock relayer already performs this check, so it could be removed\n    await MockFhevmInstance.verifyUserDecryptSignature(\n      publicKey,\n      signature,\n      contractAddresses,\n      userAddress,\n      startTimestamp,\n      durationDays,\n      this.#verifyingContractAddressDecryption,\n      this.#contractsChainId,\n    );\n\n    // relayer-sdk\n    const payloadForRequest: RelayerV1UserDecryptPayload = {\n      handleContractPairs: relayerHandles,\n      requestValidity: {\n        startTimestamp: startTimestamp.toString(), // Convert to string\n        durationDays: durationDays.toString(), // Convert to string\n      },\n      contractsChainId: this.#chainId.toString(), // Convert to string\n      contractAddresses: contractAddresses.map((c) => EthersT.getAddress(c)),\n      userAddress: EthersT.getAddress(userAddress),\n      signature: remove0x(signature),\n      publicKey: remove0x(publicKey),\n      extraData,\n    };\n\n    // Return a json object basically following the @zama-fhe/relayer-sdk format\n    const json = await relayer.requestRelayerV1UserDecrypt(this.#relayerProvider, payloadForRequest);\n    const result = json.response[0];\n    // The `decrypted_values` field is specific to the mock relayer.\n    const clearTextHexList = result.payload.decrypted_values;\n\n    const listBigIntDecryptions = clearTextHexList.map(EthersT.toBigInt);\n\n    const results = buildUserDecryptedResult(\n      relayerHandles.map((h) => h.handle),\n      listBigIntDecryptions,\n    );\n\n    return results;\n  }\n\n  // Static function called by:\n  // - MockFhevmInstance.userDecrypt()\n  // - packages/hardhat-plugin/src/internal/provider/FhevmProviderExtender._handleFhevmRelayerV1UserDecrypt()\n  public static async verifyUserDecryptSignature(\n    publicKey: string,\n    signature: string,\n    contractAddresses: string[],\n    userAddress: string,\n    startTimestamp: string | number,\n    durationDays: string | number,\n    verifyingContractAddressDecryption: string,\n    contractsChainId: number,\n  ) {\n    publicKey = ensure0x(publicKey);\n    signature = ensure0x(signature);\n\n    const eip712: EIP712 = MockFhevmInstance.createEIP712(\n      publicKey,\n      contractAddresses,\n      startTimestamp,\n      durationDays,\n      verifyingContractAddressDecryption,\n      contractsChainId,\n    );\n\n    const types: Record<string, EIP712Type[]> = {};\n    types[eip712.primaryType] = eip712.types[eip712.primaryType];\n\n    const signerAddress = EthersT.verifyTypedData(eip712.domain, types, eip712.message, signature);\n\n    const normalizedSignerAddress = EthersT.getAddress(signerAddress);\n    const normalizedUserAddress = EthersT.getAddress(userAddress);\n\n    if (normalizedSignerAddress !== normalizedUserAddress) {\n      throw new FhevmError(\"Invalid EIP-712 signature!\");\n    }\n  }\n\n  public static async verifyPublicACLPermissions(\n    readonlyEthersProvider: EthersT.Provider,\n    aclContractAddress: string,\n    handles: string[],\n  ) {\n    const aclABI = [\"function isAllowedForDecryption(bytes32 handle) view returns (bool)\"];\n    const acl = new EthersT.Contract(aclContractAddress, aclABI, readonlyEthersProvider);\n\n    const verifications = handles.map(async (h) => {\n      const ctHandleHex = EthersT.toBeHex(EthersT.toBigInt(h), 32);\n\n      const allowed = await acl.isAllowedForDecryption(ctHandleHex);\n      if (!allowed) {\n        throw new FhevmError(`Handle ${h} is not allowed for public decryption!`);\n      }\n    });\n\n    return Promise.all(verifications).catch((e) => {\n      throw e;\n    });\n  }\n\n  // (Duplicated code) Should be imported from @zama-fhe/relayer-sdk\n  public static async verifyUserACLPermissions(\n    readonlyEthersProvider: EthersT.Provider,\n    aclContractAddress: string,\n    handles: HandleContractPair[],\n    userAddress: string,\n  ) {\n    const aclABI = [\"function persistAllowed(bytes32 handle, address account) view returns (bool)\"];\n    const acl = new EthersT.Contract(aclContractAddress, aclABI, readonlyEthersProvider);\n\n    const verifications = handles.map(async ({ handle, contractAddress }) => {\n      const ctHandleHex = EthersT.toBeHex(EthersT.toBigInt(handle), 32);\n\n      const userAllowed = await acl.persistAllowed(ctHandleHex, userAddress);\n      const contractAllowed = await acl.persistAllowed(ctHandleHex, contractAddress);\n      if (!userAllowed) {\n        throw new FhevmError(`User ${userAddress} is not authorized to user decrypt handle ${handle}!`);\n      }\n      if (!contractAllowed) {\n        throw new FhevmError(`dapp contract ${contractAddress} is not authorized to user decrypt handle ${handle}!`);\n      }\n      if (userAddress === contractAddress) {\n        throw new FhevmError(\n          `userAddress ${userAddress} should not be equal to contractAddress when requesting decryption!`,\n        );\n      }\n    });\n\n    return Promise.all(verifications).catch((e) => {\n      throw e;\n    });\n  }\n\n  public static verifyHandleContractAddresses(handles: HandleContractPair[], contractAddresses: string[]) {\n    const set = new Set<string>();\n    // Build a list of unique allowed contact addresses.\n    for (let i = 0; i < contractAddresses.length; ++i) {\n      const add = contractAddresses[i].toLowerCase();\n      if (!set.has(add)) {\n        set.add(add);\n      }\n    }\n    // Check that every handle contract (in HandleContractPair) is actually listed in the contractAddresses argument.\n    for (let i = 0; i < handles.length; ++i) {\n      if (!set.has(handles[i].contractAddress.toLowerCase())) {\n        throw new FhevmError(\n          `Contract address ${handles[i].contractAddress} associated to handle ${handles[i].handle} is not listed in the contractAddresses array argument.`,\n        );\n      }\n    }\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport constants from \"../constants.js\";\nimport type { DecryptedResults, FhevmInstance, HandleContractPair } from \"../relayer-sdk/types.js\";\nimport { assertIsAddress } from \"../utils/address.js\";\nimport { FhevmError } from \"../utils/error.js\";\nimport { verifyKeypair } from \"../utils/keypair.js\";\nimport { toUIntNumber } from \"../utils/math.js\";\nimport { timestampNow } from \"../utils/time.js\";\nimport { FhevmHandle } from \"./FhevmHandle.js\";\nimport type { FhevmType } from \"./FhevmType.js\";\n\nexport type FhevmKeypair = {\n  publicKey: string;\n  privateKey: string;\n};\n\n/**\n * Represents a time-bound validity constraint for a user decryption request.\n *\n * This structure defines a window of time during which a user decryption\n * request is considered valid. It is typically used to ensure that the request\n * cannot be reused or replayed outside of the authorized interval.\n *\n * - `startTimestamp` defines the beginning of the validity window, as a Unix\n *   timestamp in seconds (POSIX time).\n * - `durationDays` defines how long the validity window remains open, measured\n *   in full calendar days.\n *\n * @example\n * const validity: FhevmUserDecryptValidity = {\n *   startTimestamp: Math.floor(Date.now() / 1000), // current time in seconds (POSIX time)\n *   durationDays: 7, // valid for one week\n * };\n */\nexport type FhevmUserDecryptValidity = {\n  /** Start time in seconds since Unix epoch (POSIX time). */\n  startTimestamp: EthersT.Numeric;\n\n  /** Duration in days. */\n  durationDays: EthersT.Numeric;\n};\n\nexport type FhevmUserDecryptOptions = {\n  instance?: FhevmInstance;\n  keypair?: FhevmKeypair;\n  validity?: FhevmUserDecryptValidity;\n};\n\nexport type FhevmPublicDecryptOptions = {\n  instance?: FhevmInstance;\n};\n\nexport async function userDecryptHandleBytes32(\n  instance: FhevmInstance,\n  handleContractPairs: { handleBytes32: string; contractAddress: string; fhevmType?: FhevmType }[],\n  user: EthersT.Signer,\n  options?: Omit<FhevmUserDecryptOptions, \"instance\">,\n): Promise<DecryptedResults> {\n  // Verify that contract addresses are well formed.\n  _assertIsContractAddressesArray(handleContractPairs);\n\n  // Resolve missing options (instance, keypair etc.)\n  const userDecryptArgs = await _resolveUserDecryptOptions(instance, options);\n\n  // extract chainId from instance (FhevmInstance is missing getChainId function)\n  const chainId = _getFhevmInstanceChainId(instance);\n\n  // Verify Fhevm handles\n  _verifyFhevmHandleContractPairs(handleContractPairs, chainId);\n\n  // Compute signature and list of contract addresses extracted and sorted from the handle/contract pairs\n  const { signature, contractAddresses } = await _computeUserSignatureAndContractAddresses(\n    instance,\n    handleContractPairs,\n    user,\n    userDecryptArgs,\n  );\n\n  // Prepare final arguments:\n  // - user address\n  // - array of CtHandleContractPair\n\n  const userAddress = await user.getAddress();\n\n  const handles: HandleContractPair[] = handleContractPairs.map((p) => {\n    return { handle: p.handleBytes32, contractAddress: p.contractAddress };\n  });\n\n  // Call FhevmInstance userDecrypt\n  const decryptedHandles: DecryptedResults = await instance.userDecrypt(\n    handles,\n    userDecryptArgs.keypair.privateKey,\n    userDecryptArgs.keypair.publicKey,\n    signature,\n    contractAddresses,\n    userAddress,\n    userDecryptArgs.startTimestamp,\n    userDecryptArgs.durationDays,\n  );\n\n  return decryptedHandles;\n}\n\ntype FhevmUserDecryptArguments = {\n  keypair: FhevmKeypair;\n  startTimestamp: number;\n  durationDays: number;\n};\n\n/**\n * - Creates a new FhevmInstance if needed.\n * - Generates a new FhevmKeypair or checks a given FhevmKeypair passed as argument.\n * - Generates a new FhevmUserDecryptValidity object or checks a given FhevmUserDecryptValidity passed as argument.\n */\nasync function _resolveUserDecryptOptions(\n  instance: FhevmInstance,\n  options?: FhevmUserDecryptOptions,\n): Promise<FhevmUserDecryptArguments> {\n  let keypair: FhevmKeypair;\n\n  if (options?.keypair !== undefined) {\n    keypair = { ...options.keypair };\n    verifyKeypair(keypair);\n  } else {\n    keypair = instance.generateKeypair();\n  }\n\n  const startTimestamp = options?.validity?.startTimestamp || timestampNow();\n  const durationDays = options?.validity?.durationDays || constants.DEFAULT_DURATION_DAYS;\n\n  const startTimestampNumber = toUIntNumber(startTimestamp, \"startTimeStamp\");\n  const durationDaysNumber = toUIntNumber(durationDays, \"durationDays\");\n\n  return {\n    keypair,\n    startTimestamp: startTimestampNumber,\n    durationDays: durationDaysNumber,\n  };\n}\n\nasync function _computeUserSignatureAndContractAddresses(\n  instance: FhevmInstance,\n  contractAddresses: ({ contractAddress: string } | string)[],\n  user: EthersT.Signer,\n  userDecryptArgs: FhevmUserDecryptArguments,\n) {\n  if (contractAddresses.length === 0) {\n    throw new FhevmError(\"Empty list of contract addresses.\");\n  }\n\n  // We use a deterministic method for convenience. (in case we need to rebuild the signature).\n  const contractAddressesSortUnique = _buildDeterministicContractAddressesList(contractAddresses);\n\n  if (contractAddressesSortUnique.length === 0) {\n    throw new FhevmError(\"Empty list of valid contract addresses.\");\n  }\n\n  const eip712 = instance.createEIP712(\n    userDecryptArgs.keypair.publicKey,\n    contractAddressesSortUnique,\n    userDecryptArgs.startTimestamp,\n    userDecryptArgs.durationDays,\n  );\n\n  const signature = await user.signTypedData(\n    eip712.domain,\n    { UserDecryptRequestVerification: eip712.types.UserDecryptRequestVerification },\n    eip712.message,\n  );\n\n  return {\n    signature,\n    contractAddresses: contractAddressesSortUnique,\n  };\n}\n\nfunction _getFhevmInstanceChainId(instance: FhevmInstance): number {\n  const dummyEIP712 = instance.createEIP712(\"\", [EthersT.ZeroAddress], 0, 0);\n  return dummyEIP712.message.contractsChainId;\n}\n\nfunction _buildDeterministicContractAddressesList(\n  contractAddresses: ({ contractAddress: string } | string)[],\n): string[] {\n  const set = new Set<string>();\n\n  // Build a list of unique allowed contact addresses.\n  for (let i = 0; i < contractAddresses.length; ++i) {\n    const ca = contractAddresses[i];\n    let contractAddress: string;\n    if (typeof ca === \"string\") {\n      contractAddress = ca;\n    } else {\n      contractAddress = ca.contractAddress;\n    }\n    const add = EthersT.getAddress(contractAddress);\n    if (!set.has(add)) {\n      set.add(add);\n    }\n  }\n\n  // Sort by alphabetical order, user lowercase comparison\n  return [...set].sort((a, b) => {\n    const addrA = a.toLowerCase(); // ignore upper and lowercase\n    const addrB = b.toLowerCase(); // ignore upper and lowercase\n    if (addrA < addrB) {\n      return -1;\n    }\n    if (addrA > addrB) {\n      return 1;\n    }\n    return 0;\n  });\n}\n\nfunction _assertIsContractAddressesArray(contractAddresses: ({ contractAddress: string } | string)[]) {\n  if (contractAddresses.length === 0) {\n    throw new FhevmError(\"Empty list of contract addresses.\");\n  }\n\n  for (let i = 0; i < contractAddresses.length; ++i) {\n    const ca = contractAddresses[i];\n\n    let contractAddress: string;\n    if (typeof ca === \"string\") {\n      contractAddress = ca;\n    } else {\n      contractAddress = ca.contractAddress;\n    }\n    assertIsAddress(contractAddress, \"contractAddress\");\n  }\n}\n\nfunction _verifyFhevmHandleContractPairs(\n  handleContractPairs: { handleBytes32: string; contractAddress: string; fhevmType?: FhevmType }[],\n  chainId?: number,\n) {\n  if (handleContractPairs.length === 0) {\n    throw new FhevmError(\"Empty list of handle/contract pairs.\");\n  }\n\n  for (let i = 0; i < handleContractPairs.length; ++i) {\n    const pair = handleContractPairs[i];\n\n    FhevmHandle.verify(pair.handleBytes32, {\n      ...(pair.fhevmType !== undefined && { fhevmType: pair.fhevmType }),\n      ...(chainId !== undefined && { chainId: chainId }),\n    });\n\n    assertIsAddress(pair.contractAddress, \"contractAddress\");\n  }\n}\n", "import { ethers as EthersT } from \"ethers\";\n\nimport { assertIsAddress } from \"../utils/address.js\";\nimport { assertIsBytes32String } from \"../utils/bytes.js\";\nimport { FhevmError, assertFhevm } from \"../utils/error.js\";\nimport { type MinimalProvider, minimalProviderSend } from \"./provider.js\";\n\n/*\n  /// keccak256(abi.encode(uint256(keccak256(\"fhevm.storage.FHEVMConfig\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\n\n  /// keccak256(abi.encode(uint256(keccak256(\"fhevm.storage.DecryptionRequests\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant DecryptionRequestsStorageLocation =\n      0x5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d00;\n*/\nexport function computeStorageLocation(storageName: string): string {\n  const enc = EthersT.AbiCoder.defaultAbiCoder().encode(\n    [\"uint256\"],\n    [BigInt(EthersT.keccak256(EthersT.toUtf8Bytes(storageName))) - 1n],\n  );\n  return EthersT.toBeHex(\n    BigInt(EthersT.keccak256(enc)) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00n,\n    32,\n  );\n}\n\n/**\n * Reads a raw storage slot value from a smart contract using the `eth_getStorageAt` JSON-RPC method.\n *\n * This function queries the storage at a specific `index` for the given contract `address`,\n * using the `latest` block tag. The result is returned as a 32-byte hex string.\n *\n * @param provider - An EIP-1193-compatible provider used to send the RPC request.\n * @param address - The Ethereum address of the contract to read storage from.\n * @param index - The storage slot index (as a bigint) to query.\n * @returns A 32-byte hex string representing the raw storage value at the given slot.\n *\n * @throws If the provided address is invalid or if the RPC call fails or if the return value is not a valid 32-byte hex string.\n */\nexport async function getStorageAt(provider: MinimalProvider, address: string, index: bigint): Promise<string> {\n  assertIsAddress(address);\n  const indexParam = EthersT.toBeHex(index, 32);\n\n  const data = await minimalProviderSend(provider, \"eth_getStorageAt\", [address, indexParam, \"latest\"]);\n\n  assertIsBytes32String(data);\n\n  return data;\n}\n\nexport async function setStorageAt(\n  provider: MinimalProvider,\n  methodName: string,\n  address: string,\n  index: bigint,\n  valueBytes32: string,\n) {\n  assertIsAddress(address);\n  assertIsBytes32String(valueBytes32);\n\n  if (methodName !== \"hardhat_setStorageAt\") {\n    throw new FhevmError(`Only hardhat_setStorageAt is supported. Got ${methodName} instead.`);\n  }\n\n  const indexParam = EthersT.toBeHex(index, 32);\n\n  await minimalProviderSend(provider, methodName, [address, indexParam, valueBytes32]);\n}\n\n/**\n * Reads a fixed number of consecutive addresses stored at a given storage location.\n *\n * @param provider - A `MinimalProvider` that supports either `send` or `request` for RPC interaction.\n * @param contractAddress - The Ethereum address of the contract to read storage from.\n * @param storageLocationBytes32 - The storage slot index as a 32-byte hex string.\n * @param numAddresses - The number of addresses to read.\n * @returns An array of addresses.\n *\n * @throws If the provided address is invalid or if the RPC call fails or if the storage slot does not contain the expected addresses.\n */\nexport async function getAddressesFromStorage(\n  provider: MinimalProvider,\n  contractAddress: string,\n  storageLocationBytes32: string,\n  numAddresses: number,\n): Promise<string[]> {\n  const addresses: string[] = [];\n  for (let i = 0; i < numAddresses; ++i) {\n    const addr = await getStorageAt(provider, contractAddress, BigInt(storageLocationBytes32) + BigInt(i));\n    addresses.push(addr);\n  }\n\n  const errorMsg = `The contract at address ${contractAddress} has not been initialized properly.`;\n\n  for (let i = 0; i < numAddresses; ++i) {\n    const addr = addresses[i];\n    if (typeof addr !== \"string\" || !EthersT.isBytesLike(addr) || addr.length !== 66) {\n      throw new FhevmError(errorMsg);\n    }\n\n    const hex = EthersT.toBeHex(BigInt(addr), 20);\n    try {\n      addresses[i] = EthersT.getAddress(hex);\n    } catch {\n      throw new FhevmError(errorMsg);\n    }\n  }\n\n  return addresses;\n}\n\nexport async function getInitializableStorage(\n  provider: MinimalProvider,\n  contractAddress: string,\n): Promise<{ initialized: bigint; initializing: boolean }> {\n  const storageLocationBytes32 = computeStorageLocation(\"openzeppelin.storage.Initializable\");\n  assertFhevm(\n    storageLocationBytes32 === \"0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00\",\n    \"Wrong 'openzeppelin.storage.Initializable' storage location\",\n  );\n\n  // One single 32 bytes slot with data packed in reverse order\n  // 0x0000000000000000000000000000000000000000000000_01_0000000000000005\n  //                                                 bool      uint64\n  let data = await getStorageAt(provider, contractAddress, BigInt(storageLocationBytes32) + BigInt(0));\n  data = data.replace(/^0x/, \"\").padStart(64, \"0\");\n\n  // _initialized (uint64): first 8 bytes\n  const initializedHex = \"0x\" + data.slice(-16); // 8 bytes = 16 hex chars\n  const initialized = BigInt(initializedHex);\n\n  // _initializing (bool): next byte (9th byte)\n  const initializingByte = parseInt(data.slice(-18, -16), 16);\n  const initializing = initializingByte !== 0;\n\n  return { initialized, initializing };\n}\n\nexport async function setInitializableStorage(\n  provider: MinimalProvider,\n  contractAddress: string,\n  value: { initialized: bigint; initializing: boolean },\n) {\n  //\n  // @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\n  // struct InitializableStorage {\n  //     /**\n  //      * @dev Indicates that the contract has been initialized.\n  //      */\n  //     uint64 _initialized;\n  //     /**\n  //      * @dev Indicates that the contract is in the process of being initialized.\n  //      */\n  //     bool _initializing;\n  // }\n  //\n  // // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n  // bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n  //\n  const storageLocationBytes32 = computeStorageLocation(\"openzeppelin.storage.Initializable\");\n  assertFhevm(\n    storageLocationBytes32 === \"0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00\",\n    \"Wrong 'openzeppelin.storage.Initializable' storage location\",\n  );\n\n  // Encode uint64 _initialized\n  const initializedBytes = EthersT.toBeHex(value.initialized, 8); // 8 bytes\n  // Encode bool _initializing (1 byte)\n  const initializingByte = value.initializing ? \"0x01\" : \"0x00\";\n\n  const packedHex = initializingByte + initializedBytes.slice(2); // drop '0x' from bool byte\n  const paddedSlotValue = EthersT.zeroPadValue(packedHex, 32); // full 32-byte slot\n\n  await setStorageAt(\n    provider,\n    \"hardhat_setStorageAt\",\n    contractAddress,\n    BigInt(storageLocationBytes32) + BigInt(0),\n    paddedSlotValue,\n  );\n}\n\nexport async function setOwnableStorage(provider: MinimalProvider, contractAddress: string, ownerAddress: string) {\n  //\n  // abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n  //   /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n  //   struct OwnableStorage {\n  //       address _owner;\n  //   }\n  //   ...\n  // }\n  //\n  // // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n  // bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n  //\n  const storageLocationBytes32 = computeStorageLocation(\"openzeppelin.storage.Ownable\");\n  assertFhevm(\n    storageLocationBytes32 === \"0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300\",\n    \"Wrong 'openzeppelin.storage.Ownable' storage location\",\n  );\n\n  const paddedSlotValue = EthersT.zeroPadValue(ownerAddress, 32); // full 32-byte slot\n\n  await setStorageAt(\n    provider,\n    \"hardhat_setStorageAt\",\n    contractAddress,\n    BigInt(storageLocationBytes32) + BigInt(0),\n    paddedSlotValue,\n  );\n}\n", "import type { MinimalProvider } from \"../ethers/provider.js\";\nimport { computeStorageLocation, getAddressesFromStorage } from \"../ethers/storage.js\";\nimport { assertFhevm } from \"../utils/error.js\";\n\n/**\n * Maps the Solidity struct `CoprocessorConfig` struct defined in\n * [`@fhevm/solidity/lib/Impl.sol`](https://github.com/zama-ai/fhevm-solidity/blob/main/lib/Impl.sol)\n * This struct contains all addresses of the FHEVM Coprocessor contracts, which are required in by a FHEVM dApp.\n */\nexport type CoprocessorConfig = {\n  /**\n   * Address of the deployed\n   * [`ACL.sol`](https://github.com/zama-ai/fhevm-backend/blob/main/contracts/contracts/ACL.sol)\n   * contract from `@fhevm/core-contracts`.\n   */\n  ACLAddress: string;\n  /**\n   * Address of the deployed\n   * [`FHEVMExecutor.sol`](https://github.com/zama-ai/fhevm-backend/blob/main/contracts/contracts/FHEVMExecutor.sol)\n   * contract from `@fhevm/core-contracts`.\n   */\n  CoprocessorAddress: string;\n  /**\n   * Address of the deployed\n   * [`InputVerifier.sol`](https://github.com/zama-ai/fhevm-backend/blob/main/contracts/contracts/InputVerifier.sol)\n   * contract from `@fhevm/core-contracts`.\n   */\n  DecryptionOracleAddress: string;\n  /**\n   * Address of the deployed\n   * [`KMSVerifier.sol`](https://github.com/zama-ai/fhevm-backend/blob/main/contracts/contracts/KMSVerifier.sol)\n   * contract from `@fhevm/core-contracts`.\n   */\n  KMSVerifierAddress: string;\n};\n\n/**\n * Retrieves the `CoprocessorConfig` struct from a smart contract that utilizes the FHEVM framework,\n * deployed at the given `contractAddress`.\n *\n * This function computes the storage slot corresponding to the `CoprocessorConfig` defined in\n * [`@fhevm/solidity/lib/Impl.sol`](https://github.com/zama-ai/fhevm-solidity/blob/main/lib/Impl.sol),\n * then reads the four consecutive addresses fields directly from storage.\n *\n * @param provider - A `MinimalProvider` that implements either `send` or `request` for JSON-RPC communication.\n * @param contractAddress - The on-chain address of the FHEVM contract to query.\n * @returns A Promise that resolves to the `CoprocessorConfig`.\n *\n * @throws If the computed storage slot does not match the expected constant layout, indicating a version or layout mismatch.\n */\nexport async function getCoprocessorConfig(\n  provider: MinimalProvider,\n  contractAddress: string,\n): Promise<CoprocessorConfig> {\n  const coprocessorConfigStorageLocation = computeStorageLocation(\"confidential.storage.config\");\n  assertFhevm(\n    coprocessorConfigStorageLocation === \"0x9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700\",\n  );\n\n  /*\n    See: @fhevm/solidity/config/ZamaConfig.sol and @fhevm/solidity/lib/Impl.sol\n    \n    struct CoprocessorConfig {\n      address ACLAddress;\n      address CoprocessorAddress;\n      address DecryptionOracleAddress;\n      address KMSVerifierAddress;\n    }\n  */\n  const addresses: string[] = await getAddressesFromStorage(\n    provider,\n    contractAddress,\n    coprocessorConfigStorageLocation,\n    4 /* number of addresses in the struct */,\n  );\n\n  return {\n    ACLAddress: addresses[0],\n    CoprocessorAddress: addresses[1],\n    DecryptionOracleAddress: addresses[2],\n    KMSVerifierAddress: addresses[3],\n  };\n}\n", "export const version: string = \"0.1.0\";\n"],
  "mappings": "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A,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACF,GArFY,YAAA,UAAO,CAAA,EAAA;AAgHZ,IAAM,gBAA+B;EAC1C;IACE,MAAM;IACN,OAAO;IACP,oBAAoB,CAAC,OAAO,MAAM,OAAO,MAAM,MAAM,OAAO,UAAU,MAAM;IAC5E,WAAW;IACX,mBAAmB;;EAErB;IACE,MAAM;IACN,OAAO;IACP,oBAAoB,CAAA;IACpB,WAAW;IACX,mBAAmB;;EAErB;IACE,MAAM;IACN,OAAO;IACP,oBAAoB;MAClB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;IAEF,WAAW;IACX,mBAAmB;IACnB,SAAS;MACP;QACE,MAAM;QACN,oBAAoB,CAAA;QACpB,mBAAmB;;;;EAIzB;IACE,MAAM;IACN,OAAO;IACP,oBAAoB;MAClB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;IAEF,WAAW;IACX,mBAAmB;IACnB,SAAS;MACP;QACE,MAAM;QACN,oBAAoB,CAAA;QACpB,mBAAmB;;;;EAIzB;IACE,MAAM;IACN,OAAO;IACP,oBAAoB;MAClB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;IAEF,WAAW;IACX,mBAAmB;IACnB,SAAS;MACP;QACE,MAAM;QACN,oBAAoB,CAAA;QACpB,mBAAmB;;;;EAIzB;IACE,MAAM;IACN,OAAO;IACP,oBAAoB;MAClB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;IAEF,WAAW;IACX,mBAAmB;IACnB,SAAS;MACP;QACE,MAAM;QACN,oBAAoB,CAAA;QACpB,mBAAmB;;;;EAIzB;IACE,MAAM;IACN,OAAO;IACP,oBAAoB;MAClB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;IAEF,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AAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,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ACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;CAET;;;;;;;;;;;;;;;;;;AChnCK,IAAO,WAAP,MAAO,kBAAiB,gCAA+B;EAM3D,cAAA;AACE,UAAM,UAAU;AANlB,+BAAA,IAAA,MAAA,MAAA;AACA,sCAAA,IAAA,MAAA,MAAA;AACA,kCAAA,IAAA,MAAA,MAAA;AACA,sBAAA,IAAA,MAAA,MAAA;EAIA;EAEO,aAAa,OAClB,QACA,yBACA,KACA,YAA+B;AAE/B,oBAAgB,yBAAyB,yBAAyB;AAElE,QAAI,eAAe,QAAW;AAC5B,YAAM,IAAI,WAAW,qBAAqB;IAC5C;AAEA,UAAM,WAAW,IAAI,UAAQ;AAC7B,IAAAC,wBAAA,UAAQ,mCAA4B,yBAAuB,GAAA;AAC3D,IAAAA,wBAAA,UAAQ,4BAAqB,IAAI,eAAQ,SAAS,yBAAyB,OAAO,0BAA0B,MAAM,GAAC,GAAA;AACnH,UAAM,SAAS,YAAW;AAC1B,WAAO;EACT;EAEA,IAAoB,mBAAgB;AAClC,gBAAYC,wBAAA,MAAI,4BAAA,GAAA,MAAuB,QAAW,yCAAyC;AAC3F,WAAOA,wBAAA,MAAI,4BAAA,GAAA;EACb;EAEA,IAAoB,YAAS;AAC3B,gBAAYA,wBAAA,MAAI,4BAAA,GAAA,MAAuB,QAAW,yCAAyC;AAC3F,WAAOA,wBAAA,MAAI,4BAAA,GAAA,EAAmB;EAChC;EAEA,IAAW,UAAO;AAChB,gBAAYA,wBAAA,MAAI,mCAAA,GAAA,MAA8B,QAAW,yCAAyC;AAClG,WAAOA,wBAAA,MAAI,mCAAA,GAAA;EACb;EAEA,IAAW,UAAO;AAChB,gBAAYA,wBAAA,MAAI,mBAAA,GAAA,MAAc,QAAW,yCAAyC;AAClF,WAAOA,wBAAA,MAAI,mBAAA,GAAA;EACb;EAEA,IAAW,sBAAmB;AAC5B,gBAAYA,wBAAA,MAAI,+BAAA,GAAA,MAA0B,QAAW,yCAAyC;AAC9F,WAAOA,wBAAA,MAAI,+BAAA,GAAA;EACb;EAEQ,MAAM,cAAW;AACvB,gBAAYA,wBAAA,MAAI,4BAAA,GAAA,MAAuB,QAAW,yCAAyC;AAC3F,gBAAYA,wBAAA,MAAI,+BAAA,GAAA,MAA0B,QAAW,sCAAsC;AAE3F,IAAAD,wBAAA,MAAI,+BAAwB,MAAMC,wBAAA,MAAI,4BAAA,GAAA,EAAmB,wBAAuB,GAAE,GAAA;AAClF,oBAAgBA,wBAAA,MAAI,+BAAA,GAAA,GAAuB,qBAAqB;AAEhE,IAAAD,wBAAA,MAAI,mBAAY,MAAMC,wBAAA,MAAI,4BAAA,GAAA,EAAmB,WAAU,GAAE,GAAA;AACzD,mBAAeA,wBAAA,MAAI,mBAAA,GAAA,GAAW,SAAS;EACzC;;;;;ACxDF,eAAsB,WACpB,QACA,QACA,OACA,SAAgC;AAEhC,QAAM,YAAY,MAAM,OAAO,cAAc,QAAQ,OAAO,OAAO;AACnE,QAAM,SAAS,eAAQ,UAAU,KAAK,SAAS;AAC/C,QAAM,IAAI,KAAK,OAAO;AACtB,QAAM,IAAI,OAAO;AACjB,QAAM,IAAI,OAAO;AAEjB,QAAM,SAAS,IAAI,aAAa,GAAG,IAAI,IAAI,EAAE,SAAS,EAAE;AACxD,SAAO;AACT;AAEA,eAAsB,gBACpB,SACA,QACA,OACA,SAAgC;AAEhC,QAAM,aAAuB,CAAA;AAC7B,WAAS,MAAM,GAAG,MAAM,QAAQ,QAAQ,OAAO;AAC7C,UAAM,SAAS,QAAQ,GAAG;AAC1B,UAAM,YAAY,MAAM,WAAW,QAAS,QAAQ,OAAO,OAAO;AAClE,eAAW,KAAK,SAAS;EAC3B;AACA,SAAO;AACT;AAEM,SAAU,qBACd,cACA,MACA,gBAA6F;AAE7F,cAAY,MAAM,QAAQ,YAAY,GAAG,WAAW,IAAI,gBAAgB;AACxE,cAAY,aAAa,UAAU,GAAG,WAAW,IAAI,gBAAgB;AACrE,cACE,aAAa,CAAC,MAAM,eAAe,MACnC,WAAW,IAAI,4BAA4B,aAAa,CAAC,CAAC,cAAc,eAAe,IAAI,EAAE;AAE/F,cACE,aAAa,CAAC,MAAM,eAAe,SACnC,WAAW,IAAI,4BAA4B,aAAa,CAAC,CAAC,cAAc,eAAe,OAAO,EAAE;AAElG,cACE,aAAa,CAAC,MAAM,eAAe,SACnC,WAAW,IAAI,4BAA4B,aAAa,CAAC,CAAC,cAAc,eAAe,OAAO,EAAE;AAElG,cACE,aAAa,CAAC,MAAM,eAAe,mBACnC,WAAW,IAAI,4BAA4B,aAAa,CAAC,CAAC,cAAc,eAAe,iBAAiB,EAAE;AAE9G;AAEM,SAAU,mBACd,gBACA,oBACA,WACA,YAAkB;AAElB,QAAM,aAAa,oBAAI,IAAG;AAC1B,qBAAmB,QAAQ,CAAC,SAAS,UAAS;AAC5C,QAAI,WAAW,IAAI,OAAO,GAAG;AAC3B,YAAM,iBAAiB;AACvB,YAAM,IAAI,WACR,aAAa,UAAU,0BAA0B,cAAc,gDAAgD;IAEnH;AACA,eAAW,IAAI,SAAS,KAAK;EAC/B,CAAC;AAED,aAAW,WAAW,oBAAoB;AACxC,QAAI,CAAC,eAAe,SAAS,OAAO,GAAG;AACrC,YAAM,IAAI,WAAW,0BAA0B,OAAO,0BAA0B,UAAU,UAAU;IACtG;EACF;AAEA,SAAO,mBAAmB,UAAU;AACtC;;;AC/FM,SAAU,mBAAmB,OAAgB,WAAkB;AACnE,cAAY,iBAAiB,YAAY,GAAG,aAAa,OAAO,4BAA4B;AAC9F;AASM,SAAU,sBAAsB,OAAgB,WAAkB;AACtE,sBAAoB,OAAO,IAAI,SAAS;AAC1C;AAEM,SAAU,oBAAoB,OAAgB,OAAgB,WAAkB;AACpF,iBAAe,OAAO,SAAS;AAC/B,MAAI,UAAU,QAAW;AACvB,gBAAY,eAAQ,YAAY,KAAK,GAAG,GAAG,aAAa,OAAO,MAAM,KAAK,8BAA8B;EAC1G,OAAO;AACL,gBACE,UAAU,eAAQ,QAAQ,OAAO,KAAK,GACtC,GAAG,aAAa,OAAO,MAAM,KAAK,wBAAwB,KAAK,SAAS;EAE5E;AACF;AAEM,SAAU,eAAe,OAAgB,WAAkB;AAC/D,gBAAc,OAAO,GAAG,SAAS;AACnC;AAIM,SAAU,gBAAgB,OAAgB,WAAkB;AAChE,gBAAc,OAAO,IAAI,SAAS;AACpC;AACM,SAAU,gBAAgB,OAAgB,WAAkB;AAChE,gBAAc,OAAO,IAAI,SAAS;AACpC;AAEM,SAAU,cAAc,OAAgB,OAAgB,WAAkB;AAC9E,qBAAmB,OAAO,SAAS;AACnC,MAAI,UAAU,QAAW;AACvB,gBAAY,eAAQ,YAAY,KAAK,GAAG,GAAG,aAAa,OAAO,MAAM,KAAK,8BAA8B;EAC1G,OAAO;AACL,gBACE,MAAM,WAAW,OACjB,GAAG,aAAa,OAAO,MAAM,KAAK,wBAAwB,KAAK,iCAAiC,KAAK,SAAS,MAAM,MAAM,UAAU;EAExI;AACF;AAwBM,SAAU,YAAY,OAA6B,OAAa;AAEpE,SAAO,eAAQ,SAAS,eAAQ,QAAQ,OAAO,KAAK,CAAC;AACvD;AAEM,SAAU,eAAe,QAAoB;AACjD,QAAM,cAAc,OAAO,OAAO,CAAC,KAAK,QAAQ,MAAM,IAAI,QAAQ,CAAC;AACnE,QAAM,SAAS,IAAI,WAAW,WAAW;AACzC,MAAI,SAAS;AAEb,aAAW,OAAO,QAAQ;AACxB,WAAO,IAAI,KAAK,MAAM;AACtB,cAAU,IAAI;EAChB;AAEA,SAAO;AACT;;;ACnFM,SAAU,oBAAoB,KAAW;AAC7C,QAAM,MAAM,IAAI,SAAS,EAAE;AAC3B,SAAO,IAAI,SAAS,IAAI,MAAM,MAAM;AACtC;AAeO,IAAM,gBAAgB,CAAC,cAAiC;AAC7D,QAAM,MAAM,UAAU,QAAQ,SAAS,EAAE,EAAE,MAAM,SAAS;AAC1D,MAAI,CAAC;AAAK,WAAO,IAAI,WAAU;AAC/B,SAAO,WAAW,KAAK,IAAI,IAAI,CAAC,SAAS,SAAS,MAAM,EAAE,CAAC,CAAC;AAC9D;AAGO,IAAM,cAAc,CAAC,UAC1B,KAAK,MAAM,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,GAAG,EAAE,CAAC;AAE1E,SAAU,kBAAkB,OAAgB,WAAkB;AAClE,iBAAe,OAAO,SAAS;AAC/B,cAAY,eAAQ,YAAY,KAAK,GAAG,GAAG,aAAa,OAAO,KAAK,KAAK,6BAA6B;AACxG;;;ACtCO,IAAM,gCAAmD,IAAI,eAAQ,UAAU;EACpF;IACE,QAAQ,CAAA;IACR,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,YAAY;UACV;YACE,cAAc;YACd,MAAM;YACN,MAAM;;UAER;YACE,cAAc;YACd,MAAM;YACN,MAAM;;;QAGV,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;CAET;;;;;;;;;;;;;;;;;;;AC7nBK,IAAO,gBAAP,MAAO,uBAAsB,gCAA+B;EAOhE,cAAA;AACE,UAAM,eAAe;AAPvB,iDAAA,IAAA,MAAA,MAAA;AACA,gDAAA,IAAA,MAAA,MAAA;AACA,oCAAA,IAAA,MAAA,MAAA;AACA,6BAAA,IAAA,MAAA,MAAA;AACA,gCAAA,IAAA,MAAA,MAAA;EAIA;EAEO,aAAa,OAClB,QACA,8BACA,KACA,YAAoC;AAEpC,oBAAgB,8BAA8B,8BAA8B;AAE5E,UAAM,gBAAgB,IAAI,eAAa;AACvC,IAAAC,wBAAA,eAAa,6CAAiC,8BAA4B,GAAA;AAC1E,IAAAA,wBAAA,eAAa,8CAAkC,IAAI,eAAQ,SACzD,8BACA,OAAO,+BACP,MAAM,GACP,GAAA;AACD,IAAAA,wBAAA,eAAa,6BAAiB,yCAAY,cAAY,GAAA;AACtD,IAAAA,wBAAA,eAAa,iCAAqB,yCAAY,kBAAgB,GAAA;AAC9D,IAAAA,wBAAA,eAAa,0BAAc,yCAAY,WAAS,GAAA;AAEhD,UAAM,cAAc,YAAW;AAC/B,WAAO;EACT;EAEA,IAAoB,mBAAgB;AAClC,gBAAYC,wBAAA,MAAI,8CAAA,GAAA,MAAoC,QAAW,0CAA0C;AACzG,WAAOA,wBAAA,MAAI,8CAAA,GAAA;EACb;EAEA,IAAoB,YAAS;AAC3B,gBAAYA,wBAAA,MAAI,8CAAA,GAAA,MAAoC,QAAW,8CAA8C;AAC7G,WAAOA,wBAAA,MAAI,8CAAA,GAAA,EAAgC;EAC7C;EAEQ,MAAM,cAAW;AACvB,gBAAYA,wBAAA,MAAI,8CAAA,GAAA,MAAoC,QAAW,0CAA0C;AAEzG,QAAI,CAACA,wBAAA,MAAI,iCAAA,GAAA,GAAoB;AAC3B,YAAM,UAAU,MAAMA,wBAAA,MAAI,8CAAA,GAAA,EAAgC,sBAAqB;AAC/E,MAAAD,wBAAA,MAAI,iCAAqB,SAAO,GAAA;IAClC;AACA,yBAAqBC,wBAAA,MAAI,iCAAA,GAAA,CAAkB;AAE3C,QAAIA,wBAAA,MAAI,0BAAA,GAAA,MAAgB,QAAW;AACjC,YAAM,YAAY,MAAMA,wBAAA,MAAI,8CAAA,GAAA,EAAgC,aAAY;AACxE,uBAAiB,SAAS;AAC1B,MAAAD,wBAAA,MAAI,0BAAc,OAAO,SAAS,GAAC,GAAA;IACrC;AAEA,QAAIC,wBAAA,MAAI,6BAAA,GAAA,MAAmB,QAAW;AAEpC,YAAM,eAAe,MAAMA,wBAAA,MAAI,8CAAA,GAAA,EAAgC,aAAY;AAG3E,kBAAY,aAAa,WAAW,CAAC;AACrC,qBAAe,aAAa,CAAC,GAAG,iBAAiB;AACjD,qBAAe,aAAa,CAAC,GAAG,iBAAiB;AACjD,qBAAe,aAAa,CAAC,GAAG,iBAAiB;AACjD,yBAAmB,aAAa,CAAC,GAAG,iBAAiB;AACrD,sBAAgB,aAAa,CAAC,GAAG,iBAAiB;AAClD,4BAAsB,aAAa,CAAC,GAAG,iBAAiB;AACxD,kBAAY,MAAM,QAAQ,aAAa,CAAC,CAAC,KAAK,aAAa,CAAC,EAAE,WAAW,GAAG,iBAAiB;AAE7F,MAAAD,wBAAA,MAAI,6BAAiB;QACnB,QAAQ,OAAO,OAAO,aAAa,CAAC,CAAC,CAAC;QACtC,MAAM,aAAa,CAAC;QACpB,SAAS,aAAa,CAAC;QACvB,SAAS,aAAa,CAAC;QACvB,mBAAmB,aAAa,CAAC;QACjC,MAAM,aAAa,CAAC;;SAErB,GAAA;IACH;AAGA,gBAAYC,wBAAA,MAAI,6BAAA,GAAA,EAAe,WAAW,OAAO,EAAI,CAAC;AACtD,gBAAYA,wBAAA,MAAI,6BAAA,GAAA,EAAe,SAAS,eAAQ,QAAQ;AACxD,gBAAYA,wBAAA,MAAI,6BAAA,GAAA,EAAe,SAAS,kBAAU,0BAA0B,OAAO,IAAI;AACvF,gBAAYA,wBAAA,MAAI,6BAAA,GAAA,EAAe,YAAY,kBAAU,0BAA0B,OAAO,OAAO;EAC/F;EAEA,IAAW,UAAO;AAChB,gBAAYA,wBAAA,MAAI,6CAAA,GAAA,MAAmC,QAAW,uCAAuC;AACrG,WAAOA,wBAAA,MAAI,6CAAA,GAAA;EACb;;EAGA,IAAW,iBAAc;AACvB,gBAAYA,wBAAA,MAAI,6BAAA,GAAA,MAAmB,QAAW,uCAAuC;AACrF,WAAOA,wBAAA,MAAI,6BAAA,GAAA,EAAe;EAC5B;;;EAIA,IAAW,kCAA+B;AACxC,gBAAYA,wBAAA,MAAI,6BAAA,GAAA,MAAmB,QAAW,uCAAuC;AACrF,WAAOA,wBAAA,MAAI,6BAAA,GAAA,EAAe;EAC5B;EAEA,IAAW,eAAY;AACrB,gBAAYA,wBAAA,MAAI,6BAAA,GAAA,MAAmB,QAAW,uCAAuC;AACrF,WAAOA,wBAAA,MAAI,6BAAA,GAAA;EACb;EAEO,wBAAqB;AAC1B,gBAAYA,wBAAA,MAAI,iCAAA,GAAA,MAAuB,QAAW,uCAAuC;AACzF,WAAOA,wBAAA,MAAI,iCAAA,GAAA;EACb;EAEO,eAAY;AACjB,gBAAYA,wBAAA,MAAI,0BAAA,GAAA,MAAgB,QAAW,uCAAuC;AAClF,WAAOA,wBAAA,MAAI,0BAAA,GAAA;EACb;EAEO,MAAM,8BAA8B,SAAyB;AAClE,UAAM,YAAY,KAAK,sBAAqB;AAE5C,kBAAc,SAAS,SAAS;AAChC,gBAAY,QAAQ,WAAW,UAAU,QAAQ,qCAAqC;AAEtF,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,EAAE,GAAG;AACzC,YAAM,IAAI,MAAM,QAAQ,CAAC,EAAE,WAAU;AACrC,kBAAY,UAAU,CAAC,MAAM,GAAG,aAAa,CAAC,uBAAuB,CAAC,gBAAgB;IACxF;EACF;EAEO,iBACL,oBACA,aACA,iBACA,iBACA,WACA,YAAoB;AAEpB,kBAAc,UAAU;AAExB,UAAM,SAAS,KAAK;AAEpB,UAAM,qBAA+B,WAAW,IAAI,CAAC,cAAqB;AACxE,YAAM,MAAM,SAAS,SAAS;AAC9B,YAAM,mBAAmB,eAAQ,gBAC/B;QACE,MAAM,OAAO;QACb,SAAS,OAAO;QAChB,SAAS,OAAO;QAChB,mBAAmB,OAAO;SAE5B,kBAAU,0BAA0B,OACpC;QACE,WAAW;QACX;QACA;QACA;QACA;SAEF,GAAG;AAEL,aAAO;IACT,CAAC;AAED,QAAI,CAAC,mBAAmB,KAAK,sBAAqB,GAAI,oBAAoB,KAAK,aAAY,GAAI,aAAa,GAAG;AAC7G,YAAM,IAAI,WAAW,8CAA8C;IACrE;EACF;;EAGO,mCACL,oBACA,iBACA,iBACA,aACA,WAAiB;AAEjB,oBAAgB,aAAa,aAAa;AAC1C,oBAAgB,iBAAiB,iBAAiB;AAElD,UAAM,SAAS,KAAK;AAEpB,UAAM,SAAuB;MAC3B,QAAQ;QACN,SAAS,OAAO;QAChB,MAAM,OAAO;QACb,SAAS,OAAO;QAChB,mBAAmB,OAAO;;MAE5B,OAAO,kBAAU,0BAA0B;MAC3C,SAAS;QACP,WAAW,mBAAmB,IAAI,CAAC,WAAW,eAAQ,aAAa,eAAQ,QAAQ,MAAM,GAAG,EAAE,CAAC;QAC/F;QACA;QACA;QACA;;;AAIJ,WAAO;EACT;;;AAGI,SAAU,qBACd,mBACA,2BACA,WAAiB;AAEjB,QAAM,aAAa,kBAAkB;AACrC,QAAM,wBAAwB,0BAA0B;AAExD,QAAM,qBAAqB,oBAAoB,UAAU;AACzD,cAAY,mBAAmB,WAAW,CAAC;AAE3C,QAAM,gCAAgC,oBAAoB,qBAAqB;AAC/E,cAAY,8BAA8B,WAAW,CAAC;AAGtD,MAAI,gBAAgB,OAAO,qBAAqB;AAGhD,WAAS,IAAI,GAAG,IAAI,YAAY,EAAE,GAAG;AACnC,UAAM,4BAA4B,aAAa,kBAAkB,CAAC,GAAG,IAAI;AACzE,gBAAY,0BAA0B,WAAW,IAAI,EAAE;AACvD,qBAAiB;EACnB;AAGA,4BAA0B,IAAI,CAAC,iBAAgB;AAC7C,UAAM,8BAA8B,aAAa,cAAc,IAAI;AACnE,QAAI,4BAA4B,WAAW,IAAI,IAAI;AACjD,YAAM,IAAI,WAAW,kCAAkC,2BAA2B,mBAAmB;IACvG;AACA,qBAAiB;EACnB,CAAC;AAGD,kBAAgB,eAAQ,OAAO,CAAC,eAAe,SAAS,CAAC;AAEzD,SAAO;AACT;;;;;;;;;;;;;;;;;;;;;AC1PM,IAAO,cAAP,MAAO,aAAW;EAStB,YACE,QACA,SACA,WACA,SACAC,UACA,UACA,OAAc;AAfhB,wBAAA,IAAA,MAAA,MAAA;AACA,yBAAA,IAAA,MAAA,MAAA;AACA,2BAAA,IAAA,MAAA,MAAA;AACA,yBAAA,IAAA,MAAA,MAAA;AACA,yBAAA,IAAA,MAAA,MAAA;AACA,0BAAA,IAAA,MAAA,MAAA;AACA,uBAAA,IAAA,MAAA,MAAA;AAWE,IAAAC,wBAAA,MAAI,qBAAW,QAAM,GAAA;AACrB,IAAAA,wBAAA,MAAI,sBAAY,SAAO,GAAA;AACvB,IAAAA,wBAAA,MAAI,wBAAc,WAAS,GAAA;AAC3B,IAAAA,wBAAA,MAAI,sBAAY,SAAO,GAAA;AACvB,IAAAA,wBAAA,MAAI,sBAAYD,UAAO,GAAA;AACvB,IAAAC,wBAAA,MAAI,uBAAa,UAAQ,GAAA;AACzB,QAAI,UAAU,QAAW;AACvB,MAAAA,wBAAA,MAAI,oBAAU,OAAK,GAAA;IACrB;EACF;EAEA,IAAW,SAAM;AACf,WAAOC,wBAAA,MAAI,qBAAA,GAAA;EACb;EACA,IAAW,UAAO;AAChB,WAAOA,wBAAA,MAAI,sBAAA,GAAA;EACb;EACA,IAAW,YAAS;AAClB,WAAOA,wBAAA,MAAI,wBAAA,GAAA;EACb;EACA,IAAW,UAAO;AAChB,WAAOA,wBAAA,MAAI,sBAAA,GAAA;EACb;EACA,IAAW,UAAO;AAChB,WAAOA,wBAAA,MAAI,sBAAA,GAAA;EACb;EACA,IAAW,WAAQ;AACjB,WAAOA,wBAAA,MAAI,uBAAA,GAAA;EACb;EACA,IAAW,QAAK;AACd,WAAOA,wBAAA,MAAI,oBAAA,GAAA;EACb;EACA,IAAW,gBAAa;AACtB,WAAO,iBAAiBA,wBAAA,MAAI,wBAAA,GAAA,CAAW;EACzC;EACA,IAAW,cAAW;AACpB,WAAO,eAAeA,wBAAA,MAAI,sBAAA,GAAA,CAAS;EACrC;;;;;;;;;;EAWO,OAAO,eAAe,kBAAwB;AACnD,gBACE,OAAO,qBAAqB,UAC5B,wCAAwC,OAAO,gBAAgB,uBAAuB;AAGxF,QAAI,CAAC,eAAQ,YAAY,kBAAkB,EAAE,GAAG;AAC9C,YAAM,IAAI,WAAW,kBAAkB,gBAAgB,6BAA6B;IACtF;AAEA,UAAM,SAAS,iBAAiB,MAAM,GAAG,EAAE;AAG3C,UAAM,iBAAiB,iBAAiB,MAAM,IAAI,EAAE;AACpD,QAAI,cAAsB;AAC1B,QAAI;AACF,oBAAc,aAAa,OAAO,cAAc;IAClD,QAAQ;AACN,YAAM,IAAI,WAAW,kBAAkB,gBAAgB,0CAA0C;IACnG;AAGA,UAAM,WAAoB,gBAAgB;AAG1C,UAAM,mBAAmB,iBAAiB,MAAM,IAAI,EAAE;AACtD,QAAI,UAAkB;AACtB,QAAI;AACF,gBAAU,aAAa,OAAO,gBAAgB;IAChD,QAAQ;AACN,YAAM,IAAI,WAAW,kBAAkB,gBAAgB,+CAA+C;IACxG;AAGA,UAAM,gBAAgB,iBAAiB,MAAM,IAAI,EAAE;AAEnD,QAAI,UAA+B;AACnC,QAAI,YAAmC;AACvC,QAAI;AACF,YAAM,IAAI,aAAa,OAAO,aAAa;AAC3C,gBAAU;AACV,kBAAY;IACd,QAAQ;AACN,YAAM,IAAI,WACR,kBAAkB,gBAAgB,iDAAiD,aAAa,IAAI;IAExG;AAEA,iBAAa,OAAO;AACpB,mBAAe,SAAS;AAGxB,UAAM,mBAAmB,iBAAiB,MAAM,IAAI,EAAE;AAEtD,QAAIF,WAAkB;AACtB,QAAI;AACF,MAAAA,WAAU,aAAa,OAAO,gBAAgB;IAChD,QAAQ;AACN,YAAM,IAAI,WAAW,kBAAkB,gBAAgB,oDAAoD;IAC7G;AAEA,QAAIA,aAAY,kBAAU,sBAAsB;AAC9C,YAAM,IAAI,WACR,kBAAkB,gBAAgB,mDAAmD,kBAAU,oBAAoB,SAASA,QAAO,UAAU;IAEjJ;AAEA,UAAM,cAAc,IAAI,aACtB,QACA,SACA,WACA,SACAA,UACA,UACA,cAAc,MAAM,cAAc,MAAS;AAS7C,WAAO;EACT;EAEA,OAAO,OACL,eACA,UAIC;AAED,0BAAsB,eAAe,eAAe;AAEpD,QAAI,kBAAkB,eAAQ,UAAU;AACtC,YAAM,IAAI,WAAW,2BAA2B;IAClD;AAEA,UAAM,cAAc,aAAY,eAAe,aAAa;AAE5D,SAAI,qCAAU,aAAY,QAAW;AACnC,UAAI,YAAY,YAAY,SAAS,SAAS;AAC5C,cAAM,IAAI,WACR,gCAAgC,aAAa,cAAc,SAAS,OAAO,aAAa,YAAY,OAAO,WAAW;MAE1H;IACF;AAEA,SAAI,qCAAU,eAAc,QAAW;AACrC,UAAI,YAAY,cAAc,SAAS,WAAW;AAChD,cAAM,gBAAgB,YAAY;AAClC,cAAM,wBAAwB,iBAAiB,SAAS,SAAS;AACjE,cAAM,IAAI,WACR,6BAA6B,aAAa,gBAAgB,sBAAsB,IAAI,eAAe,cAAc,IAAI,YAAY;MAErI;IACF;AAEA,SAAI,qCAAU,aAAY,QAAW;AACnC,UAAI,YAAY,YAAY,SAAS,SAAS;AAC5C,cAAM,cAAc,YAAY;AAChC,cAAM,sBAAsB,eAAe,SAAS,OAAO;AAC3D,cAAM,IAAI,WACR,6BAA6B,aAAa,gBAAgB,oBAAoB,IAAI,eAAe,YAAY,IAAI,YAAY;MAEjI;IACF;AAEA,WAAO;EACT;EAEO,kBAAe;AACpB,gBAAY,OAAOE,wBAAA,MAAI,sBAAA,GAAA,CAAS,MAAM,OAAOA,wBAAA,MAAI,wBAAA,GAAA,CAAW,CAAC;AAC7D,gBACGA,wBAAA,MAAI,oBAAA,GAAA,MAAY,UAAaA,wBAAA,MAAI,uBAAA,GAAA,KAC/BA,wBAAA,MAAI,oBAAA,GAAA,MAAY,UAAaA,wBAAA,MAAI,oBAAA,GAAA,IAAU,OAAO,CAACA,wBAAA,MAAI,uBAAA,GAAA,CAAW;AAGvE,UAAM,iBAAiB,YAAYA,wBAAA,MAAI,sBAAA,GAAA,GAAW,EAAE;AACpD,UAAM,gBAAgB,eAAe,SAAS,IAAI,EAAE;AAEpD,gBAAY,eAAe,WAAW,EAAE;AACxC,gBAAY,cAAc,WAAW,CAAC;AAGtC,UAAM,aAAa,eAAQ,SAASA,wBAAA,MAAI,qBAAA,GAAA,CAAQ;AAEhD,UAAM,uBAAuB,IAAI,WAAW,EAAE;AAC9C,yBAAqB,IAAI,YAAY,CAAC;AACtC,yBAAqB,EAAE,IAAIA,wBAAA,MAAI,oBAAA,GAAA,MAAY,SAAY,MAAMA,wBAAA,MAAI,oBAAA,GAAA;AACjE,yBAAqB,IAAI,eAAe,EAAE;AAC1C,yBAAqB,EAAE,IAAIA,wBAAA,MAAI,sBAAA,GAAA;AAC/B,yBAAqB,EAAE,IAAIA,wBAAA,MAAI,sBAAA,GAAA;AAE/B,WAAO;EACT;EAEO,qBAAkB;AACvB,WAAO,eAAQ,QAAQ,KAAK,gBAAe,CAAE;EAC/C;EAEO,OAAO,kBACZ,iBACA,YACA,SACA,WACA,mBACA,OAAa;AAEb,UAAM,SAAS,aAAY,oBAAoB,iBAAiB,YAAY,SAAS,KAAK;AAC1F,WAAO,IAAI,aACT,QACA,SACA,WACA,WACA,mBACA,OACA,KAAK;EAET;;;;EAKQ,OAAO,oBAAoB,iBAA6B,YAAoB,SAAiB,OAAa;AAkBhH,oBAAgB,iBAAiB,UAAU;AAC3C,oBAAgB,YAAY,YAAY;AACxC,mBAAe,OAAO,OAAO;AAC7B,mBAAe,SAAS,SAAS;AAEjC,UAAM,uBAAuB,IAAI,WAAW,CAAC,KAAK,CAAC;AACnD,UAAM,4BAA4B,eAAe,YAAY,aAAa;AAC1E,UAAM,iBAAiB,YAAY,SAAS,EAAE;AAE9C,mBAAe,oBAAoB;AACnC,oBAAgB,yBAAyB;AACzC,oBAAgB,cAAc;AAE9B,WAAO,eAAQ,UACb,YAAY,iBAAiB,sBAAsB,2BAA2B,cAAc,CAAC;EAEjG;EAEO,OAAO,kBACZ,uBACA,YACA,oBACA,SACA,mBAAyB;AAEzB,UAAM,iBAA+B,aAAY,eAC/C,uBACA,YACA,oBACA,SACA,iBAAiB;AAEnB,WAAO,eAAe,IAAI,eAAQ,OAAO;EAC3C;EAEO,OAAO,eACZ,uBACA,YACA,oBACA,SACA,mBAAyB;AAEzB,QAAI,OAAO,OAAO,IAAI,YAAY;AAChC,YAAM,IAAI,WAAW,iDAAiD;IACxE;AAIA,UAAM,qBAAqB,eAAQ,UAAU,qBAAqB;AAElE,UAAM,kBAA8B,eAAQ,SAAS,kBAAkB;AACvE,gBAAY,gBAAgB,WAAW,EAAE;AAmBzC,UAAM,UAAU,WAAW,IAAI,CAAC,WAAW,oBAAmB;AAC5D,YAAM,cAAc,aAAY,kBAC9B,iBACA,oBACA,SACA,WACA,mBACA,eAAe;AAEjB,aAAO,YAAY,gBAAe;IACpC,CAAC;AAED,WAAO;EACT;;;;;AC7WK,IAAM,8BAAiD,IAAI,eAAQ,UAAU;EAClF;IACE,QAAQ,CAAA;IACR,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ,CAAA;IACR,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,SAAS;MACP;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;CAET;;;;;;;;;;;;;;;;;;;ACtkBK,IAAO,cAAP,MAAO,qBAAoB,gCAA+B;EAO9D,cAAA;AACE,UAAM,aAAa;AAPrB,qCAAA,IAAA,MAAA,MAAA;AACA,4CAAA,IAAA,MAAA,MAAA;AACA,kCAAA,IAAA,MAAA,MAAA;AACA,2BAAA,IAAA,MAAA,MAAA;AACA,8BAAA,IAAA,MAAA,MAAA;EAIA;EAEO,aAAa,OAClB,QACA,4BACA,KACA,YAAkC;AAElC,oBAAgB,4BAA4B,4BAA4B;AAExE,QAAI,eAAe,QAAW;AAC5B,YAAM,IAAI,WAAW,qBAAqB;IAC5C;AAEA,UAAM,cAAc,IAAI,aAAW;AACnC,IAAAC,wBAAA,aAAW,yCAA+B,4BAA0B,GAAA;AACpE,IAAAA,wBAAA,aAAW,kCAAwB,IAAI,eAAQ,SAC7C,4BACA,OAAO,6BACP,MAAM,GACP,GAAA;AACD,UAAM,YAAY,YAAW;AAC7B,WAAO;EACT;EAEA,IAAoB,mBAAgB;AAClC,gBAAYC,wBAAA,MAAI,kCAAA,GAAA,MAA0B,QAAW,wCAAwC;AAC7F,WAAOA,wBAAA,MAAI,kCAAA,GAAA;EACb;EAEA,IAAoB,YAAS;AAC3B,gBAAYA,wBAAA,MAAI,kCAAA,GAAA,MAA0B,QAAW,4CAA4C;AACjG,WAAOA,wBAAA,MAAI,kCAAA,GAAA,EAAsB;EACnC;EAEQ,MAAM,cAAW;AACvB,gBAAYA,wBAAA,MAAI,kCAAA,GAAA,MAA0B,QAAW,wCAAwC;AAC7F,gBAAYA,wBAAA,MAAI,+BAAA,GAAA,MAAuB,QAAW,yCAAyC;AAC3F,gBAAYA,wBAAA,MAAI,wBAAA,GAAA,MAAgB,QAAW,yCAAyC;AAEpF,UAAM,UAAU,MAAMA,wBAAA,MAAI,kCAAA,GAAA,EAAsB,cAAa;AAC7D,yBAAqB,OAAO;AAC5B,IAAAD,wBAAA,MAAI,+BAAqB,SAAO,GAAA;AAEhC,UAAM,YAAY,MAAMC,wBAAA,MAAI,kCAAA,GAAA,EAAsB,aAAY;AAC9D,qBAAiB,SAAS;AAC1B,IAAAD,wBAAA,MAAI,wBAAc,OAAO,SAAS,GAAC,GAAA;AAEnC,QAAIC,wBAAA,MAAI,2BAAA,GAAA,MAAmB,QAAW;AAEpC,YAAM,eAAe,MAAMA,wBAAA,MAAI,kCAAA,GAAA,EAAsB,aAAY;AACjE,kBAAY,aAAa,WAAW,CAAC;AACrC,qBAAe,aAAa,CAAC,GAAG,iBAAiB;AACjD,qBAAe,aAAa,CAAC,GAAG,iBAAiB;AACjD,qBAAe,aAAa,CAAC,GAAG,iBAAiB;AACjD,yBAAmB,aAAa,CAAC,GAAG,iBAAiB;AACrD,sBAAgB,aAAa,CAAC,GAAG,iBAAiB;AAClD,4BAAsB,aAAa,CAAC,GAAG,iBAAiB;AAExD,MAAAD,wBAAA,MAAI,2BAAiB;QACnB,QAAQ,OAAO,OAAO,aAAa,CAAC,CAAC,CAAC;QACtC,MAAM,aAAa,CAAC;QACpB,SAAS,aAAa,CAAC;QACvB,SAAS,aAAa,CAAC;QACvB,mBAAmB,aAAa,CAAC;QACjC,MAAM,aAAa,CAAC;;SAErB,GAAA;IACH;AAGA,gBAAYC,wBAAA,MAAI,2BAAA,GAAA,EAAe,WAAW,OAAO,EAAI,CAAC;AACtD,gBAAYA,wBAAA,MAAI,2BAAA,GAAA,EAAe,SAAS,eAAQ,QAAQ;AACxD,gBAAYA,wBAAA,MAAI,2BAAA,GAAA,EAAe,SAAS,kBAAU,sBAAsB,OAAO,IAAI;AACnF,gBAAYA,wBAAA,MAAI,2BAAA,GAAA,EAAe,YAAY,kBAAU,sBAAsB,OAAO,OAAO;EAC3F;EAEA,IAAW,UAAO;AAChB,gBAAYA,wBAAA,MAAI,yCAAA,GAAA,MAAiC,QAAW,qCAAqC;AACjG,WAAOA,wBAAA,MAAI,yCAAA,GAAA;EACb;;EAGA,IAAW,iBAAc;AACvB,gBAAYA,wBAAA,MAAI,2BAAA,GAAA,MAAmB,QAAW,qCAAqC;AACnF,WAAOA,wBAAA,MAAI,2BAAA,GAAA,EAAe;EAC5B;;;EAIA,IAAW,2BAAwB;AACjC,gBAAYA,wBAAA,MAAI,2BAAA,GAAA,MAAmB,QAAW,qCAAqC;AACnF,WAAOA,wBAAA,MAAI,2BAAA,GAAA,EAAe;EAC5B;EAEA,IAAW,eAAY;AACrB,gBAAYA,wBAAA,MAAI,2BAAA,GAAA,MAAmB,QAAW,qCAAqC;AACnF,WAAOA,wBAAA,MAAI,2BAAA,GAAA;EACb;EAEO,yBAAsB;AAC3B,gBAAYA,wBAAA,MAAI,+BAAA,GAAA,MAAuB,QAAW,qCAAqC;AACvF,WAAOA,wBAAA,MAAI,+BAAA,GAAA;EACb;EAEO,MAAM,sBAAsB,SAAyB;AAC1D,UAAM,YAAY,KAAK,uBAAsB;AAE7C,kBAAc,SAAS,SAAS;AAChC,gBAAY,QAAQ,WAAW,UAAU,QAAQ,qCAAqC;AAEtF,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,EAAE,GAAG;AACzC,YAAM,IAAI,MAAM,QAAQ,CAAC,EAAE,WAAU;AACrC,kBAAY,UAAU,CAAC,MAAM,GAAG,aAAa,CAAC,uBAAuB,CAAC,gBAAgB;IACxF;EACF;EAEO,eAAY;AACjB,gBAAYA,wBAAA,MAAI,wBAAA,GAAA,MAAgB,QAAW,qCAAqC;AAChF,WAAOA,wBAAA,MAAI,wBAAA,GAAA;EACb;EAEO,sCACL,oBACA,iBACA,WAAiB;AAEjB,UAAM,SAAS,KAAK;AACpB,UAAM,SAAuB;MAC3B,QAAQ;QACN,SAAS,OAAO;QAChB,MAAM,OAAO;QACb,SAAS,OAAO;QAChB,mBAAmB,OAAO;;MAE5B,OAAO,kBAAU,sBAAsB;MACvC,SAAS;QACP,WAAW;QACX;QACA;;;AAIJ,WAAO;EACT;;;AAGF,eAAsB,4BACpB,mBACA,iBACA,WACA,UACA,aACA,YAA4B;AAO5B,QAAM,eAA8B,kBAAkB,IAAI,CAAC,qBACzD,YAAY,eAAe,gBAAgB,CAAC;AAG9C,cAAY,kBAAkB,WAAW,gBAAgB,MAAM;AAE/D,QAAM,WAAqB,CAAA;AAC3B,QAAM,YAAiC,CAAA;AAEvC,WAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,EAAE,GAAG;AACjD,QAAI,iBAA4C,gBAAgB,CAAC;AACjE,QAAI,OAAO,mBAAmB,WAAW;AACvC,uBAAiB,iBAAiB,SAAS;IAC7C;AACA,UAAM,uBAAuB,OAAO,cAAc;AAClD,UAAM,gBAA+B,aAAa,CAAC,EAAE;AAErD,aAAS,KAAK,cAAc,gBAAgB;AAE5C,YAAQ,cAAc,MAAM;MAC1B,KAAK,UAAU,UAAU;AAEvB,kBAAU,KAAK,KAAK,qBAAqB,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG,CAAC,EAAE;AACzE;MACF;MACA,KAAK,UAAU,OAAO;AAEpB,kBAAU,KAAK,oBAAoB;AACnC;MACF;MACA,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,UAAU,UAAU;AAEvB,kBAAU,KAAK,oBAAoB;AACnC;MACF;MACA,KAAK,UAAU,UAAU;AAEvB,kBAAU,KAAK,KAAK,qBAAqB,SAAS,EAAE,EAAE,SAAS,KAAK,GAAG,CAAC,EAAE;AAC1E;MACF;MACA,KAAK,UAAU,WAAW;AAExB,kBAAU,KAAK,KAAK,qBAAqB,SAAS,EAAE,EAAE,SAAS,KAAK,GAAG,CAAC,EAAE;AAC1E;MACF;MACA,KAAK,UAAU,WAAW;AAExB,kBAAU,KAAK,KAAK,qBAAqB,SAAS,EAAE,EAAE,SAAS,KAAK,GAAG,CAAC,EAAE;AAC1E;MACF;MACA,SAAS;AACP,cAAM,IAAI,WACR,wCAAwC,cAAc,IAAI,WAAW,cAAc,IAAI,eAAe,cAAc,gBAAgB,EAAE;MAE1I;IACF;EACF;AAKA,QAAM,cAAc,SAAS,OAAO,CAAC,WAAW,GAAG,UAAU,SAAS,GAAG,CAAC,IAAI,GAAG,WAAW,CAAA,CAAE,CAAC;AAI/F,QAAM,kBAAkB,OAAO,YAAY,MAAM,EAAE,EAAE,MAAM,GAAG,GAAG;AACjE,cACE,oBAAoB,OAAO,YAAY,MAAM,IAAI,GAAG,GACpD,uDAAuD;AAGzD,QAAM,SAAS,YAAY,sCAAsC,mBAAmB,iBAAiB,SAAS;AAE9G,QAAM,iCAA2C,MAAM,gBACrD,YACA,OAAO,QACP,OAAO,OACP,OAAO,OAAO;AAGhB,SAAO,EAAE,YAAY,gCAAgC,OAAO,UAAU,QAAQ,WAAW,gBAAe;AAC1G;AAEA,eAAsB,+CACpB,mBACA,uBACA,WACA,WACA,2BACA,UACA,aACA,YAA4B;AAE5B,cAAY,cAAc,eAAQ,eAAe,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,GAAG,wBAAwB;AAE1F,QAAM,EAAE,YAAY,OAAO,OAAM,IAAK,MAAM,4BAC1C,mBACA,uBACA,WACA,UACA,aACA,UAAU;AAIZ,QAAM,mBAAmB,eAAQ,eAAe,CAAC,OAAO,GAAG,CAAC,WAAW,MAAM,CAAC;AAC9E,QAAM,mBAAmB,eAAQ,eAAe,MAAM,WAAW,MAAM,EAAE,KAAK,OAAO,GAAG,UAAU;AAClG,QAAM,kBAAkB,eAAQ,OAAO,CAAC,kBAAkB,kBAAkB,SAAS,CAAC;AAGtF,QAAM,oBAAoB,SAAS,OAAO,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,MAAM,CAAC;AAEjE,QAAM,WACJ,4BACA,SAAS,OAAO,CAAC,WAAW,SAAS,OAAO,GAAG,CAAC,WAAW,mBAAmB,eAAe,CAAC,EAAE,MAAM,CAAC;AAEzG,SAAO,EAAE,SAAQ;AACnB;;;;;;;;;;;;;;;;AClTM,IAAO,0BAAP,MAAO,iCAAgC,qCAAoC;EAI/E,cAAA;AACE,UAAM,kBAAkB;AAJ1B,6DAAA,IAAA,MAAA,MAAA;AACA,oEAAA,IAAA,MAAA,MAAA;EAIA;EAEO,aAAa,OAClB,QACA,wCACA,KAA8C;AAE9C,oBAAgB,wCAAwC,wCAAwC;AAEhG,UAAM,mBAAmB,IAAI,yBAAuB;AACpD,IAAAC,wBAAA,kBAAgB,iEAA2C,wCAAsC,GAAA;AACjG,IAAAA,wBAAA,kBAAgB,0DAAoC,IAAI,eAAQ,SAC9D,wCACA,OAAO,6BACP,MAAM,GACP,GAAA;AACD,UAAM,iBAAiB,YAAW;AAClC,WAAO;EACT;EAEA,IAAoB,mBAAgB;AAClC,gBACEC,wBAAA,MAAI,0DAAA,GAAA,MAAsC,QAC1C,wDAAwD;AAE1D,WAAOA,wBAAA,MAAI,0DAAA,GAAA;EACb;EAEA,IAAoB,YAAS;AAC3B,gBACEA,wBAAA,MAAI,0DAAA,GAAA,MAAsC,QAC1C,wDAAwD;AAE1D,WAAOA,wBAAA,MAAI,0DAAA,GAAA,EAAkC;EAC/C;EAEQ,MAAM,cAAW;AACvB,gBACEA,wBAAA,MAAI,0DAAA,GAAA,MAAsC,QAC1C,oDAAoD;EAExD;EAEA,IAAW,UAAO;AAChB,gBACEA,wBAAA,MAAI,iEAAA,GAAA,MAA6C,QACjD,iDAAiD;AAEnD,WAAOA,wBAAA,MAAI,iEAAA,GAAA;EACb;;;;;;;;;;;;;;;;;;;;;;;AC1CI,IAAO,2BAAP,MAAO,0BAAwB;EASnC,cAAA;AARA,kCAAA,IAAA,MAAA,MAAA;AACA,4CAAA,IAAA,MAAA,MAAA;AACA,4CAAA,IAAA,MAAA,MAAA;AACA,0CAAA,IAAA,MAAA,MAAA;AACA,uCAAA,IAAA,MAAA,MAAA;AACA,sDAAA,IAAA,MAAA,MAAA;AACA,gDAAA,IAAA,MAAA,MAAA;EAEe;EAER,aAAa,OAClB,wBACA,QAeC;AAED,QAAI,CAAC,eAAQ,UAAU,OAAO,kBAAkB,GAAG;AACjD,YAAM,IAAI,WAAW,gCAAgC,OAAO,kBAAkB,EAAE;IAClF;AACA,QAAI,CAAC,eAAQ,UAAU,OAAO,kBAAkB,GAAG;AACjD,YAAM,IAAI,WAAW,wCAAwC,OAAO,kBAAkB,EAAE;IAC1F;AACA,QAAI,OAAO,mCAAmC,QAAW;AACvD,UAAI,CAAC,eAAQ,UAAU,OAAO,8BAA8B,GAAG;AAC7D,cAAM,IAAI,WAAW,6CAA6C,OAAO,8BAA8B,EAAE;MAC3G;IACF;AAEA,UAAM,OAAO,IAAI,0BAAwB;AAEzC,IAAAC,wBAAA,MAAI,+BAAQ,MAAM,IAAI,OACpB,wBACA,OAAO,oBACP,OAAO,QACP,OAAO,aAAa,GACrB,GAAA;AACD,IAAAA,wBAAA,MAAI,yCAAkB,MAAM,cAAc,OACxC,wBACAC,wBAAA,MAAI,+BAAA,GAAA,EAAM,sBACV,OAAO,kBACP,OAAO,uBAAuB,GAC/B,GAAA;AACD,IAAAD,wBAAA,MAAI,yCAAkB,MAAM,cAAc,OACxC,wBACAC,wBAAA,MAAI,yCAAA,GAAA,EAAgB,sBACpB,OAAO,gBAAgB,GACxB,GAAA;AACD,IAAAD,wBAAA,MAAI,uCAAgB,MAAM,YAAY,OACpC,wBACA,OAAO,oBACP,OAAO,cAAc,GACtB,GAAA;AACD,IAAAA,wBAAA,MAAI,oCAAa,MAAM,SAAS,OAC9B,wBACAC,wBAAA,MAAI,yCAAA,GAAA,EAAgB,iBACpB,OAAO,WAAW,GACnB,GAAA;AACD,QAAI,OAAO,mCAAmC,QAAW;AACvD,MAAAD,wBAAA,MAAI,mDAA4B,MAAM,wBAAwB,OAC5D,wBACA,OAAO,gCACP,OAAO,0BAA0B,GAClC,GAAA;IACH;AAEA,QAAIC,wBAAA,MAAI,yCAAA,GAAA,EAAgB,mBAAmBA,wBAAA,MAAI,uCAAA,GAAA,EAAc,gBAAgB;AAC3E,YAAM,IAAI,WACR,0DAA0DA,wBAAA,MAAI,yCAAA,GAAA,EAAgB,cAAc,4CAA4CA,wBAAA,MAAI,uCAAA,GAAA,EAAc,cAAc,EAAE;IAE9K;AAEA,IAAAD,wBAAA,MAAI,6CAAsB,CAAA,GAAE,GAAA;AAE5B,IAAAC,wBAAA,MAAI,6CAAA,GAAA,EAAoBA,wBAAA,MAAI,+BAAA,GAAA,EAAM,QAAQ,YAAW,CAAE,IAAIA,wBAAA,MAAI,+BAAA,GAAA;AAC/D,IAAAA,wBAAA,MAAI,6CAAA,GAAA,EAAoBA,wBAAA,MAAI,yCAAA,GAAA,EAAgB,QAAQ,YAAW,CAAE,IAAIA,wBAAA,MAAI,yCAAA,GAAA;AACzE,QAAIA,wBAAA,MAAI,mDAAA,GAAA,GAA2B;AACjC,MAAAA,wBAAA,MAAI,6CAAA,GAAA,EAAoBA,wBAAA,MAAI,mDAAA,GAAA,EAA0B,QAAQ,YAAW,CAAE,IAAIA,wBAAA,MAAI,mDAAA,GAAA;IACrF;AACA,IAAAA,wBAAA,MAAI,6CAAA,GAAA,EAAoBA,wBAAA,MAAI,yCAAA,GAAA,EAAgB,QAAQ,YAAW,CAAE,IAAIA,wBAAA,MAAI,yCAAA,GAAA;AACzE,IAAAA,wBAAA,MAAI,6CAAA,GAAA,EAAoBA,wBAAA,MAAI,uCAAA,GAAA,EAAc,QAAQ,YAAW,CAAE,IAAIA,wBAAA,MAAI,uCAAA,GAAA;AACvE,IAAAA,wBAAA,MAAI,6CAAA,GAAA,EAAoBA,wBAAA,MAAI,oCAAA,GAAA,EAAW,QAAQ,YAAW,CAAE,IAAIA,wBAAA,MAAI,oCAAA,GAAA;AAEpE,WAAO,OAAOA,wBAAA,MAAI,6CAAA,GAAA,CAAmB;AAErC,WAAO;EACT;EAEO,uBAAoB;AACzB,gBAAYA,wBAAA,MAAI,6CAAA,GAAA,MAAwB,QAAW,6CAA6C;AAChG,WAAOA,wBAAA,MAAI,6CAAA,GAAA;EACb;EAEO,uBAAuB,SAAe;AAC3C,UAAM,IAAI,QAAQ,YAAW;AAC7B,QAAI,MAAM,KAAK,IAAI,QAAQ,YAAW,GAAI;AACxC,aAAO,KAAK;IACd;AACA,QAAI,MAAM,KAAK,cAAc,QAAQ,YAAW,GAAI;AAClD,aAAO,KAAK;IACd;AACA,QAAI,MAAM,KAAK,cAAc,QAAQ,YAAW,GAAI;AAClD,aAAO,KAAK;IACd;AACA,QAAI,MAAM,KAAK,YAAY,QAAQ,YAAW,GAAI;AAChD,aAAO,KAAK;IACd;AACA,QAAI,MAAM,KAAK,SAAS,QAAQ,YAAW,GAAI;AAC7C,aAAO,KAAK;IACd;AACA,QAAI,KAAK,yBAAyB;AAChC,UAAI,MAAM,KAAK,wBAAwB,QAAQ,YAAW,GAAI;AAC5D,eAAO,KAAK;MACd;IACF;AACA,WAAO;EACT;EAEO,oBAAoB,MAAuB;AAChD,YAAQ,MAAM;MACZ,KAAK;AACH,eAAO,KAAK;MACd,KAAK;AACH,eAAO,KAAK;MACd,KAAK;AACH,eAAO,KAAK;MACd,KAAK;AACH,eAAO,KAAK;MACd,KAAK;AACH,eAAO,KAAK;MACd,KAAK;AACH,eAAO,KAAK;MACd,SAAS;AACP,cAAM,IAAI,WAAW,wBAAwB,IAAI,EAAE;MACrD;IACF;EACF;EAEO,+BAA+B,MAAkC;AACtE,YAAQ,MAAM;MACZ,KAAK;AACH,eAAO,KAAK;MACd,KAAK;AACH,eAAO,KAAK;MACd,KAAK;AACH,eAAO,KAAK;MACd,KAAK;AACH,eAAO,KAAK;MACd,KAAK;AACH,eAAO,KAAK;MACd,SAAS;AACP,cAAM,IAAI,WAAW,oCAAoC,IAAI,EAAE;MACjE;IACF;EACF;EAEO,oCACL,MAAuC;AAEvC,YAAQ,MAAM;MACZ,KAAK;AACH,eAAO,KAAK;MACd,SAAS;AACP,cAAM,IAAI,WAAW,0CAA0C,IAAI,EAAE;MACvE;IACF;EACF;EAEO,gCAAgC,MAAkC;AACvE,WAAO,KAAK,+BAA+B,IAAI,EAAE;EACnD;EAEO,qCAAqC,MAAuC;AACjF,UAAM,IAAI,KAAK,oCAAoC,IAAI;AACvD,QAAI,MAAM,QAAW;AACnB,aAAO;IACT;AACA,WAAO,EAAE;EACX;EAEA,IAAW,0BAAuB;AAChC,WAAOA,wBAAA,MAAI,mDAAA,GAAA;EACb;EAEA,IAAW,MAAG;AACZ,gBAAYA,wBAAA,MAAI,+BAAA,GAAA,MAAU,QAAW,6CAA6C;AAClF,WAAOA,wBAAA,MAAI,+BAAA,GAAA;EACb;EAEA,IAAW,gBAAa;AACtB,gBAAYA,wBAAA,MAAI,yCAAA,GAAA,MAAoB,QAAW,6CAA6C;AAC5F,WAAOA,wBAAA,MAAI,yCAAA,GAAA;EACb;EAEA,IAAW,gBAAa;AACtB,gBAAYA,wBAAA,MAAI,yCAAA,GAAA,MAAoB,QAAW,6CAA6C;AAC5F,WAAOA,wBAAA,MAAI,yCAAA,GAAA;EACb;EAEA,IAAW,cAAW;AACpB,gBAAYA,wBAAA,MAAI,uCAAA,GAAA,MAAkB,QAAW,6CAA6C;AAC1F,WAAOA,wBAAA,MAAI,uCAAA,GAAA;EACb;EAEA,IAAW,WAAQ;AACjB,gBAAYA,wBAAA,MAAI,oCAAA,GAAA,MAAe,QAAW,6CAA6C;AACvF,WAAOA,wBAAA,MAAI,oCAAA,GAAA;EACb;EAEO,uBAAuB,QAG7B;;AACC,gBAAYA,wBAAA,MAAI,+BAAA,GAAA,MAAU,QAAW,6CAA6C;AAClF,gBAAYA,wBAAA,MAAI,yCAAA,GAAA,MAAoB,QAAW,6CAA6C;AAC5F,gBAAYA,wBAAA,MAAI,uCAAA,GAAA,MAAkB,QAAW,6CAA6C;AAC1F,gBAAYA,wBAAA,MAAI,yCAAA,GAAA,MAAoB,QAAW,6CAA6C;AAE5F,UAAM,2BAA0B,KAAAA,wBAAA,MAAI,mDAAA,GAAA,MAAJ,mBAA+B;AAE/D,WAAO;MACL,oBAAoBA,wBAAA,MAAI,+BAAA,GAAA,EAAM;MAC9B,+BAA8B,KAAAA,wBAAA,MAAI,yCAAA,GAAA,MAAJ,mBAAqB;MACnD,SAAS,OAAO;MAChB,gBAAgB,OAAOA,wBAAA,MAAI,uCAAA,GAAA,EAAc,cAAc;MACvD,8BAA8BA,wBAAA,MAAI,yCAAA,GAAA,EAAgB;MAClD,oBAAoBA,wBAAA,MAAI,uCAAA,GAAA,EAAc;MACtC,oCAAoCA,wBAAA,MAAI,uCAAA,GAAA,EAAc;MACtD,2CAA2CA,wBAAA,MAAI,yCAAA,GAAA,EAAgB;MAC/D,YAAY,OAAO;MACnB,GAAI,2BAA2B,EAAE,wBAAuB;;EAE5D;;;;;;;;;;;;;;;;;;ACrQI,SAAU,yBAAyB,OAAgB,WAAmB,UAAgB;AAC1F,mBAAiB,OAAO,GAAG,SAAS,eAAe,QAAQ,EAAE;AAC/D;AAEM,SAAU,2BACd,OACA,WACA,UAAgB;AAEhB,qBAAmB,OAAO,GAAG,SAAS,eAAe,QAAQ,EAAE;AACjE;AAEM,SAAU,6BACd,OACA,WACA,UAAgB;AAEhB,+BAA6B,OAAO,WAAW,UAAU,CAAC;AAC5D;AAEM,SAAU,6BACd,OACA,WACA,UAAgB;AAEhB,+BAA6B,OAAO,WAAW,UAAU,CAAC;AAC5D;AAUM,SAAU,8BACd,OACA,WACA,UAAgB;AAEhB,+BAA6B,OAAO,WAAW,UAAU,EAAE;AAC7D;AAEM,SAAU,8BACd,OACA,WACA,UAAgB;AAEhB,+BAA6B,OAAO,WAAW,UAAU,EAAE;AAC7D;AAEM,SAAU,4BACd,OACA,WACA,UAAgB;AAEhB,+BAA6B,OAAO,WAAW,QAAQ;AACzD;AAEA,SAAS,6BACP,OACA,WACA,UACA,OAAc;AAEd,sBAAoB,OAAO,OAAO,GAAG,SAAS,eAAe,QAAQ,EAAE;AACzE;AAEM,SAAU,wBAAwB,OAAgB,WAAmB,UAAgB;AACzF,kBAAgB,OAAO,GAAG,SAAS,eAAe,QAAQ,EAAE;AAC9D;AAEM,IAAO,iBAAP,MAAO,gBAAc;EAIzB,YAAY,iBAAuB;AAHnC,gCAAA,IAAA,MAAuB,EAAE;AACzB,kCAAA,IAAA,MAAyB,EAAE;AAOzB,IAAAC,yBAAA,MAAI,6BAAgB,mBAAmB,IAAI,KAAK,kBAAkB,GAAC,GAAA;EACrE;EAEA,OAAO,MAAM,aAAqB,eAAqB;AACrD,QAAI,cAAc,KAAK,gBAAgB,GAAG;AACxC,YAAM,IAAI,WAAW,gCAAgC,WAAW,cAAc,aAAa,GAAG;IAChG;EACF;EAEA,IAAW,UAAO;AAChB,UAAM,QAAQC,yBAAA,MAAI,6BAAA,GAAA,IAAgB;AAClC,QAAI,OAAO;AACT,kBAAYA,yBAAA,MAAI,+BAAA,GAAA,IAAkB,CAAC;IACrC,OAAO;AACL,kBAAYA,yBAAA,MAAI,+BAAA,GAAA,KAAmB,CAAC;IACtC;AACA,WAAO;EACT;EAEA,IAAW,kBAAe;AACxB,QAAIA,yBAAA,MAAI,6BAAA,GAAA,IAAgB,GAAG;AACzB,aAAO;IACT;AACA,WAAOA,yBAAA,MAAI,6BAAA,GAAA,IAAgB;EAC7B;EAEA,IAAW,cAAW;AACpB,WAAOA,yBAAA,MAAI,6BAAA,GAAA;EACb;EAEA,IAAW,gBAAa;AACtB,WAAOA,yBAAA,MAAI,+BAAA,GAAA;EACb;;;;EAKA,GAAG,aAAqB,eAAqB;AAC3C,oBAAe,MAAM,aAAa,aAAa;AAC/C,QAAIA,yBAAA,MAAI,6BAAA,GAAA,MAAkB,aAAa;AACrC,aAAOA,yBAAA,MAAI,+BAAA,GAAA,IAAkB;IAC/B;AACA,WAAOA,yBAAA,MAAI,6BAAA,GAAA,IAAgB;EAC7B;;;;EAKA,GAAG,aAAqB,eAAqB;AAC3C,oBAAe,MAAM,aAAa,aAAa;AAC/C,WAAOA,yBAAA,MAAI,6BAAA,GAAA,MAAkB,eAAeA,yBAAA,MAAI,+BAAA,GAAA,MAAoB;EACtE;;;;EAKA,GAAG,aAAqB,eAAqB;AAC3C,WAAO,KAAK,GAAG,aAAa,aAAa,KAAK,KAAK,GAAG,aAAa,aAAa;EAClF;;;;EAKA,cAAc,aAAqB,eAAqB;AACtD,oBAAe,MAAM,aAAa,aAAa;AAC/C,QAAI,KAAK,GAAG,aAAa,aAAa,GAAG;AACvC,YAAM,IAAI,WACR,8BAA8B,WAAW,cAAc,aAAa,2CAA2CA,yBAAA,MAAI,6BAAA,GAAA,CAAa,cAAcA,yBAAA,MAAI,+BAAA,GAAA,CAAe,EAAE;IAEvK;AACA,IAAAD,yBAAA,MAAI,6BAAgB,aAAW,GAAA;AAC/B,IAAAA,yBAAA,MAAI,+BAAkB,eAAa,GAAA;EACrC;;;;EAKA,wBAAwB,aAAqB,eAAqB;AAChE,oBAAe,MAAM,aAAa,aAAa;AAC/C,QAAI,KAAK,GAAG,aAAa,aAAa,GAAG;AACvC,YAAM,IAAI,WACR,wDAAwD,WAAW,cAAc,aAAa,IAAI;IAEtG;AACA,IAAAA,yBAAA,MAAI,6BAAgB,aAAW,GAAA;AAC/B,IAAAA,yBAAA,MAAI,+BAAkB,eAAa,GAAA;EACrC;EAEA,OAAO,aAAqB,eAAqB;AAC/C,oBAAe,MAAM,aAAa,aAAa;AAC/C,IAAAA,yBAAA,MAAI,6BAAgB,aAAW,GAAA;AAC/B,IAAAA,yBAAA,MAAI,+BAAkB,eAAa,GAAA;EACrC;;;;;AC7KI,SAAU,gBAAgB,kBAA0B,WAA4B,UAA+B;AACnH,wBAAsB,gBAAgB;AACtC,wBAAsB,SAAS,eAAe;AAC9C,qBAAmB,SAAS,WAAW;AACvC,qBAAmB,SAAS,KAAK;AAEjC,MAAI,OAAO,cAAc,YAAY,OAAO,cAAc,UAAU;AAClE,UAAM,IAAI,WAAW,+DAA+D,OAAO,SAAS,UAAU;EAChH;AAEA,MAAI,OAAO,cAAc,UAAU;AACjC,sBAAkB,WAAW,oBAAoB;EACnD;AACF;AAEM,SAAU,eAAe,kBAAwB;AACrD,wBAAsB,gBAAgB;AACxC;AAEM,SAAU,qBAAqB,OAAmB;AACtD,SAAO,GAAG,MAAM,SAAS,WAAW,IAAI,MAAM,SAAS,KAAK,IAAI,MAAM,SAAS,eAAe,IAAI,MAAM,YAAY;AACtH;AAEM,SAAU,qBAAqB,KAAW;AAC9C,QAAM,WAAW,IAAI,MAAM,GAAG;AAC9B,SAAO;IACL,cAAc,SAAS,CAAC;IACxB,UAAU;MACR,aAAa,OAAO,SAAS,SAAS,CAAC,CAAC;MACxC,OAAO,OAAO,SAAS,SAAS,CAAC,CAAC;MAClC,iBAAiB,SAAS,CAAC;;;AAGjC;;;;;;;;;;;;;;;;;;AChCA,IAAM,aAAsB;AAEtB,IAAO,aAAP,MAAiB;EAMrB,cAAA;AALA,4CAAA,IAAA,MAAA,MAAA;AACA,wBAAA,IAAA,MAAA,MAAA;AACA,8BAAA,IAAA,MAAyB,CAAC;AAC1B,gCAAA,IAAA,MAA2B,EAAE;EAEP;EAEtB,UAAO;;AACL,IAAAE,yBAAA,MAAA,4BAAA,KAAAC,yBAAA,MAAA,2BAAA,GAAA,GAAA,MAAqB,KAAA,GAAA;EACvB;EAEA,IAAI,gBAAa;AACf,WAAOA,yBAAA,MAAI,2BAAA,GAAA;EACb;EAEA,IAAI,kBAAe;AACjB,WAAOA,yBAAA,MAAI,6BAAA,GAAA;EACb;EAEA,IAAI,eAAY;AACd,QAAI,CAACA,yBAAA,MAAI,yCAAA,GAAA,GAA+B;AACtC,YAAM,IAAI,WAAW,6BAA6B;IACpD;AACA,WAAOA,yBAAA,MAAI,yCAAA,GAAA,EAA8B;EAC3C;EAEQ,OAAI;AACV,QAAI,CAACA,yBAAA,MAAI,yCAAA,GAAA,GAA+B;AACtC,YAAM,IAAI,WAAW,6BAA6B;IACpD;AACA,WAAOA,yBAAA,MAAI,yCAAA,GAAA;EACb;EAEO,MAAM,KAAK,iBAAuB;AACvC,QAAIA,yBAAA,MAAI,yCAAA,GAAA,GAA+B;AACrC,YAAM,IAAI,WAAW,6BAA6B;IACpD;AACA,IAAAD,yBAAA,MAAI,6BAAoB,iBAAe,GAAA;AACvC,IAAAA,yBAAA,MAAI,qBAAY,IAAI,eAAe,eAAe,GAAC,GAAA;AACnD,IAAAA,yBAAA,MAAI,yCAAgC,oBAAI,IAAG,GAAE,GAAA;AAC7C,WAAO;EACT;;;;EAKO,MAAM,QAAK;AAChB,SAAK,KAAI,EAAG,MAAK;EACnB;EAEQ,MAAM,qBACZ,kBACA,sBACA,UACA,SAA+B;AAE/B,QAAI,CAACC,yBAAA,MAAI,qBAAA,GAAA,GAAW;AAClB,YAAM,IAAI,WAAW,6BAA6B;IACpD;AACA,UAAM,MAA2B,KAAK,KAAI;AAC1C,QAAI,YAAY;AACd,WAAI,mCAAS,aAAY,MAAM;AAC7B,YAAI,IAAI,IAAI,gBAAgB,GAAG;AAC7B,gBAAM,IAAI,WAAW,UAAU,gBAAgB,kBAAkB;QACnE;MACF;IACF;AAEA,QAAI,OAAO,yBAAyB,UAAU;AAC5C,6BAAuB,qBAAqB,SAAQ;IACtD;AAEA,UAAM,WAAW,qBAAqB,EAAE,cAAc,sBAAsB,SAAQ,CAAE;AAEtF,QAAI,IAAI,kBAAkB,QAAQ;AAElC,QAAI,SAAS,oBAAoB,eAAQ,UAAU;AACjD,UAAI,YAAY;AAEd,QAAAA,yBAAA,MAAI,qBAAA,GAAA,EAAU,cAAc,SAAS,aAAa,SAAS,KAAK;MAClE,OAAO;AACL,QAAAA,yBAAA,MAAI,qBAAA,GAAA,EAAU,OAAO,SAAS,aAAa,SAAS,KAAK;MAC3D;IACF;EAGF;EAEQ,MAAM,oBAAoB,kBAAwB;AACxD,UAAM,MAA2B,KAAK,KAAI;AAE1C,UAAM,WAAW,IAAI,IAAI,gBAAgB;AACzC,QAAI,aAAa,QAAW;AAC1B,YAAM,IAAI,WAAW,UAAU,gBAAgB,kBAAkB;IACnE;AAEA,WAAO,qBAAqB,QAAQ;EACtC;EAEO,MAAM,oBACX,kBACA,WACA,UACA,SAA+B;AAE/B,oBAAgB,kBAAkB,WAAW,QAAQ;AACrD,UAAM,KAAK,qBAAqB,kBAAkB,WAAW,UAAU,OAAO;EAChF;EAEA,MAAM,mBAAmB,kBAAwB;AAC/C,mBAAe,gBAAgB;AAC/B,WAAO,MAAM,KAAK,oBAAoB,gBAAgB;EACxD;EAEO,MAAM,uBACX,kBACA,WACA,UACA,SAEC;AAED,oBAAgB,kBAAkB,WAAW,QAAQ;AACrD,QAAI;AACF,YAAM,KAAK,qBAAqB,kBAAkB,WAAW,UAAU,OAAO;AAC9E,aAAO;IACT,QAAQ;AACN,aAAO;IACT;EACF;EAEO,MAAM,sBAAsB,kBAAwB;AACzD,mBAAe,gBAAgB;AAC/B,QAAI;AACF,aAAO,MAAM,KAAK,oBAAoB,gBAAgB;IACxD,QAAQ;AACN,aAAO;IACT;EACF;;;;;;;;;;;;;;;;;;AC7IF,IAAY;CAAZ,SAAYC,gBAAa;AACvB,EAAAA,eAAAA,eAAA,QAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,QAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,QAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,QAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,QAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,WAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,UAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,WAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,QAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,QAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,kBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,gBAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,eAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,SAAA,IAAA,EAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,gBAAA,IAAA,EAAA,IAAA;AACF,GA7BY,kBAAA,gBAAa,CAAA,EAAA;AA+BnB,IAAO,mBAAP,MAAuB;EAI3B,YAAY,YAAoB,SAAe;AAH/C,iCAAA,IAAA,MAAA,MAAA;AACA,8BAAA,IAAA,MAAA,MAAA;AAGE,QAAI,CAAC,eAAQ,UAAU,UAAU,GAAG;AAClC,YAAM,IAAI,WAAW,qBAAqB;IAC5C;AACA,QAAI,OAAO,YAAY,UAAU;AAC/B,YAAM,IAAI,WAAW,iBAAiB;IACxC;AACA,IAAAC,yBAAA,MAAI,8BAAe,YAAU,GAAA;AAC7B,IAAAA,yBAAA,MAAI,2BAAY,SAAO,GAAA;EACzB;EACO,OAAO,eAAuB,eAAuB,QAAe;AACzE,WAAO,wBACL,cAAc,QACd,eACA,eACA,QACAC,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,OAAO,eAAuB,eAAuB,QAAe;AACzE,WAAO,wBACL,cAAc,QACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,OAAO,eAAuB,eAAuB,QAAe;AACzE,WAAO,wBACL,cAAc,QACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,OAAO,eAAuB,eAAuB,QAAe;AACzE,WAAO,wBACL,cAAc,QACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,OAAO,eAAuB,eAAuB,QAAe;AACzE,WAAO,wBACL,cAAc,QACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,UAAU,eAAuB,eAAuB,QAAe;AAC5E,WAAO,sBACL,cAAc,WACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,SAAS,eAAuB,eAAuB,QAAe;AAC3E,WAAO,sBACL,cAAc,UACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,UAAU,eAAuB,eAAuB,QAAe;AAC5E,WAAO,sBACL,cAAc,WACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,OAAO,eAAuB,eAAuB,QAAe;AACzE,WAAO,sBACL,cAAc,QACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,OAAO,eAAuB,eAAuB,QAAe;AACzE,WAAO,sBACL,cAAc,QACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,QAAQ,eAAuB,eAAuB,QAAe;AAC1E,WAAO,sBACL,cAAc,SACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,QAAQ,eAAuB,eAAuB,QAAe;AAC1E,WAAO,sBACL,cAAc,SACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,MAAM,eAAuB,eAAuB,QAAe;AACxE,WAAO,sBACL,cAAc,OACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,MAAM,eAAuB,eAAuB,QAAe;AACxE,WAAO,sBACL,cAAc,OACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,MAAM,eAAuB,eAAuB,QAAe;AACxE,WAAO,sBACL,cAAc,OACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,MAAM,eAAuB,eAAuB,QAAe;AACxE,WAAO,sBACL,cAAc,OACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,MAAM,eAAuB,eAAuB,QAAe;AACxE,WAAO,sBACL,cAAc,OACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;EACO,MAAM,eAAuB,eAAuB,QAAe;AACxE,WAAO,sBACL,cAAc,OACd,eACA,eACA,QACAA,yBAAA,MAAI,8BAAA,GAAA,GACJA,yBAAA,MAAI,2BAAA,GAAA,CAAS;EAEjB;;;AAuBF,SAAS,2BAA2B,WAAmB,YAAqB,SAAe;AACzF,MAAI,SAAiB,YAAY;AACjC,WAAS,SAAU,SAAS;AAC5B,WAAS,SAAU,WAAW;AAC9B,WAAS,SAAU,OAAO,UAAU,KAAK;AACzC,WAAS,SAAS,OAAO,kBAAU,oBAAoB;AACvD,SAAO;AACT;AAEM,SAAU,qBACd,IACA,KACA,KACA,QACA,MACA,YACA,SAAe;AAEf,MAAI,OAAO,WAAW,WAAW;AAC/B,aAAS,SAAS,SAAS;EAC7B;AACA,QAAM,MAAM,eAAQ,eAClB,CAAC,SAAS,WAAW,WAAW,UAAU,WAAW,SAAS,GAC9D,CAAC,IAAI,KAAK,KAAK,QAAQ,YAAY,OAAO,CAAC;AAE7C,QAAM,YAAY,OAAO,eAAQ,UAAU,GAAG,CAAC;AAC/C,SAAO,eAAQ,QAAQ,2BAA2B,WAAW,MAAM,OAAO,OAAO,CAAC,CAAC;AACrF;AAEM,SAAU,wBACd,IACA,KACA,KACA,QACA,YACA,SAAe;AAEf,QAAM,YAAY,YAAY,eAAe,GAAG;AAChD,SAAO,qBAAqB,IAAI,KAAK,KAAK,QAAQ,UAAU,SAAS,YAAY,OAAO;AAC1F;AAEM,SAAU,sBACd,IACA,KACA,KACA,QACA,YACA,SAAe;AAEf,QAAM,YAAY,YAAY,eAAe,GAAG;AAChD,SAAO,qBAAqB,IAAI,KAAK,KAAK,QAAQ,UAAU,SAAS,YAAY,OAAO;AAC1F;AAEM,SAAU,sBACd,IACA,KACA,KACA,QACA,YACA,SAAe;AAEf,SAAO,qBAAqB,IAAI,KAAK,KAAK,QAAQ,QAAQ,MAAM,YAAY,OAAO;AACrF;;;AC7QM,SAAU,uBAAuB,OAAc;AACnD,SACE,UAAU,sBACV,UAAU,oBACV,UAAU,yBACV,UAAU,YACV,UAAU,YACV,UAAU,YACV,UAAU,YACV,UAAU,YACV,UAAU,eACV,UAAU,cACV,UAAU,eACV,UAAU,YACV,UAAU,YACV,UAAU,aACV,UAAU,aACV,UAAU,WACV,UAAU,gBACV,UAAU,WACV,UAAU,gBACV,UAAU,WACV,UAAU,WACV,UAAU,WACV,UAAU,WACV,UAAU,YACV,UAAU,YACV,UAAU,aACV,UAAU,oBACV,UAAU,YACV,UAAU,YACV,UAAU,UACV,UAAU;AAEd;;;AC1EA,eAAsB,qBACpB,8BACA,4BACA,kBACA,SAIC;AAED,MAAI,qBAA6B;AACjC,MAAI;AAEJ,MAAI,QAAQ,kBAAkB,QAAW;AACvC,cAAU,QAAQ;EACpB,OAAO;AACL,yBAAqB,MAAM,iBAAiB,eAAc;AAC1D,cAAU;EACZ;AAEA,MAAI;AACJ,MAAI,QAAQ,oBAAoB,QAAW;AACzC,gBAAY,QAAQ;EACtB,OAAO;AACL,gBAAY;EACd;AAEA,MAAI,YAAY,SAAS;AACvB,UAAM,IAAI,WAAW,kCAAkC,SAAS,YAAY,OAAO,EAAE;EACvF;AAGA,QAAM,SAAS;IACb,SAAS;IACT;IACA;;AAGF,QAAM,OAAO,MAAM,iBAAiB,QAAQ,MAAM;AAElD,QAAM,SAAS,IAAI,eAAe,EAAE;AACpC,QAAM,SAA6B,KAChC,IAAI,CAAC,QAAO;AACX,QAAI;AACF,aAAO,cAAc,IAAI,aAAa,IAAI,KAAK;AAE/C,YAAM,YAAY,6BAA6B,SAAS,GAAG;AAE3D,UAAI,IAAI,gBAAgB,WAAW;AACjC,YAAI,QAAQ,sBAAsB,QAAW;AAC3C,cAAI,IAAI,QAAQ,QAAQ,mBAAmB;AACzC,mBAAO;UACT;QACF;MACF;AAEA,UAAI,CAAC,uBAAuB,UAAU,IAAI,GAAG;AAC3C,eAAO;MACT;AAEA,YAAM,MAAwB;QAC5B,WAAW,UAAU;QACrB,MAAM,UAAU;QAChB,OAAO,IAAI;QACX,aAAa,IAAI;QACjB,iBAAiB,IAAI;QACrB,kBAAkB,IAAI;;AAGxB,aAAO;IACT,QAAQ;AAEN,aAAO;IACT;EACF,CAAC,EACA,OAAO,CAAC,UAAU,UAAU,IAAI;AAEnC,SAAO,EAAE,QAAQ,OAAM;AACzB;AAEM,SAAU,+BACd,MAA2D;AAG3D,MAAI,CAAC,MAAM;AACT,WAAO,CAAA;EACT;AAEA,QAAM,SAA6B,CAAA;AACnC,aAAW,OAAO,MAAM;AACtB,UAAM,QAAuC,8BAA8B,SAAS,GAAG;AAEvF,QAAI,CAAC,OAAO;AACV;IACF;AACA,QAAI,CAAC,uBAAuB,MAAM,IAAI,GAAG;AACvC;IACF;AAEA,UAAM,KAAuB;MAC3B,WAAW,MAAM;MACjB,MAAM,MAAM;MACZ,aAAa,IAAI;MACjB,OAAO,IAAI;MACX,iBAAiB,IAAI;MACrB,kBAAkB,IAAI;;AAGxB,WAAO,KAAK,EAAE;EAChB;AAEA,SAAO;AACT;;;AC9GA,eAAsB,cAAc,UAAyB;AAC3D,SAAO,oBAAoB,UAAU,kBAAkB,CAAA,CAAE;AAC3D;AAaA,eAAsB,gBACpB,UAAyB;AAMzB,MAAI;AACF,UAAM,WAAW,MAAM,cAAc,QAAQ;AAC7C,QAAI,EAAE,iBAAiB,WAAW;AAChC,aAAO,EAAE,SAAS,OAAO,iBAAiB,MAAK;IACjD;AACA,UAAM,MAAM,SAAS;AACrB,QAAI,EAAE,aAAa,MAAM;AACvB,aAAO,EAAE,SAAS,OAAO,iBAAiB,MAAK;IACjD;AACA,WAAO,EAAE,SAAS,MAAM,SAAS,OAAO,OAAO,IAAI,OAAO,CAAC,GAAG,iBAAiB,MAAK;EACtF,SAAS,GAAG;AACV,QAAI,uBAAuB,CAAC,GAAG;AAE7B,UAAI,EAAE,SAAS,UAAU,EAAE,SAAS,QAAQ;AAC1C,eAAO,EAAE,SAAS,OAAO,iBAAiB,MAAK;MACjD;IACF,WAAW,eAAe,CAAC,GAAG;AAE5B,UAAI,EAAE,WAAW,KAAK;AACpB,eAAO,EAAE,iBAAiB,KAAI;MAChC;IACF,WAAW,cAAa,GAAI;AAC1B,UAAI,aAAa,SAAS,UAAU,GAAG;AAErC,YAAI,EAAE,SAAS,gBAAgB;AAC7B,iBAAO,EAAE,iBAAiB,KAAI;QAChC;MACF;IACF;AAGA,UAAM;EACR;AACF;;;ACjDA,eAAsB,kBACpB,UAAyB;AAMzB,MAAI;AACF,UAAM,WAAW,MAAM,oBAAoB,UAAU,oBAAoB,CAAA,CAAE;AAC3E,QAAI,EAAE,aAAa,aAAa,SAAS,YAAY,OAAO;AAC1D,aAAO,EAAE,iBAAiB,OAAO,WAAW,MAAK;IACnD;AACA,QAAI,EAAE,gBAAgB,aAAa,SAAS,WAAW,WAAW,IAAI;AACpE,aAAO,EAAE,iBAAiB,OAAO,WAAW,MAAK;IACnD;AACA,WAAO,EAAE,iBAAiB,OAAO,WAAW,MAAM,SAAS,OAAO,OAAO,SAAS,OAAO,CAAC,EAAC;EAC7F,SAAS,GAAG;AACV,QAAI,uBAAuB,CAAC,GAAG;AAE7B,UAAI,EAAE,SAAS,UAAU,EAAE,SAAS,QAAQ;AAC1C,eAAO,EAAE,iBAAiB,OAAO,WAAW,MAAK;MACnD;IACF,WAAW,eAAe,CAAC,GAAG;AAE5B,UAAI,EAAE,WAAW,KAAK;AACpB,eAAO,EAAE,iBAAiB,KAAI;MAChC;IACF,WAAW,cAAa,GAAI;AAC1B,UAAI,aAAa,SAAS,UAAU,GAAG;AAErC,YAAI,EAAE,SAAS,gBAAgB;AAC7B,iBAAO,EAAE,iBAAiB,KAAI;QAChC;MACF;IACF;AAGA,UAAM;EACR;AACF;;;;;;;;;;;;;;;;;;;AC3CA,IAAY;CAAZ,SAAYC,wBAAqB;AAC/B,EAAAA,uBAAAA,uBAAA,SAAA,IAAA,CAAA,IAAA;AACA,EAAAA,uBAAAA,uBAAA,SAAA,IAAA,CAAA,IAAA;AACA,EAAAA,uBAAAA,uBAAA,aAAA,IAAA,CAAA,IAAA;AACA,EAAAA,uBAAAA,uBAAA,OAAA,IAAA,CAAA,IAAA;AACA,EAAAA,uBAAAA,uBAAA,iBAAA,IAAA,CAAA,IAAA;AACF,GANY,0BAAA,wBAAqB,CAAA,EAAA;AAQjC,SAAS,8BAA8B,OAA4B;AACjE,UAAQ,OAAO;IACb,KAAK,sBAAsB;AACzB,aAAO;IACT,KAAK,sBAAsB;AACzB,aAAO;IACT,KAAK,sBAAsB;AACzB,aAAO;IACT,KAAK,sBAAsB;AACzB,aAAO;IACT,KAAK,sBAAsB;AACzB,aAAO;EACX;AACF;AAkBM,IAAO,oBAAP,MAAO,mBAAiB;EAA9B,cAAA;AACE,uCAAA,IAAA,MAAA,MAAA;AACA,8CAAA,IAAA,MAAA,MAAA;AACA,4BAAA,IAAA,MAAA,MAAA;AACA,0CAAA,IAAA,MAAA,MAAA;AACA,iCAAA,IAAA,MAAA,MAAA;EAkPF;EAhPS,aAAa,qBAClB,kBACA,aACA,qBACA,gBACA,KAAuB;AAEvB,WAAO,mBAAkB,OACvB,kBACA,kBACA,aACA,qBACA,gBACA,GAAG;EAEP;EAEO,aAAa,OAClB,iBACA,wBACA,aACA,qBACA,gBACA,KAAuB;AAEvB,UAAM,OAAO,MAAM,qBAAqB,iBAAiB,aAAa,qBAAqB,gBAAgB,GAAG;AAC9G,UAAM,IAAI,IAAI,mBAAiB;AAC/B,IAAAC,yBAAA,GAAC,oCAAoB,iBAAe,GAAA;AACpC,IAAAA,yBAAA,GAAC,yBAAS,MAAI,GAAA;AAEd,QAAI,2BAA2B,UAAa,KAAK,QAAQ,QAAW;AAGlE,+BAAyB,IAAI,gBAAgB,KAAK,GAAG;IACvD;AAEA,IAAAA,yBAAA,GAAC,2CAA2B,wBAAsB,GAAA;AAElD,WAAO;EACT;EAEO,aAAa,WAAoC;AACtD,gBAAY,OAAO,cAAc,UAAU;AAC3C,IAAAA,yBAAA,MAAI,8BAAc,WAAS,GAAA;EAC7B;;;;EAMA,IAAW,yBAAsB;AAE/B,QAAI,CAACC,yBAAA,MAAI,oCAAA,GAAA,GAAmB;AAC1B,YAAM,IAAI,WAAW,oDAAoD;IAC3E;AACA,QAAI,CAACA,yBAAA,MAAI,2CAAA,GAAA,GAA0B;AACjC,YAAM,IAAI,WAAW,yFAAyF;IAChH;AACA,WAAOA,yBAAA,MAAI,2CAAA,GAAA;EACb;EAEA,IAAW,kBAAe;AACxB,QAAI,CAACA,yBAAA,MAAI,oCAAA,GAAA,GAAmB;AAC1B,YAAM,IAAI,WAAW,oDAAoD;IAC3E;AACA,WAAOA,yBAAA,MAAI,oCAAA,GAAA;EACb;EAEA,IAAW,OAAI;AACb,QAAI,CAACA,yBAAA,MAAI,yBAAA,GAAA,GAAQ;AACf,YAAM,IAAI,WAAW,oDAAoD;IAC3E;AACA,WAAOA,yBAAA,MAAI,yBAAA,GAAA;EACb;EAEA,IAAW,SAAM;AACf,QAAI,CAACA,yBAAA,MAAI,yBAAA,GAAA,GAAQ;AACf,YAAM,IAAI,WAAW,oDAAoD;IAC3E;AACA,WACEA,yBAAA,MAAI,yBAAA,GAAA,EAAO,SAAS,sBAAsB,WAC1CA,yBAAA,MAAI,yBAAA,GAAA,EAAO,SAAS,sBAAsB,eAC1CA,yBAAA,MAAI,yBAAA,GAAA,EAAO,SAAS,sBAAsB;EAE9C;EAEA,IAAW,oBAAiB;AAC1B,QAAI,CAACA,yBAAA,MAAI,yBAAA,GAAA,GAAQ;AACf,YAAM,IAAI,WAAW,oDAAoD;IAC3E;AACA,WAAOA,yBAAA,MAAI,yBAAA,GAAA,EAAO,SAAS,sBAAsB;EACnD;EAEA,IAAW,sBAAmB;AAC5B,QAAI,CAACA,yBAAA,MAAI,yBAAA,GAAA,GAAQ;AACf,YAAM,IAAI,WAAW,oDAAoD;IAC3E;AACA,WAAOA,yBAAA,MAAI,yBAAA,GAAA,EAAO,SAAS,sBAAsB,WAAWA,yBAAA,MAAI,yBAAA,GAAA,EAAO,SAAS,sBAAsB;EACxG;EAEA,IAAW,UAAO;AAChB,WAAO,KAAK,KAAK;EACnB;EAEO,MAAM,gCAAgC,SAAiB,SAAe;AAC3E,QAAI,CAAC,KAAK,KAAK,QAAQ,oBAAoB;AACzC,YAAM,IAAI,WAAW,WAAW,KAAK,KAAK,WAAW,yCAAyC;IAChG;AACA,QAAI,CAAC,KAAK,KAAK,QAAQ,YAAY;AACjC,YAAM,IAAI,WAAW,WAAW,KAAK,KAAK,WAAW,sCAAsC;IAC7F;AACA,QAAI,KAAK,KAAK,SAAS,sBAAsB,OAAO;AAClD,UAAI,CAAC,KAAK,KAAK,KAAK;AAClB,cAAM,IAAI,WAAW,mDAAmD;MAC1E;IACF;AAOA,UAAM,KAAK,KAAK,KAAK,KAAK,QAAQ,oBAAoB,CAAC,OAAO,CAAC;AAC/D,UAAM,KAAK,KAAK,KAAK,KAAK,QAAQ,YAAY,CAAC,SAAS,eAAQ,QAAQ,OAAO,CAAC,CAAC;AAEjF,QAAI,KAAK,KAAK,SAAS,sBAAsB,OAAO;AAClD,YAAM,kBAAkB,IAAI,eAAQ,gBAAgB,KAAK,KAAK,GAAG;AAKjE,sBAAgB,kBAAkB;AAClC,aAAO,MAAM,gBAAgB,UAAU,OAAO;IAChD,WAAW,KAAK,qBAAqB;AAInC,aAAO;IACT,OAAO;AACL,YAAM,IAAI,WAAW,WAAW,KAAK,KAAK,WAAW,yCAAyC;IAChG;EACF;EAEO,MAAM,UAAU,SAAiB,UAAgB;AACtD,UAAM,aAAa,KAAK,KAAK,QAAQ;AACrC,QAAI,CAAC,YAAY;AACf,YAAM,IAAI,WAAW,WAAW,KAAK,KAAK,WAAW,qCAAqC;IAC5F;AACA,QAAI,OAAO,aAAa,UAAU;AAChC,YAAM,IAAI,WAAW,4BAA4B;IACnD;AAEA,UAAM,KAAK,KAAK,YAAY,CAAC,SAAS,QAAQ,CAAC;EACjD;EAEO,KAAK,QAAgB,QAAc;AACxC,WAAO,oBAAoB,KAAK,iBAAiB,QAAQ,UAAU,CAAA,CAAE;EACvE;EAEO,MAAM,UAAU,SAAe;AACpC,UAAM,WAAW,MAAM,KAAK,KAAK,eAAe,CAAC,SAAS,QAAQ,CAAC;AAEnE,QAAI,OAAO,aAAa,UAAU;AAChC,YAAM,IAAI,WAAW,6CAA6C;IACpE;AAEA,WAAO;EACT;EAEO,MAAM,iBAAc;AACzB,UAAM,cAAc,MAAM,KAAK,KAAK,iBAAiB;AACrD,WAAO,OAAO,WAAW;EAC3B;EAEO,MAAM,qCAAkC;AAC7C,QAAI,CAACA,yBAAA,MAAI,uCAAA,GAAA,GAAsB;AAC7B;IACF;AAEA,QAAI;AACF,YAAM,KAAK,iBAAiBA,yBAAA,MAAI,uCAAA,GAAA,CAAoB;IACtD;AACE,MAAAD,yBAAA,MAAI,uCAAuB,QAAS,GAAA;IACtC;EACF;EAEO,MAAM,iCAAiC,kBAAwB;AACpE,QAAIC,yBAAA,MAAI,uCAAA,GAAA,GAAsB;AAC5B,YAAM,IAAI,WAAW,mDAAmD;IAC1E;AAEA,UAAM,uBAAuB,MAAM,KAAK,iBAAgB;AAExD,QAAI,CAAC,sBAAsB;AACzB,WAAK,OAAO,0CAA0C;AACtD,aAAO;IACT;AAEA,QAAI,oBAAoB,sBAAsB;AAC5C,aAAO;IACT;AAEA,SAAK,OACH,8BAA8B,gBAAgB,yCAAyC,oBAAoB,EAAE;AAG/G,UAAM,KAAK,iBAAiB,gBAAgB;AAE5C,IAAAD,yBAAA,MAAI,uCAAuB,sBAAoB,GAAA;EACjD;EAEO,MAAM,iBAAiB,eAAqB;AACjD,UAAM,mBAAmB,OAAO,cAAc,SAAS,EAAE;AAEzD,UAAM,KAAK,KAAK,wBAAwB,CAAC,gBAAgB,CAAC;AAE1D,SAAK,OAAO,6BAA6B,aAAa,EAAE;EAC1D;EAEO,MAAM,mBAAgB;AAC3B,UAAM,MAAM,MAAM,KAAK,KAAK,wBAAwB,CAAC,UAAU,KAAK,CAAC;AACrE,QAAI,CAAC,KAAK;AACR,aAAO;IACT;AACA,QAAI,EAAE,cAAc,MAAM;AACxB,aAAO;IACT;AAEA,QAAI;AACF,aAAO,OAAO,IAAI,QAAQ;IAC5B,QAAQ;AACN,aAAO;IACT;EACF;EAEQ,OAAO,SAAe;AAC5B,QAAIC,yBAAA,MAAI,8BAAA,GAAA,GAAa;AACnB,MAAAA,yBAAA,MAAI,8BAAA,GAAA,EAAW,KAAf,MAAgB,OAAO;IACzB;EACF;;;AAGF,eAAe,qBACb,iBACA,aACA,qBACA,gBACA,KAAY;AAEZ,iBAAe,aAAa,aAAa;AAEzC,MACE,gBAAgB,aAChB,gBAAgB,eAChB,mBAAmB,kBAAU,kCAC7B;AACA,gBAAY,QAAQ,QAAW,qBAAqB;AACpD,WAAO;MACL,MAAM,sBAAsB;MAC5B,SAAS,kBAAU;MACnB,SAAS,CAAA;MACT;MACA;MACA,mBAAmB;;EAEvB;AAEA,QAAM,IAAI,MAAM,iBAAiB,iBAAiB,qBAAqB,gBAAgB,GAAG;AAC1F,UAAQ,EAAE,MAAM;IACd,KAAK,sBAAsB,SAAS;AAClC,aAAO;QACL,MAAM,EAAE;QACR,SAAS,EAAE;QACX,SAAS,CAAA;QACT;QACA;QACA,mBAAmB,EAAE;;IAEzB;IACA,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB,aAAa;AACtC,aAAO;QACL,MAAM,EAAE;QACR,SAAS,EAAE;QACX,SAAS;UACP,YAAY;UACZ,SAAS;UACT,oBAAoB;;QAEtB;QACA;QACA,mBAAmB,EAAE;;IAEzB;IACA,KAAK,sBAAsB,OAAO;AAChC,aAAO;QACL,MAAM,EAAE;QACR,SAAS,EAAE;QACX,SAAS;UACP,YAAY;UACZ,SAAS;UACT,oBAAoB;;QAEtB;QACA;QACA,mBAAmB,EAAE;;IAEzB;IACA,SAAS;AACP,YAAM,IAAI,WAAW,gDAAgD,EAAE,IAAI,GAAG;IAChF;EACF;AACF;AAEA,eAAe,iBACb,iBACA,qBACA,gBACA,KAAY;AAEZ,MAAI,CAAC,KAAK;AACR,QAAI,wBAAwB,sBAAsB,SAAS;AACzD,YAAM,IAAI,WAAW,sBAAsB;IAC7C,OAAO;AACL,UAAI,mBAAmB,OAAO;AAC5B,cAAM,IAAI,WAAW,uDAAuD,cAAc,YAAY;MACxG;IACF;EACF,OAAO;AACL,QAAI,CAAC,IAAI,SAAS,GAAG,GAAG;AACtB,YAAM,IAAI,WAAW,yBAAyB,GAAG,GAAG;IACtD;EACF;AAEA,QAAM,YAAY,MAAM,oBAAoB,eAAe;AAG3D,QAAM,WAAW,MAAM,gBAAgB,eAAe;AACtD,MAAI,CAAC,SAAS,iBAAiB;AAC7B,QAAI,SAAS,SAAS;AACpB,UAAI,wBAAwB,UAAa,wBAAwB,sBAAsB,OAAO;AAC5F,cAAM,IAAI,WACR,qCAAqC,8BAA8B,mBAAmB,CAAC,SAAS,8BAA8B,sBAAsB,KAAK,CAAC,UAAU;MAExK;AAEA,UAAI,mBAAmB,UAAa,mBAAmB,SAAS,SAAS;AACvE,cAAM,IAAI,WACR,6CAA6C,cAAc,SAAS,SAAS,OAAO,UAAU;MAElG;AAEA,UAAI,CAAC,UAAU,QAAQ;AACrB,cAAM,IAAI,WAAW,+CAA+C;MACtE;AAEA,aAAO;QACL,MAAM,sBAAsB;QAC5B,SAAS,SAAS;QAClB,mBAAmB,UAAU;;IAEjC;EAEF;AAGA,QAAM,QAAQ,MAAM,kBAAkB,eAAe;AACrD,MAAI,CAAC,MAAM,iBAAiB;AAC1B,QAAI,MAAM,WAAW;AACnB,YAAM,eAAe,QAAQ,SAAY,sBAAsB,cAAc,sBAAsB;AAEnG,UAAI,wBAAwB,UAAa,wBAAwB,cAAc;AAC7E,cAAM,IAAI,WACR,qCAAqC,8BAA8B,mBAAmB,CAAC,SAAS,8BAA8B,YAAY,CAAC,UAAU;MAEzJ;AAEA,UAAI,mBAAmB,UAAa,mBAAmB,MAAM,SAAS;AACpE,cAAM,IAAI,WACR,+CAA+C,cAAc,SAAS,MAAM,OAAO,UAAU;MAEjG;AAEA,UAAI,CAAC,UAAU,QAAQ;AACrB,cAAM,IAAI,WAAW,iDAAiD;MACxE;AAEA,aAAO;QACL,MAAM;QACN,SAAS,MAAM;QACf,mBAAmB,UAAU;;IAEjC;EAEF;AAOA,MAAI,CAAC,UAAU,iBAAiB;AAC9B,UAAM,UAAU,MAAM,iBAAiB,eAAe;AACtD,QAAI,YAAY,QAAW;AACzB,YAAM,IAAI,WAAW,mCAAmC;IAC1D;AAEA,QAAI,wBAAwB,UAAa,wBAAwB,sBAAsB,SAAS;AAC9F,YAAM,IAAI,WACR,qCAAqC,8BAA8B,mBAAmB,CAAC,SAAS,8BAA8B,sBAAsB,OAAO,CAAC,UAAU;IAE1K;AAEA,QAAI,mBAAmB,UAAa,mBAAmB,SAAS;AAC9D,YAAM,IAAI,WAAW,gDAAgD,cAAc,SAAS,OAAO,UAAU;IAC/G;AAEA,QAAI,CAAC,UAAU,QAAQ;AACrB,YAAM,IAAI,WAAW,kDAAkD;IACzE;AAEA,WAAO,EAAE,MAAM,sBAAsB,SAAS,SAAS,mBAAmB,UAAU,OAAM;EAC5F;AAEA,MAAI,wBAAwB,QAAW;AACrC,UAAM,IAAI,WAAW,yDAAyD;EAChF;AAEA,MAAI,mBAAmB,QAAW;AAChC,UAAM,IAAI,WAAW,4DAA4D;EACnF;AAEA,SAAO,EAAE,MAAM,qBAAqB,SAAS,gBAAgB,mBAAmB,OAAS;AAC3F;;;;;;;;;;;;;;;;AC1dM,IAAO,2BAAP,MAA+B;EAInC,YAAY,IAAW;AAHvB,iCAAA,IAAA,MAAA,MAAA;AACA,0CAAA,IAAA,MAAA,MAAA;AAGE,IAAAC,yBAAA,MAAI,8BAAO,IAAE,GAAA;AACb,IAAAA,yBAAA,MAAI,uCAAgB,GAAC,GAAA;EACvB;EAEA,IAAW,cAAW;AACpB,WAAOC,yBAAA,MAAI,uCAAA,GAAA;EACb;EAEO,MAAM,YAAY,kBAAkC;;AAEzD,gBACE,iBAAiB,eAAeA,yBAAA,MAAI,8BAAA,GAAA,EAAK,iBACzC,yDAAyD;AAS3D,QAAI,iBAAiB,cAAc,oBAAoB;AACrD,YAAM,KAAK,iBAAiB,iBAAiB,IAAI;IACnD,OAAO;AACL,YAAM,MAAM,MAAM,KAAK,wBAAwB,gBAAgB;AAC/D,UAAI,KAAK;AACP,cAAMA,yBAAA,MAAI,8BAAA,GAAA,EAAK,oBACb,IAAI,eACJ,IAAI,WACJ;UACE,OAAO,iBAAiB;UACxB,aAAa,iBAAiB;UAC9B,iBAAiB,iBAAiB;WAEpC,IAAI,YAAY,SAAY,EAAE,SAAS,IAAI,QAAO,IAAK,MAAS;AAGlE,YAAI,iBAAiB,cAAc,oBAAoB,iBAAiB,cAAc,WAAW;AAC/F,UAAAD,yBAAA,MAAA,wCAAA,KAAAC,yBAAA,MAAA,uCAAA,GAAA,GAAA,MAAmB,KAAA,GAAA;QACrB;MACF;IACF;EACF;EAEQ,MAAM,wBAAwB,OAAuB;AAQ3D,YAAQ,MAAM,WAAW;MACvB,KAAK,kBAAkB;AAErB,cAAM,YAAoB,MAAM,KAAK,CAA4B;AACjE,cAAM,UAAkB,MAAM,KAAK,CAA4B;AAC/D,cAAM,gBAAwB,MAAM,KAAK,CAA4B;AAErE,mCAA2B,WAAW,kBAAkB,CAAC;AACzD,mCAA2B,SAAS,kBAAkB,CAAC;AACvD,sCAA8B,eAAe,kBAAkB,CAAC;AAEhE,eAAO;UACL;UACA,WAAW;;MAEf;MAEA,KAAK,uBAAuB;AAE1B,cAAM,UAAkB,MAAM,KAAK,CAA4B;AAC/D,cAAM,gBAAwB,MAAM,KAAK,CAA4B;AAErE,oCAA4B,SAAS,uBAAuB,CAAC;AAC7D,sCAA8B,eAAe,kBAAkB,CAAC;AAEhE,eAAO;UACL;UACA,WAAW;;MAEf;MAEA,KAAK,UAAU;AAEb,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,YAAI,YAAoB,SAAS,qBAAqB,SAAS;AAG/D,oBAAY,YAAY,MAAM,SAAS;AAEvC,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,UAAU;AAEb,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,YAAI,YAAoB,SAAS,qBAAqB,SAAS;AAG/D,YAAI,YAAY;AAAI,sBAAY,YAAY,MAAM,SAAS;AAC3D,oBAAY,YAAY,MAAM,SAAS;AAEvC,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,UAAU;AAEb,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,YAAI,YAAoB,SAAS,qBAAqB,SAAS;AAG/D,oBAAY,YAAY,MAAM,SAAS;AAEvC,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,UAAU;AAGb,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AACpD,YAAI,CAAC,SAAS,QAAQ;AACpB,gBAAM,IAAI,MAAM,oCAAoC;QACtD;AAGA,cAAM,YAAoB,SAAS,qBAAqB,SAAS;AAKjE,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,UAAU;AAGb,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AACpD,YAAI,CAAC,SAAS,QAAQ;AACpB,gBAAM,IAAI,MAAM,oCAAoC;QACtD;AAGA,cAAM,YAAoB,SAAS,qBAAqB,SAAS;AAKjE,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,aAAa;AAEhB,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,YAAI,YAAoB,SAAS,qBAAqB,SAAS;AAG/D,oBAAY,YAAY,MAAM,SAAS;AAEvC,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,YAAY;AAEf,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,YAAI,YAAoB,SAAS,qBAAqB,SAAS;AAG/D,oBAAY,YAAY,MAAM,SAAS;AAEvC,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,aAAa;AAEhB,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,YAAI,YAAoB,SAAS,qBAAqB,SAAS;AAG/D,oBAAY,YAAY,MAAM,SAAS;AAEvC,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,UAAU;AAEb,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,YAAI,YACF,SAAS,sBAAsB,SAAS,qBAAqB,SAAS;AAGxE,oBAAY,YAAY,MAAM,SAAS;AAEvC,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,UAAU;AAEb,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,YAAI,YACF,SAAS,sBAAsB,SAAS,qBAAqB,SAAS;AAGxE,oBAAY,YAAY,MAAM,SAAS;AAEvC,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,WAAW;AAEd,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,cAAM,QAAQ,SAAS,qBAAqB,SAAS;AAErD,YAAI,YACD,SAAS,sBAAsB,QAC/B,SAAS,sBAAuB,SAAS,qBAAqB;AAGjE,oBAAY,YAAY,MAAM,SAAS;AAEvC,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,WAAW;AAEd,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,cAAM,QAAQ,SAAS,qBAAqB,SAAS;AAErD,YAAI,YACD,SAAS,sBAAsB,QAC/B,SAAS,sBAAuB,SAAS,qBAAqB;AAGjE,oBAAY,YAAY,MAAM,SAAS;AAEvC,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,SAAS;AAEZ,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,cAAM,YAAY,SAAS,uBAAuB,SAAS,qBAAqB,KAAK;AAErF,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,cAAc;AAEjB,cAAM,WAAW,MAAM,KAAK,wBAAwB,KAAK;AAEzD,cAAM,YAAY,SAAS,uBAAuB,SAAS,qBAAqB,KAAK;AAErF,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,SAAS;AAEZ,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,cAAM,YAAY,SAAS,uBAAuB,SAAS,qBAAqB,KAAK;AAErF,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,cAAc;AAEjB,cAAM,WAAW,MAAM,KAAK,wBAAwB,KAAK;AAEzD,cAAM,YAAY,SAAS,uBAAuB,SAAS,qBAAqB,KAAK;AAErF,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,SAAS;AAEZ,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,cAAM,YAAY,SAAS,sBAAsB,SAAS,qBAAqB,KAAK;AAEpF,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,SAAS;AAEZ,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,cAAM,YAAY,SAAS,qBAAqB,SAAS,qBAAqB,KAAK;AAEnF,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,SAAS;AAEZ,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,cAAM,YAAY,SAAS,sBAAsB,SAAS,qBAAqB,KAAK;AAEpF,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,SAAS;AAEZ,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,cAAM,YAAY,SAAS,qBAAqB,SAAS,qBAAqB,KAAK;AAEnF,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,UAAU;AAEb,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,cAAM,YACJ,SAAS,qBAAqB,SAAS,qBACnC,SAAS,qBACT,SAAS;AAEf,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,UAAU;AAEb,cAAM,WAAW,MAAM,KAAK,mBAAmB,KAAK;AAEpD,cAAM,YACJ,SAAS,qBAAqB,SAAS,qBACnC,SAAS,qBACT,SAAS;AAEf,eAAO;UACL,eAAe,SAAS;UACxB;;MAEJ;MAEA,KAAK,UAAU;AAEb,cAAM,UAAU,MAAM,KAAK,kBAAkB,KAAK;AAElD,cAAM,YAAoB,mBAAmB,QAAQ,iBAAiB,QAAQ,kBAAkB;AAEhG,eAAO;UACL,eAAe,QAAQ;UACvB;;MAEJ;MAEA,KAAK,UAAU;AAEb,cAAM,UAAU,MAAM,KAAK,kBAAkB,KAAK;AAElD,YAAI,YAAoB,mBAAmB,QAAQ,iBAAiB,QAAQ,kBAAkB;AAG9F,qBAAa,YAAY,MAAM,MAAM,QAAQ;AAE7C,eAAO;UACL,eAAe,QAAQ;UACvB;;MAEJ;MAEA,KAAK,QAAQ;AAEX,cAAM,YAAoB,MAAM,KAAK,CAA4B;AACjE,cAAM,cAAsB,MAAM,KAAK,CAA4B;AACnE,cAAM,gBAAwB,MAAM,KAAK,CAA4B;AAErE,sCAA8B,WAAW,MAAM,WAAW,CAAC;AAC3D,iCAAyB,aAAa,MAAM,WAAW,CAAC;AACxD,sCAA8B,eAAe,MAAM,WAAW,CAAC;AAE/D,cAAM,oBAAiC,YAAY,eAAe,aAAa;AAC/E,cAAM,aAAsB,kBAAkB;AAC9C,cAAM,qBAAqB,OAAO,kBAAkB,cAAc,kBAAkB;AAEpF,oBACE,OAAO,UAAU,MAAM,aACvB,mCAAmC,UAAU,sBAAsB,WAAW,GAAG;AAGnF,cAAM,KAAa,QAAQ,MAAMA,yBAAA,MAAI,8BAAA,GAAA,EAAK,mBAAmB,SAAS,GAAG,YAAY;AAErF,cAAM,YAAoB,KAAK,MAAM;AAErC,eAAO;UACL;UACA;;MAEJ;MAEA,KAAK,iBAAiB;AAEpB,cAAM,iBAAyB,MAAM,KAAK,CAA4B;AACtE,cAAM,gBAAwB,MAAM,KAAK,CAA4B;AACrE,cAAM,iBAAyB,MAAM,KAAK,CAA4B;AACtE,cAAM,gBAAwB,MAAM,KAAK,CAA4B;AAErE,sCAA8B,gBAAgB,MAAM,WAAW,CAAC;AAChE,sCAA8B,eAAe,MAAM,WAAW,CAAC;AAC/D,sCAA8B,gBAAgB,MAAM,WAAW,CAAC;AAChE,sCAA8B,eAAe,MAAM,WAAW,CAAC;AAE/D,cAAM,UAAkB,QAAQ,MAAMA,yBAAA,MAAI,8BAAA,GAAA,EAAK,mBAAmB,cAAc,GAAG,YAAY;AAC/F,cAAM,SAAiB,QAAQ,MAAMA,yBAAA,MAAI,8BAAA,GAAA,EAAK,mBAAmB,aAAa,GAAG,YAAY;AAC7F,cAAM,UAAkB,QAAQ,MAAMA,yBAAA,MAAI,8BAAA,GAAA,EAAK,mBAAmB,cAAc,GAAG,YAAY;AAE/F,oBACE,YAAY,MAAM,YAAY,IAC9B,+CAA+C,OAAO,oBAAoB;AAG5E,cAAM,YAAoB,YAAY,KAAK,SAAS;AAEpD,eAAO;UACL;UACA;;MAEJ;MAEA,KAAK,WAAW;AAEd,cAAM,gBAAwB,MAAM,KAAK,CAA4B;AACrE,cAAM,cAAsB,MAAM,KAAK,CAA4B;AACnE,cAAM,gBAAwB,MAAM,KAAK,CAA4B;AAErE,iCAAyB,eAAe,MAAM,WAAW,CAAC;AAC1D,sCAA8B,aAAa,MAAM,WAAW,CAAC;AAC7D,sCAA8B,eAAe,MAAM,WAAW,CAAC;AAE/D,cAAM,oBAAiC,YAAY,eAAe,aAAa;AAC/E,cAAM,aAAsB,kBAAkB;AAC9C,cAAM,qBAAqB,kBAAkB,cAAc;AAE3D,oBACE,OAAO,UAAU,MAAM,eACvB,mCAAmC,UAAU,wBAAwB,aAAa,GAAG;AAIvF,cAAM,YAAoB,gBAAgB,kBAAkB;AAE5D,eAAO;UACL;UACA;UACA,SAAS;;MAEb;MAEA,KAAK,kBAAkB;AAErB,cAAM,oBAA4B,MAAM,KAAK,CAA4B;AACzE,cAAM,gBAAwB,MAAM,KAAK,CAA4B;AACrE,cAAM,cAAsB,MAAM,KAAK,CAA4B;AACnE,cAAM,gBAAwB,MAAM,KAAK,CAA4B;AAErE,mCAA2B,mBAAmB,MAAM,WAAW,CAAC;AAChE,iCAAyB,eAAe,MAAM,WAAW,CAAC;AAC1D,sCAA8B,aAAa,MAAM,WAAW,CAAC;AAC7D,sCAA8B,eAAe,MAAM,WAAW,CAAC;AAE/D,cAAM,oBAAiC,YAAY,eAAe,aAAa;AAC/E,cAAM,aAAsB,kBAAkB;AAE9C,oBACE,OAAO,UAAU,MAAM,eACvB,mCAAmC,UAAU,wBAAwB,aAAa,GAAG;AAGvF,cAAM,YAAoB,gBAAgB,OAAO,WAAW,iBAAiB,CAAC,CAAC;AAE/E,eAAO;UACL;UACA;UACA,SAAS;;MAEb;IACF;AAEA,UAAM,IAAI,WAAW,oCAAoC,MAAM,SAAS,EAAE;EAC5E;EAEQ,MAAM,iBAAiB,WAAiB;AAY9C,UAAM,qBAA6B,UAAU,CAA2B;AACxE,UAAM,cAAsB,UAAU,CAA2B;AACjE,UAAM,kBAA0B,UAAU,CAA2B;AACrE,UAAM,UAAkB,UAAU,CAA2B;AAC7D,UAAM,gBAAwB,UAAU,CAA2B;AAEnE,kCAA8B,oBAAoB,oBAAoB,CAAC;AACvE,4BAAwB,aAAa,oBAAoB,CAAC;AAC1D,gCAA4B,iBAAiB,oBAAoB,CAAC;AAClE,+BAA2B,SAAS,oBAAoB,CAAC;AACzD,kCAA8B,eAAe,oBAAoB,CAAC;AAIlE,gBACE,uBAAuB,eACvB,wCAAwC,kBAAkB,+BAA+B,aAAa,EAAE;AAG1G,QAAI;AACF,YAAMA,yBAAA,MAAI,8BAAA,GAAA,EAAK,mBAAmB,kBAAkB;IACtD,QAAQ;AACN,YAAM,IAAI,WAAW,8CAA8C,kBAAkB,EAAE;IACzF;EACF;EAEQ,MAAM,kBAAkB,OAAuB;AACrD,UAAM,YAAoB,MAAM,KAAK,CAA4B;AACjE,UAAM,gBAAwB,MAAM,KAAK,CAA4B;AAErE,kCAA8B,WAAW,MAAM,WAAW,CAAC;AAC3D,kCAA8B,eAAe,MAAM,WAAW,CAAC;AAE/D,UAAM,oBAAiC,YAAY,eAAe,aAAa;AAE/E,UAAM,kBAA0B,QAAQ,MAAMA,yBAAA,MAAI,8BAAA,GAAA,EAAK,mBAAmB,SAAS,GAAG,YAAY;AAElG,WAAO;MACL;MACA;MACA,oBAAoB,OAAO,kBAAkB,cAAc,kBAAkB;;EAEjF;EAEQ,MAAM,mBAAmB,OAAuB;AACtD,UAAM,aAAqB,MAAM,KAAK,CAA4B;AAClE,UAAM,aAAqB,MAAM,KAAK,CAA4B;AAClE,UAAM,eAAuB,MAAM,KAAK,CAA4B;AACpE,UAAM,gBAAwB,MAAM,KAAK,CAA4B;AAErE,kCAA8B,YAAY,MAAM,WAAW,CAAC;AAC5D,kCAA8B,YAAY,MAAM,WAAW,CAAC;AAC5D,iCAA6B,cAAc,MAAM,WAAW,CAAC;AAC7D,kCAA8B,eAAe,MAAM,WAAW,CAAC;AAE/D,UAAM,oBAAiC,YAAY,eAAe,aAAa;AAE/E,UAAM,SAAkB,iBAAiB;AACzC,UAAM,qBAA6B,QAAQ,MAAMA,yBAAA,MAAI,8BAAA,GAAA,EAAK,mBAAmB,UAAU,GAAG,YAAY;AACtG,UAAM,qBAA6B,SAC/B,OAAO,UAAU,IACjB,QAAQ,MAAMA,yBAAA,MAAI,8BAAA,GAAA,EAAK,mBAAmB,UAAU,GAAG,YAAY;AAEvE,WAAO;MACL;MACA;MACA;MACA;MACA,oBAAoB,OAAO,kBAAkB,cAAc,kBAAkB;;EAEjF;EAEQ,MAAM,wBAAwB,OAAuB;AAC3D,UAAM,aAAqB,MAAM,KAAK,CAA4B;AAClE,UAAM,WAAmB,MAAM,KAAK,CAA4B;AAChE,UAAM,eAAuB,MAAM,KAAK,CAA4B;AACpE,UAAM,gBAAwB,MAAM,KAAK,CAA4B;AAErE,kCAA8B,YAAY,MAAM,WAAW,CAAC;AAC5D,gCAA4B,UAAU,MAAM,WAAW,CAAC;AACxD,iCAA6B,cAAc,MAAM,WAAW,CAAC;AAC7D,kCAA8B,eAAe,MAAM,WAAW,CAAC;AAE/D,UAAM,oBAAiC,YAAY,eAAe,aAAa;AAE/E,UAAM,SAAkB,iBAAiB;AACzC,UAAM,qBAA6B,QAAQ,MAAMA,yBAAA,MAAI,8BAAA,GAAA,EAAK,mBAAmB,UAAU,GAAG,YAAY;AACtG,UAAM,qBAA6B,SAC/B,OAAO,QAAQ,IACf,QAAQ,MAAMA,yBAAA,MAAI,8BAAA,GAAA,EAAK,mBAAmB,QAAQ,GAAG,YAAY;AAErE,WAAO;MACL;MACA;MACA;MACA;MACA,oBAAoB,OAAO,kBAAkB,cAAc,kBAAkB;;EAEjF;;;;;;;;;;;;;;;;;;;;ACzqBI,IAAO,4BAAP,MAAgC;EAMpC,YACE,8BACA,4BACA,kBACA,iBAAuB;AATzB,sCAAA,IAAA,MAAA,MAAA;AACA,4DAAA,IAAA,MAAA,MAAA;AACA,0DAAA,IAAA,MAAA,MAAA;AACA,gDAAA,IAAA,MAAA,MAAA;AAQE,IAAAC,yBAAA,MAAI,yDAAiC,8BAA4B,GAAA;AACjE,IAAAA,yBAAA,MAAI,uDAA+B,4BAA0B,GAAA;AAC7D,IAAAA,yBAAA,MAAI,6CAAqB,kBAAgB,GAAA;AACzC,IAAAA,yBAAA,MAAI,mCAAW,IAAI,eAAe,eAAe,GAAC,GAAA;EACpD;EAEO,MAAM,OAAI;AACf,UAAM,qBAAqB,MAAMC,yBAAA,MAAI,6CAAA,GAAA,EAAmB,eAAc;AACtE,QAAI,uBAAuBA,yBAAA,MAAI,mCAAA,GAAA,EAAS,aAAa;AACnD,aAAO,CAAA;IACT;AAEA,UAAM,EAAE,QAAQ,OAAM,IAAK,MAAM,qBAC/BA,yBAAA,MAAI,yDAAA,GAAA,GACJA,yBAAA,MAAI,uDAAA,GAAA,GACJA,yBAAA,MAAI,6CAAA,GAAA,GACJ;MACE,iBAAiBA,yBAAA,MAAI,mCAAA,GAAA,EAAS;MAC9B,eAAe;KAChB;AAGH,QAAI,CAAC,OAAO,SAAS;AAEnB,MAAAA,yBAAA,MAAI,mCAAA,GAAA,EAAS,cAAc,OAAO,aAAa,OAAO,aAAa;IACrE,OAAO;AAGL,kBAAY,OAAO,WAAW,CAAC;IACjC;AAEA,WAAO;EACT;;;;;;;;;;;;;;;;;;;;;ACpCI,IAAO,kBAAP,MAAO,iBAAe;EAO1B,cAAA;AANA,8BAAA,IAAA,MAAA,MAAA;AACA,6BAAA,IAAA,MAAA,MAAA;AACA,wBAAA,IAAA,MAAA,MAAA;AACA,wCAAA,IAAA,MAAA,MAAA;AACA,mCAAA,IAAA,MAAA,MAAA;EAEe;EAER,aAAa,OAClB,kBACA,QAMC;AAED,UAAM,KAAK,IAAI,iBAAe;AAC9B,UAAM,iBAAiB,OAAO,gCAAgC;AAC9D,IAAAC,yBAAA,IAAE,2BAAa,IAAI,0BACjB,gBACA,OAAO,4BACP,kBACA,OAAO,GAAG,eAAe,GAC1B,GAAA;AACD,IAAAA,yBAAA,IAAE,0BAAY,IAAI,yBAAyB,OAAO,EAAE,GAAC,GAAA;AACrD,IAAAA,yBAAA,IAAE,qBAAO,OAAO,IAAE,GAAA;AAClB,IAAAA,yBAAA,IAAE,gCAAkB,MAAM,cAAc,OAAO,kBAAkB,OAAO,4BAA4B,GAAC,GAAA;AACrG,IAAAA,yBAAA,IAAE,qCAAuB,OAAO,oBAAkB,GAAA;AAClD,WAAO;EACT;EAEO,QAAK;AACV,gBAAYC,yBAAA,MAAI,qBAAA,GAAA,MAAS,QAAW,iCAAiC;AACrE,WAAOA,yBAAA,MAAI,qBAAA,GAAA;EACb;EAEO,MAAM,mBAAgB;AAC3B,gBAAYA,yBAAA,MAAI,2BAAA,GAAA,MAAe,QAAW,iCAAiC;AAC3E,gBAAYA,yBAAA,MAAI,0BAAA,GAAA,MAAc,QAAW,iCAAiC;AAG1E,UAAM,SAA6B,MAAMA,yBAAA,MAAI,2BAAA,GAAA,EAAW,KAAI;AAC5D,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GAAG;AACtC,YAAMA,yBAAA,MAAI,0BAAA,GAAA,EAAU,YAAY,OAAO,CAAC,CAAC;IAC3C;EACF;EAEO,MAAM,gBAAa;AACxB,gBAAYA,yBAAA,MAAI,qBAAA,GAAA,MAAS,QAAW,iCAAiC;AAMrE,UAAM,KAAK,iBAAgB;AAC3B,UAAMA,yBAAA,MAAI,qBAAA,GAAA,EAAK,MAAK;EACtB;EAEO,MAAM,gBAAgB,gBAAsB;AACjD,YAAQ,IAAI,0BAA0B,cAAc;EACtD;EAEO,MAAM,oBAAoB,kBAA0B,cAAsB,UAA+B;AAC9G,gBAAYA,yBAAA,MAAI,qBAAA,GAAA,MAAS,QAAW,iCAAiC;AAErE,UAAMA,yBAAA,MAAI,qBAAA,GAAA,EAAK,oBAAoB,kBAAkB,cAAc,QAAQ;EAC7E;EAEO,MAAM,yBAAyB,gBAAwB;AAC5D,gBAAYA,yBAAA,MAAI,qBAAA,GAAA,MAAS,QAAW,iCAAiC;AAErE,UAAM,KAAK,iBAAgB;AAE3B,UAAM,mBAA6B,CAAA;AAEnC,aAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,EAAE,GAAG;AAC9C,4BAAsB,eAAe,CAAC,CAAC;AAEvC,UAAI;AACJ,UAAI;AACF,wBAAgB,MAAMA,yBAAA,MAAI,qBAAA,GAAA,EAAK,mBAAmB,eAAe,CAAC,CAAC,GAAG;MACxE,QAAQ;AACN,uBAAe;MACjB;AACA,uBAAiB,KAAK,YAAY;IACpC;AAEA,WAAO;EACT;EAEO,MAAM,6BACX,oBACA,iBACA,iBACA,aACA,WAAiB;AAEjB,gBAAYA,yBAAA,MAAI,gCAAA,GAAA,MAAoB,QAAW,iCAAiC;AAChF,gBAAYA,yBAAA,MAAI,qCAAA,GAAA,MAAyB,QAAW,iCAAiC;AAErF,UAAM,aAAa,mBAAmB;AAEtC,UAAM,gCAA0C,CAAA;AAChD,UAAM,wBAAkC,CAAA;AAExC,aAAS,QAAQ,GAAG,QAAQ,YAAY,EAAE,OAAO;AAC/C,YAAM,mBAAmB,eAAQ,QAAQ,mBAAmB,KAAK,CAAC;AAClE,4BAAsB,KAAK,gBAAgB;AAC3C,oCAA8B,KAAK,aAAa,kBAAkB,IAAI,CAAC;IACzE;AAEA,UAAM,SAASA,yBAAA,MAAI,gCAAA,GAAA,EAAgB,mCACjC,uBACA,iBACA,iBACA,aACA,SAAS;AAGX,UAAM,gBAA0B,MAAM,gBACpCA,yBAAA,MAAI,qCAAA,GAAA,GACJ,OAAO,QACP,OAAO,OACP,OAAO,OAAO;AAIhB,UAAM,2BAAqC,cAAc,IAAI,CAAC,WAAW,aAAa,QAAQ,IAAI,CAAC;AAEnG,WAAO;MACL,SAAS;MACT,YAAY;;EAEhB;;;;;ACnJI,SAAU,4BAA4B,OAAc;AACxD,SAAO,UAAU;AACnB;;;ACJO,IAAM,mCAAsD,IAAI,eAAQ,UAAU;EACvF;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;CAET;;;AC1BD,eAAsB,0BACpB,mCACA,iCACA,kBACA,SAIC;AAED,MAAI,qBAA6B;AACjC,MAAI;AAEJ,MAAI,QAAQ,kBAAkB,QAAW;AACvC,cAAU,QAAQ;EACpB,OAAO;AACL,yBAAqB,MAAM,iBAAiB,eAAc;AAC1D,cAAU;EACZ;AAEA,MAAI;AACJ,MAAI,QAAQ,oBAAoB,QAAW;AACzC,gBAAY,QAAQ;EACtB,OAAO;AACL,gBAAY;EACd;AAEA,MAAI,YAAY,SAAS;AACvB,UAAM,IAAI,WAAW,kCAAkC,SAAS,YAAY,OAAO,EAAE;EACvF;AAEA,QAAM,0BACJ,kCAAkC,SAAS,mBAAmB;AAChE,MAAI,CAAC,yBAAyB;AAC5B,UAAM,IAAI,WAAW,mCAAmC;EAC1D;AAGA,QAAM,SAAS,kCAAkC,mBAAmB,yBAAyB,CAAA,CAAE;AAE/F,QAAM,SAAyB;IAC7B,SAAS;IACT;IACA;IACA;;AAGF,QAAM,OAAO,MAAM,iBAAiB,QAAQ,MAAM;AAElD,QAAM,SAAS,IAAI,eAAe,EAAE;AACpC,QAAM,SAAkC,KACrC,IAAI,CAAC,QAAO;AACX,QAAI;AACF,aAAO,cAAc,IAAI,aAAa,IAAI,KAAK;AAE/C,YAAM,YAAY,kCAAkC,SAAS,GAAG;AAEhE,UAAI,CAAC,4BAA4B,UAAU,IAAI,GAAG;AAChD,eAAO;MACT;AAEA,UAAI,IAAI,gBAAgB,WAAW;AACjC,YAAI,QAAQ,sBAAsB,QAAW;AAC3C,cAAI,IAAI,QAAQ,QAAQ,mBAAmB;AACzC,mBAAO;UACT;QACF;MACF;AAEA,YAAM,MAA6B;QACjC,WAAW,UAAU;QACrB,MAAM,UAAU;QAChB,OAAO,IAAI;QACX,aAAa,IAAI;QACjB,iBAAiB,IAAI;QACrB,kBAAkB,IAAI;;AAGxB,aAAO;IACT,QAAQ;AAEN,aAAO;IACT;EACF,CAAC,EACA,OAAO,CAAC,UAAU,UAAU,IAAI;AAEnC,SAAO,EAAE,QAAQ,OAAM;AACzB;AAEM,SAAU,yBAAyB,GAAwB;AAC/D,MAAI,EAAE,cAAc,qBAAqB;AACvC,WAAO;EACT;AAEA,QAAM,UAAU,EAAE,KAAK,CAAC;AACxB,QAAM,YAAY,EAAE,KAAK,CAAC;AAC1B,QAAM,oBAAoB,EAAE,KAAK,CAAC;AAClC,QAAM,wBAAwB,EAAE,KAAK,CAAC;AACtC,QAAM,4BAA4B,EAAE,KAAK,CAAC;AAE1C,6BAA2B,SAAS,qBAAqB,CAAC;AAC1D,6BAA2B,WAAW,qBAAqB,CAAC;AAE5D,cAAY,kBAAkB,SAAS,CAAC;AACxC,gCAA8B,kBAAkB,CAAC,GAAG,qBAAqB,CAAC;AAC1E,0BAAwB,uBAAuB,qBAAqB,CAAC;AACrE,+BAA6B,2BAA2B,qBAAqB,CAAC;AAE9E,QAAM,MAA8B;IAClC,aAAa,EAAE;IACf,OAAO,EAAE;IACT,iBAAiB,EAAE;IACnB,kBAAkB,EAAE;IACpB;IACA;IACA;IACA;IACA;;AAGF,SAAO;AACT;AAEM,SAAU,qCACd,MAA2D;AAG3D,MAAI,CAAC,MAAM;AACT,WAAO,CAAA;EACT;AACA,QAAM,SAAmC,CAAA;AACzC,aAAW,OAAO,MAAM;AACtB,UAAM,QAAuC,iCAAiC,SAAS,GAAG;AAE1F,QAAI,CAAC,OAAO;AACV;IACF;AACA,QAAI,CAAC,4BAA4B,MAAM,IAAI,GAAG;AAC5C;IACF;AAEA,UAAM,MAA6B;MACjC,WAAW,MAAM;MACjB,MAAM,MAAM;MACZ,aAAa,IAAI;MACjB,OAAO,IAAI;MACX,iBAAiB,IAAI;MACrB,kBAAkB,IAAI;;AAGxB,UAAM,IAAI,yBAAyB,GAAG;AACtC,QAAI,CAAC,GAAG;AACN;IACF;AAEA,WAAO,KAAK,CAAC;EACf;AAEA,SAAO;AACT;;;;;;;;;;;;;;;;;;ACtKM,IAAO,gCAAP,MAAoC;EAMxC,YAAY,IAAa,aAA0B,YAA8B,eAA6B;AAL9G,sCAAA,IAAA,MAAA,MAAA;AACA,+CAAA,IAAA,MAAA,MAAA;AACA,8CAAA,IAAA,MAAA,MAAA;AACA,iDAAA,IAAA,MAAA,MAAA;AAGE,IAAAC,yBAAA,MAAI,mCAAO,IAAE,GAAA;AACb,IAAAA,yBAAA,MAAI,4CAAgB,aAAW,GAAA;AAC/B,IAAAA,yBAAA,MAAI,2CAAe,YAAU,GAAA;AAC7B,IAAAA,yBAAA,MAAI,8CAAkB,eAAa,GAAA;EACrC;;EAGO,MAAM,YACX,wBAA8C;AAE9C,UAAM,gBAA0B,CAAA;AAChC,UAAM,oBAA8B,CAAA;AACpC,aAAS,IAAI,GAAG,IAAI,uBAAuB,kBAAkB,QAAQ,EAAE,GAAG;AACxE,kBACE,uBAAuB,eAAeC,yBAAA,MAAI,mCAAA,GAAA,EAAK,iBAC/C,6FAA6F;AAO/F,YAAM,QAAQ,MAAMA,yBAAA,MAAI,mCAAA,GAAA,EAAK,mBAAmB,uBAAuB,kBAAkB,CAAC,CAAC;AAE3F,kBAAY,MAAM,iBAAiB,IAAI;AACvC,oBAAc,KAAK,MAAM,YAAY;AACrC,wBAAkB,KAAK,uBAAuB,kBAAkB,CAAC,CAAC;IACpE;AAEA,UAAM,cAAsB,eAAQ,eAAe,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;AAEjE,UAAM,EAAE,SAAQ,IAAK,MAAM,+CACzB,mBACA,eACA,aACA,uBAAuB,WACvB,uBAAuB,2BACvB,eAAQ,SAAS,gBAAe,GAChCA,yBAAA,MAAI,4CAAA,GAAA,GACJA,yBAAA,MAAI,2CAAA,GAAA,CAAY;AAGlB,UAAM,SAAS;MACb,IAAI,uBAAuB;MAC3B,MAAM;;AAGR,UAAM,KAAK,MAAMA,yBAAA,MAAI,8CAAA,GAAA,EAAgB,gBAAgB,MAAM;AAC3D,UAAM,UAAU,MAAM,GAAG,KAAI;AAE7B,WAAO,EAAE,IAAI,QAAO;EACtB;;;;;;;;;;;;;;;;;;;;AC1DI,IAAO,iCAAP,MAAqC;EAMzC,YACE,mCACA,iCACA,kBACA,iBAAuB;AATzB,2CAAA,IAAA,MAAA,MAAA;AACA,sEAAA,IAAA,MAAA,MAAA;AACA,oEAAA,IAAA,MAAA,MAAA;AACA,qDAAA,IAAA,MAAA,MAAA;AAQE,IAAAC,yBAAA,MAAI,mEAAsC,mCAAiC,GAAA;AAC3E,IAAAA,yBAAA,MAAI,iEAAoC,iCAA+B,GAAA;AACvE,IAAAA,yBAAA,MAAI,kDAAqB,kBAAgB,GAAA;AACzC,IAAAA,yBAAA,MAAI,wCAAW,IAAI,eAAe,eAAe,GAAC,GAAA;EACpD;EAEO,MAAM,OAAI;AAOf,QAAI,iBAAiB;AACrB,UAAM,qBAAqB,MAAMC,yBAAA,MAAI,kDAAA,GAAA,EAAmB,eAAc;AACtE,QAAI,sBAAsBA,yBAAA,MAAI,wCAAA,GAAA,EAAS,aAAa;AAClD,uBAAiB;AAEjB,MAAAA,yBAAA,MAAI,wCAAA,GAAA,EAAS,OAAO,qBAAqB,GAAG,CAAC;IAC/C;AAEA,UAAM,EAAE,QAAQ,OAAM,IAAK,MAAM,0BAC/BA,yBAAA,MAAI,mEAAA,GAAA,GACJA,yBAAA,MAAI,iEAAA,GAAA,GACJA,yBAAA,MAAI,kDAAA,GAAA,GACJ;MACE,iBAAiBA,yBAAA,MAAI,wCAAA,GAAA,EAAS;MAC9B,eAAe;KAChB;AAGH,QAAI,CAAC,OAAO,SAAS;AAEnB,MAAAA,yBAAA,MAAI,wCAAA,GAAA,EAAS,cAAc,OAAO,aAAa,OAAO,aAAa;IACrE,OAAO;AAGL,kBAAY,OAAO,WAAW,CAAC;IACjC;AAEA,WAAO,EAAE,QAAQ,gBAAgB,mBAAkB;EACrD;;;;;;;;;;;;;;;;;;;;;;;;;AC9BF,IAAM,yBAAN,MAAM,wBAAsB;EAA5B,cAAA;AACE,gCAAA,IAAA,MAA8C,oBAAI,IAAG,CAAoC;EA0D3F;EAxDU,OAAO,IAAI,OAA+B,iBAAiC;AACjF,WAAO,GAAG,OAAO,mBAAmB,MAAM,OAAO,CAAC;EACpD;EAEO,SAAS,OAA6B;AAC3C,WAAOC,yBAAA,MAAI,6BAAA,GAAA,EAAM,IAAI,wBAAuB,IAAI,KAAK,CAAC;EACxD;EAEO,OAAO,OAA6B;AACzC,IAAAA,yBAAA,MAAI,6BAAA,GAAA,EAAM,OAAO,wBAAuB,IAAI,KAAK,CAAC;EACpD;EAEO,WAAW,OAA+B,gBAAuB;AACtE,QAAI,KAAK,IAAI,KAAK,KAAK,CAAC,gBAAgB;AACtC,YAAM,IAAI,WACR,8BAA8B,MAAM,OAAO,eAAe,MAAM,SAAS,oBAAoB,MAAM,qBAAqB,qBAAqB;IAEjJ;AACA,UAAM,QAAkC;MACtC,OAAO;QACL,SAAS,OAAO,MAAM,OAAO;QAC7B,WAAW,OAAO,MAAM,SAAS;QACjC,uBAAuB,MAAM;QAC7B,OAAO,MAAM;QACb,aAAa,MAAM;QACnB,iBAAiB,MAAM;QACvB,kBAAkB,MAAM;;MAE1B,qBAAqB;MACrB,yBAAyB;MACzB,kBAAkB;MAClB,SAAS;;AAEX,IAAAA,yBAAA,MAAI,6BAAA,GAAA,EAAM,IAAI,wBAAuB,IAAI,KAAK,GAAG,KAAK;AACtD,WAAO;EACT;EAEO,UAAU,OAA6B;AAC5C,UAAM,QAAQA,yBAAA,MAAI,6BAAA,GAAA,EAAM,IAAI,wBAAuB,IAAI,KAAK,CAAC;AAC7D,QAAI,CAAC,OAAO;AACV,aAAO;IACT;AACA,WAAO,MAAM;EACf;EAEO,SAAS,OAA6B;AAC3C,UAAM,QAAQA,yBAAA,MAAI,6BAAA,GAAA,EAAM,IAAI,wBAAuB,IAAI,KAAK,CAAC;AAC7D,QAAI,CAAC,OAAO;AACV,aAAO;IACT;AACA,WAAO,CAAC,MAAM;EAChB;EAEO,IAAI,OAA6B;AACtC,WAAOA,yBAAA,MAAI,6BAAA,GAAA,EAAM,IAAI,wBAAuB,IAAI,KAAK,CAAC;EACxD;;;AAGI,IAAO,uBAAP,MAAO,sBAAoB;EAAjC,cAAA;AACE,mCAAA,IAAA,MAAA,MAAA;AACA,kCAAA,IAAA,MAAA,MAAA;AACA,2CAAA,IAAA,MAAA,MAAA;AACA,sCAAA,IAAA,MAAA,MAAA;AACA,oCAAA,IAAA,MAAqC,IAAI,uBAAsB,CAAE;AACjE,8BAAA,IAAA,MAAA,MAAA;AACA,sCAAA,IAAA,MAAA,MAAA;AACA,qCAAA,IAAA,MAAA,MAAA;EAqGF;EAnGS,aAAa,OAClB,kBACA,QAQC;AAED,UAAM,MAAM,IAAI,sBAAoB;AACpC,UAAM,KAAc,OAAO,YAAY,MAAK;AAC5C,UAAM,8BAA8B,OAAO,qCAAqC;AAChF,IAAAC,yBAAA,KAAG,wCAAqB,kBAAgB,GAAA;AACxC,IAAAA,yBAAA,KAAG,mCAAgB,OAAO,aAAW,GAAA;AACrC,IAAAA,yBAAA,KAAG,gCAAa,IAAI,+BAClB,6BACA,OAAO,iCACP,kBACA,GAAG,eAAe,GACnB,GAAA;AACD,IAAAA,yBAAA,KAAG,mCAAgB,MAAM,YAAY,OAAO,kBAAkB,OAAO,0BAA0B,GAAC,GAAA;AAChG,IAAAA,yBAAA,KAAG,2BAAQ,MAAM,IAAI,OAAO,kBAAkB,OAAO,kBAAkB,GAAC,GAAA;AACxE,IAAAA,yBAAA,KAAG,+BAAY,IAAI,8BAA8B,IAAID,yBAAA,KAAG,mCAAA,GAAA,GAAe,OAAO,YAAY,OAAO,aAAa,GAAC,GAAA;AAC/G,IAAAC,yBAAA,KAAG,kCAAe,OAAO,YAAU,GAAA;AACnC,WAAO;EACT;EAEO,MAAM,2BACX,mBACA,iBACA,WAAiB;AAEjB,gBAAYD,yBAAA,MAAI,mCAAA,GAAA,MAAkB,QAAW,sCAAsC;AACnF,gBAAYA,yBAAA,MAAI,kCAAA,GAAA,MAAiB,QAAW,sCAAsC;AAElF,UAAM,MAAM,MAAM,4BAChB,mBACA,iBACA,WACA,eAAQ,SAAS,gBAAe,GAChCA,yBAAA,MAAI,mCAAA,GAAA,GACJA,yBAAA,MAAI,kCAAA,GAAA,CAAY;AAGlB,WAAO,EAAE,iBAAiB,IAAI,iBAAiB,YAAY,IAAI,WAAU;EAC3E;EAEO,MAAM,wBAAqB;AAChC,gBAAYA,yBAAA,MAAI,mCAAA,GAAA,MAAkB,QAAW,sCAAsC;AACnF,gBAAYA,yBAAA,MAAI,gCAAA,GAAA,MAAe,QAAW,sCAAsC;AAChF,gBAAYA,yBAAA,MAAI,wCAAA,GAAA,MAAuB,QAAW,sCAAsC;AACxF,gBAAYA,yBAAA,MAAI,2BAAA,GAAA,MAAU,QAAW,sCAAsC;AAC3E,gBAAYA,yBAAA,MAAI,+BAAA,GAAA,MAAc,QAAW,sCAAsC;AAG/E,UAAMA,yBAAA,MAAI,mCAAA,GAAA,EAAc,iBAAgB;AAGxC,UAAM,EAAE,QAAQ,eAAc,IAAK,MAAMA,yBAAA,MAAI,gCAAA,GAAA,EAAW,KAAI;AAE5D,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GAAG;AACtC,YAAM,MAAqC,yBAAyB,OAAO,CAAC,CAAC;AAC7E,UAAI,CAAC,KAAK;AACR;MACF;AAGA,UAAIA,yBAAA,MAAI,iCAAA,GAAA,EAAY,UAAU,GAAG,GAAG;AAClC,cAAM,IAAI,WACR,+BAA+B,IAAI,SAAS,oBAAoB,IAAI,qBAAqB,0BAA0B;MAEvH;AAGA,YAAMA,yBAAA,MAAI,2BAAA,GAAA,EAAM,4BAA4B,IAAI,mBAAmBA,yBAAA,MAAI,wCAAA,GAAA,CAAkB;AAIzF,YAAM,WAAWA,yBAAA,MAAI,iCAAA,GAAA,EAAY,WAAW,KAAK,cAAc;AAC/D,kBAAY,SAAS,OAAO;AAC5B,kBAAY,SAAS,wBAAwB,EAAE;AAC/C,kBAAY,SAAS,qBAAqB,MAAS;AACnD,kBAAY,SAAS,4BAA4B,MAAS;AAE1D,UAAI;AACF,cAAM,EAAE,IAAI,QAAO,IAAK,MAAMA,yBAAA,MAAI,+BAAA,GAAA,EAAU,YAAY,GAAG;AAC3D,iBAAS,sBAAsB,mCAAS;AACxC,iBAAS,oBAAmB,mCAAS,YAAW;AAChD,iBAAS,0BAA0B,GAAG;AACtC,iBAAS,UAAU;MACrB,SAAS,GAAG;AACV,QAAAA,yBAAA,MAAI,iCAAA,GAAA,EAAY,OAAO,GAAG;AAC1B,cAAM;MACR;IACF;EACF;;;;;AChMF,IAAM,sBAA8B;AACpC,IAAM,mBAA2B;AAEjC,IAAM,qBAA6B,sBAAsB,KAAK;AAC9D,IAAM,sBAA8B,mBAAmB,KAAK;AAE5D,SAAS,eAAe,SAAkD;AACxE,UAAQ,YAAY,SAAS,QAAQ,SAAS;AAC9C,UAAQ,aAAa,SAAS,QAAQ,UAAU;AAEhD,MAAI,CAAC,eAAQ,YAAY,OAAO,QAAQ,WAAW,iBAAiB,GAAG;AACrE,UAAM,IAAI,WACR,wGAAwG;EAE5G;AACA,MAAI,CAAC,eAAQ,YAAY,OAAO,QAAQ,YAAY,kBAAkB,GAAG;AACvE,UAAM,IAAI,WACR,wGAAwG;EAE5G;AACF;AAEM,SAAU,kBAAe;AAI7B,QAAM,SAAS,eAAQ,OAAO,aAAY;AAE1C,QAAM,0BAA0B,SAAS,OAAO,SAAS;AACzD,QAAM,2BAA2B,SAAS,OAAO,UAAU;AAE3D,cAAY,wBAAwB,WAAW,yBAAyB,SAAS,CAAC;AAElF,QAAM,qBAAqB,IAAI,oBAAoB,wBAAwB;AAC3E,QAAM,sBAAsB,IAAI,sBAAsB,IAAI,yBAAyB;AAEnF,MAAI,IAAI,KAAK,MAAM,qBAAqB,CAAC;AACzC,QAAM,kBAAkB,WAAW,OAAO,CAAC,IAAI,IAAI,OAAO,qBAAqB,IAAI,CAAC;AAEpF,MAAI,KAAK,MAAM,sBAAsB,CAAC;AACtC,QAAM,mBAAmB,WAAW,OAAO,CAAC,IAAI,IAAI,OAAO,sBAAsB,IAAI,CAAC;AAEtF,QAAM,YAAY,OAAO,kBAAkB;AAC3C,QAAM,aAAa,OAAO,mBAAmB,OAAO;AAEpD,cAAY,UAAU,WAAW,IAAI,IAAI,iBAAiB;AAC1D,cAAY,WAAW,WAAW,IAAI,IAAI,kBAAkB;AAC5D,cAAY,wBAAwB,WAAW,EAAE;AACjD,cAAY,yBAAyB,WAAW,EAAE;AAElD,QAAM,UAAU;IACd;IACA;;AAGF,iBAAe,OAAO;AAEtB,SAAO;AACT;AAmBO,IAAM,eACX,CAAC,mBAA2B,qBAC5B,CACE,WACA,mBACA,gBACA,cACA,qBACU;AACV,QAAM,YAA2B;AACjC,MAAI,oBAAoB,CAAC,eAAQ,UAAU,gBAAgB;AAAG,UAAM,IAAI,MAAM,4BAA4B;AAE1G,MAAI,CAAC,eAAQ,UAAU,iBAAiB,GAAG;AACzC,UAAM,IAAI,MAAM,qCAAqC;EACvD;AAEA,MAAI,CAAC,kBAAkB,MAAM,CAAC,MAAM,eAAQ,UAAU,CAAC,CAAC,GAAG;AACzD,UAAM,IAAI,MAAM,2BAA2B;EAC7C;AAEA,QAAM,qBACJ,OAAO,cAAc,WAAY,UAAU,WAAW,IAAI,IAAI,YAAY,KAAK,SAAS,KAAM;AAGhG,QAAM,0BAA0B,OAAO,mBAAmB,WAAW,eAAe,SAAQ,IAAK;AAEjG,QAAM,wBAAwB,OAAO,iBAAiB,WAAW,aAAa,SAAQ,IAAK;AAE3F,QAAM,eAAe;IACnB,EAAE,MAAM,QAAQ,MAAM,SAAQ;IAC9B,EAAE,MAAM,WAAW,MAAM,SAAQ;IACjC,EAAE,MAAM,WAAW,MAAM,UAAS;IAClC,EAAE,MAAM,qBAAqB,MAAM,UAAS;;AAG9C,QAAM,SAAS;IACb,MAAM;IACN,SAAS;IACT,SAAS;IACT;;AAGF,MAAI,kBAAkB;AACpB,WAAO;MACL,OAAO;QACL;QACA,yCAAyC;UACvC,EAAE,MAAM,aAAa,MAAM,QAAO;UAClC,EAAE,MAAM,qBAAqB,MAAM,YAAW;UAC9C,EAAE,MAAM,oBAAoB,MAAM,UAAS;UAC3C,EAAE,MAAM,kBAAkB,MAAM,UAAS;UACzC,EAAE,MAAM,gBAAgB,MAAM,UAAS;UACvC,EAAE,MAAM,aAAa,MAAM,QAAO;UAClC;YACE,MAAM;YACN,MAAM;;;;MAIZ,aAAa;MACb;MACA,SAAS;QACP,WAAW;QACX;QACA;QACA,gBAAgB;QAChB,cAAc;QACd;QACA;;;EAGN;AAEA,SAAO;IACL,OAAO;MACL;MACA,gCAAgC;QAC9B,EAAE,MAAM,aAAa,MAAM,QAAO;QAClC,EAAE,MAAM,qBAAqB,MAAM,YAAW;QAC9C,EAAE,MAAM,oBAAoB,MAAM,UAAS;QAC3C,EAAE,MAAM,kBAAkB,MAAM,UAAS;QACzC,EAAE,MAAM,gBAAgB,MAAM,UAAS;QACvC,EAAE,MAAM,aAAa,MAAM,QAAO;;;IAGtC,aAAa;IACb;IACA,SAAS;MACP,WAAW;MACX;MACA;MACA,gBAAgB;MAChB,cAAc;MACd;;;AAGN;;;;;;;;;;;;;;;;;;;;;;;;AClKI,IAAO,4BAAP,MAAO,2BAAyB;EAiBpC,YACE,iBACA,iBACA,iBACA,aACA,oBACA,eAA4B;AAtB9B,+CAAA,IAAA,MAAwC,CAAA,CAAE;AAC1C,0CAAA,IAAA,MAA2B,CAAA,CAAE;AAC7B,wCAAA,IAAA,MAAuB,CAAA,CAAE;AACzB,4CAAA,IAAA,MAAwB,CAAC;AAEzB,+CAAA,IAAA,MAAA,MAAA;AACA,+CAAA,IAAA,MAAA,MAAA;AACA,2CAAA,IAAA,MAAA,MAAA;AAEA,+CAAA,IAAA,MAAA,MAAA;AACA,kDAAA,IAAA,MAAA,MAAA;AACA,6CAAA,IAAA,MAAA,MAAA;AAcE,QAAI,OAAO,eAAe,IAAI,YAAY;AACxC,YAAM,IAAI,MAAM,iDAAiD;IACnE;AAEA,IAAAE,yBAAA,MAAI,4CAAoB,iBAAe,GAAA;AACvC,IAAAA,yBAAA,MAAI,4CAAoB,iBAAe,GAAA;AACvC,IAAAA,yBAAA,MAAI,4CAAoB,iBAAe,GAAA;AACvC,IAAAA,yBAAA,MAAI,wCAAgB,aAAW,GAAA;AAC/B,IAAAA,yBAAA,MAAI,+CAAuB,oBAAkB,GAAA;AAC7C,IAAAA,yBAAA,MAAI,0CAAkB,eAAa,GAAA;EACrC;EAEA,IAAW,cAAW;AACpB,WAAOC,yBAAA,MAAI,wCAAA,GAAA;EACb;EAEA,IAAW,kBAAe;AACxB,WAAOA,yBAAA,MAAI,4CAAA,GAAA;EACb;EAEQ,iBAAiB,WAAiB;AACxC,gBAAY,aAAa,CAAC;AAC1B,QAAIA,yBAAA,MAAI,yCAAA,GAAA,IAAiB,YAAY,2BAA0B,cAAc;AAC3E,YAAM,MAAM,yEAAyE;IACvF;AACA,QAAIA,yBAAA,MAAI,4CAAA,GAAA,EAAkB,SAAS,IAAI,2BAA0B,eAAe;AAC9E,YAAM,MAAM,6EAA6E;IAC3F;EACF;EAEQ,8BAA8B,gBAAiC,WAAoB;AAEzF,UAAM,UAAU,mBAAmB,SAAS;AAC5C,UAAM,YAAY,oBAAoB,OAAO;AAE7C,SAAK,iBAAiB,SAAS;AAE/B,IAAAA,yBAAA,MAAI,uCAAA,GAAA,EAAa,KAAK,SAAS;AAC/B,IAAAA,yBAAA,MAAI,qCAAA,GAAA,EAAW,KAAK,OAAO;AAC3B,IAAAA,yBAAA,MAAI,4CAAA,GAAA,EAAkB,KAAK,cAAc;AACzC,IAAAD,yBAAA,MAAA,yCAAAC,yBAAA,MAAA,yCAAA,GAAA,IAAsB,WAAS,GAAA;AAE/B,gBAAYA,yBAAA,MAAI,4CAAA,GAAA,EAAkB,UAAU,2BAA0B,aAAa;AACnF,gBAAYA,yBAAA,MAAI,yCAAA,GAAA,KAAkB,2BAA0B,YAAY;AACxE,gBAAYA,yBAAA,MAAI,4CAAA,GAAA,EAAkB,WAAWA,yBAAA,MAAI,qCAAA,GAAA,EAAW,MAAM;AAClE,gBAAYA,yBAAA,MAAI,4CAAA,GAAA,EAAkB,WAAWA,yBAAA,MAAI,uCAAA,GAAA,EAAa,MAAM;EACtE;EAEQ,UAAU,gBAA4B,WAAoB;AAChE,gBAAY,cAAc,SAAS,CAAC;AAEpC,UAAM,gBAAgB,iBAAiB,SAAS;AAChD,UAAM,YAAY,oBAAoB,cAAc,OAAO;AAC3D,UAAM,kBAAkB,cAAc;AAGtC,gBAAY,oBAAoB,SAAS;AACzC,gBAAY,YAAY,MAAM,CAAC;AAE/B,UAAM,aAAa,YAAY;AAE/B,QAAI,eAAe,SAAS,YAAY;AACtC,YAAM,IAAI,WACR,mDAAmD,UAAU,WAAW,cAAc,IAAI,EAAE;IAEhG;AAEA,UAAM,uBAA+B,eAAQ,SAAS,cAAc;AACpE,UAAM,0BAAkC,aAAa,eAAe;AAGpE,gBAAY,eAAe,SAAS,MAAM,SAAS;AACnD,gBAAY,wBAAwB,uBAAuB;AAE3D,SAAK,8BAA8B,sBAAsB,SAAS;AAElE,WAAO;EACT;EAEQ,SAAS,gBAAiC,YAAqB;AACrE,gBAAY,aAAa,UAAU,CAAC;AAEpC,UAAM,gBAAgB,iBAAiB,UAAU;AACjD,UAAM,kBAAkB,cAAc;AAEtC,QAAI,iBAAiB,GAAG;AACtB,YAAM,IAAI,WAAW,kCAAkC,cAAc,EAAE;IACzE;AAEA,UAAM,uBAA+B,OAAO,cAAc;AAC1D,UAAM,0BAAkC,aAAa,eAAe;AAEpE,QAAI,uBAAuB,yBAAyB;AAClD,YAAM,IAAI,WACR,WAAW,cAAc,gBAAgB,WAAW,cAAc,6CAA6C,uBAAuB,GAAG;IAE7I;AAEA,SAAK,8BAA8B,sBAAsB,UAAU;AAEnE,WAAO;EACT;;EAGO,QAAQ,OAAgC;AAC7C,UAAM,kBAA2B,aAAa,KAAK;AAEnD,SAAK,8BAA8B,iBAAiB,UAAU,KAAK;AAEnE,WAAO;EACT;EACO,KAAK,OAAsB;AAChC,WAAO,KAAK,SAAS,OAAO,UAAU,MAAM;EAC9C;EACO,MAAM,OAAsB;AACjC,WAAO,KAAK,SAAS,OAAO,UAAU,OAAO;EAC/C;EACO,MAAM,OAAsB;AACjC,WAAO,KAAK,SAAS,OAAO,UAAU,OAAO;EAC/C;EACO,MAAM,OAAsB;AACjC,WAAO,KAAK,SAAS,OAAO,UAAU,OAAO;EAC/C;EACO,OAAO,OAAsB;AAClC,WAAO,KAAK,SAAS,OAAO,UAAU,QAAQ;EAChD;EACO,WAAW,OAAa;AAC7B,QAAI,CAAC,eAAQ,UAAU,KAAK,GAAG;AAC7B,YAAM,IAAI,MAAM,kCAAkC;IACpD;AAEA,UAAM,iBAAiB,eAAQ,WAAW,KAAK;AAE/C,SAAK,8BAA8B,gBAAgB,UAAU,QAAQ;AAErE,WAAO;EACT;EACO,OAAO,OAAsB;AAClC,WAAO,KAAK,SAAS,OAAO,UAAU,QAAQ;EAChD;EACO,WAAW,OAAiB;AACjC,WAAO,KAAK,UAAU,OAAO,UAAU,QAAQ;EACjD;EACO,YAAY,OAAiB;AAClC,WAAO,KAAK,UAAU,OAAO,UAAU,SAAS;EAClD;EACO,YAAY,OAAiB;AAClC,WAAO,KAAK,UAAU,OAAO,UAAU,SAAS;EAClD;EAEQ,uCAAuC,WAAiB;AAC9D,UAAM,aAAaA,yBAAA,MAAI,4CAAA,GAAA,EAAkB;AACzC,UAAM,2BAAqC,CAAA;AAC3C,UAAM,wBAAkC,CAAA;AACxC,UAAM,mBAAiC,CAAA;AACvC,UAAM,YAAqC,CAAA;AAE3C,aAAS,IAAI,GAAG,IAAI,YAAY,EAAE,GAAG;AACnC,YAAM,uBAAuB,OAAOA,yBAAA,MAAI,4CAAA,GAAA,EAAkB,CAAC,CAAC;AAC5D,4BAAsB,KAAK,oBAAoB;AAC/C,+BAAyB,KAAK,eAAQ,QAAQ,oBAAoB,CAAC;AACnE,uBAAiB,KAAK,eAAQ,YAAY,EAAE,CAAC;AAE7C,gBAAU,KAAK;QACb,aAAa;QACb,OAAO;QACP,iBAAiB,eAAQ;OAC1B;IACH;AAEA,UAAM,sCAAkD,2BAA0B,kCAChF,uBACAA,yBAAA,MAAI,qCAAA,GAAA,GACJ,gBAAgB;AAGlB,UAAM,WAA4B;MAChC;MACA;MACA,UAAUA,yBAAA,MAAI,qCAAA,GAAA;MACd,YAAYA,yBAAA,MAAI,uCAAA,GAAA;MAChB,oBAAoBA,yBAAA,MAAI,+CAAA,GAAA;MACxB,cAAc,iBAAiB,IAAI,eAAQ,OAAO;;AAGpD,UAAM,cAA8C;MAClD,iBAAiBA,yBAAA,MAAI,4CAAA,GAAA;MACrB,aAAaA,yBAAA,MAAI,wCAAA,GAAA;MACjB,iCAAiC,eAAQ,QAAQ,mCAAmC;MACpF,iBAAiB,OAAOA,yBAAA,MAAI,4CAAA,GAAA,EAAkB,SAAS,EAAE;MACzD;MACA;;AAGF,WAAO;EACT;EAEQ,OAAO,kCACb,uBACA,UACA,kBAA8B;AAE9B,QAAI,YAAwB,IAAI,WAAW,CAAC;AAE5C,UAAM,aAAa,sBAAsB;AAEzC,gBAAY,iBAAiB,WAAW,UAAU;AAClD,gBAAY,SAAS,WAAW,UAAU;AAG1C,aAAS,IAAI,GAAG,IAAI,YAAY,EAAE,GAAG;AAInC,YAAM,uBAAuB,sBAAsB,CAAC;AACpD,YAAM,aAAa,qBAAqB,SAAS,CAAC,CAAC;AAEnD,YAAM,eAAe,IAAI,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC;AACjD,YAAM,wBAAwB,YAAY,sBAAsB,UAAU;AAC1E,YAAM,eAA2B,iBAAiB,CAAC;AAGnD,kBAAY,YAAY,WAAW,cAAc,uBAAuB,YAAY;IACtF;AAEA,WAAO,eAAQ,SAAS,eAAQ,UAAU,SAAS,CAAC;EACtD;EAEO,MAAM,UAAO;AAClB,UAAM,YAA2B;AAkBjC,UAAM,UAAU,KAAK,uCAAuC,SAAS;AACrE,UAAM,4BAA4B,eAAQ,SAAS,QAAQ,+BAA+B;AA4B1F,UAAM,WAAW,MAAc,2BAA2BA,yBAAA,MAAI,4CAAA,GAAA,GAAmB,OAAO;AAExF,UAAM,qBAAqB,YAAY,eACrC,2BACAA,yBAAA,MAAI,uCAAA,GAAA,GACJA,yBAAA,MAAI,+CAAA,GAAA,GACJA,yBAAA,MAAI,4CAAA,GAAA,GACJ,kBAAU,oBAAoB;AAGhC,IAAAA,yBAAA,MAAI,0CAAA,GAAA,EAAgB,iBAClB,oBACAA,yBAAA,MAAI,wCAAA,GAAA,GACJA,yBAAA,MAAI,4CAAA,GAAA,GACJA,yBAAA,MAAI,4CAAA,GAAA,GACJ,WACA,SAAS,UAAU;AAGrB,UAAM,gBAAgB,qBAAqB,SAAS,SAAS,SAAS,YAAY,SAAS;AAE3F,WAAO;MACL,SAAS;MACT,YAAY,eAAQ,UAAU,aAAa;;EAE/C;EAEO,UAAO;AACZ,UAAM,IAAI,WAAW,sDAAsD;EAC7E;;;AA7TgB,OAAA,eAAA,2BAAA,gBAAA;;;;SAAuB;;AACvB,OAAA,eAAA,2BAAA,iBAAA;;;;SAAwB;;;;AC5B1C,IAAM,mBAA2C;EAC/C,GAAG;;EACH,GAAG;;EACH,GAAG;;EACH,GAAG;;EACH,GAAG;;EACH,GAAG;;EACH,GAAG;;EACH,GAAG;;;AAIC,SAAU,mBAAmB,SAAiB;AAClD,MAAI,QAAQ;AAEZ,aAAW,UAAU,SAAS;AAC5B,QAAI,OAAO,WAAW,IAAI;AACxB,YAAM,IAAI,MAAM,UAAU,MAAM,yBAAyB;IAC3D;AAEA,UAAM,UAAU,OAAO,MAAM,IAAI,EAAE,EAAE,YAAW;AAChD,UAAM,mBAAmB,SAAS,SAAS,EAAE;AAE7C,QAAI,EAAE,oBAAoB,mBAAmB;AAC3C,YAAM,IAAI,MAAM,UAAU,MAAM,uBAAuB;IACzD;AAEA,aAAS,iBAAiB,gBAAiD;AAG3E,QAAI,QAAQ,MAAM;AAChB,YAAM,IAAI,MAAM,kEAAkE;IACpF;EACF;AACA,SAAO;AACT;;;AChCA,IAAM,iBAA2E;EAC/E,GAAG;EACH,GAAG;EACH,GAAG;EACH,GAAG;EACH,GAAG;EACH,GAAG;EACH,GAAG;EACH,GAAG;;AAIC,SAAU,2BAA2B,SAAmB,iBAAuB;AACnF,MAAI,YAAsB,CAAA;AAC1B,aAAW,UAAU,SAAS;AAC5B,UAAM,UAAU,OAAO,MAAM,IAAI,EAAE,EAAE,YAAW;AAChD,UAAM,mBAAmB,SAAS,SAAS,EAAE;AAC7C,cAAU,KAAK,gBAAgB;EACjC;AAEA,QAAM,kBACJ,OACA,KAAK,OAAO,EAAE;EACd,gBAAgB,MAAM,CAAC,IACvB,KAAK,OAAO,EAAE;AAEhB,QAAM,WAAW,UAAU,IAAI,CAAC,MAAK;AACnC,UAAM,UAAU,eAAe,CAAC;AAChC,WAAO;EACT,CAAC;AAED,QAAM,QAAQ,IAAI,eAAQ,SAAQ;AAClC,QAAM,UAAU,MAAM,OAAO,CAAC,WAAW,GAAG,UAAU,SAAS,GAAG,eAAe;AAGjF,QAAM,YAAY,QAAQ,MAAM,GAAG,IAAI,UAAU,MAAM;AAEvD,MAAI,UAA4B,CAAA;AAChC,UAAQ,QAAQ,CAAC,QAAQ,QAAS,QAAQ,MAAM,IAAI,UAAU,GAAG,CAAE;AAEnE,SAAO;AACT;;;ACzCA,IAAM,sCAA8C;AACpD,IAAM,iCAAyC;AAGzC,SAAU,sBAAsB,gBAAwB,cAAoB;AAChF,MAAI,iBAAiB,OAAO,CAAC,GAAG;AAC9B,UAAM,IAAI,WAAW,sBAAsB;EAC7C;AAEA,MAAI,eAAe,gCAAgC;AACjD,UAAM,IAAI,WAAW,yCAAyC,8BAA8B,EAAE;EAChG;AAEA,QAAM,mBAAmB,OAAO,KAAK,MAAM,KAAK,IAAG,IAAK,GAAI,CAAC;AAC7D,MAAI,iBAAiB,kBAAkB;AACrC,UAAM,IAAI,WAAW,qCAAqC;EAC5D;AAEA,QAAM,oBAAoB,eAAe,OAAO,KAAK;AACrD,MAAI,iBAAiB,oBAAoB,kBAAkB;AACzD,UAAM,IAAI,WAAW,kCAAkC;EACzD;AACF;AAGA,SAAS,sBAAsB,iBAAyB,MAAY;AAClE,MAAI,SAAS,GAAG;AAEd,WAAO,oBAAoB,OAAO,CAAC;EACrC,WAAW,SAAS,GAAG;AAErB,WAAO,eAAQ,WAAW,OAAO,gBAAgB,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG,CAAC;EACjF,WAAW,SAAS,GAAG;AAErB,WAAO,OAAO,gBAAgB,SAAS,EAAE,EAAE,SAAS,KAAK,GAAG;EAC9D,WAAW,SAAS,IAAI;AAEtB,WAAO,OAAO,gBAAgB,SAAS,EAAE,EAAE,SAAS,KAAK,GAAG;EAC9D,WAAW,SAAS,IAAI;AAEtB,WAAO,OAAO,gBAAgB,SAAS,EAAE,EAAE,SAAS,KAAK,GAAG;EAC9D;AACA,SAAO;AACT;AAGM,SAAU,yBAAyB,SAAmB,uBAA+B;AACzF,MAAI,YAAsB,CAAA;AAC1B,aAAW,UAAU,SAAS;AAC5B,UAAM,UAAU,OAAO,MAAM,IAAI,EAAE,EAAE,YAAW;AAChD,UAAM,mBAAmB,SAAS,SAAS,EAAE;AAC7C,cAAU,KAAK,gBAAgB;EACjC;AAEA,MAAI,UAA4B,CAAA;AAChC,UAAQ,QACN,CAAC,QAAQ,QAAS,QAAQ,MAAM,IAAI,sBAAsB,sBAAsB,GAAG,GAAG,UAAU,GAAG,CAAC,CAAE;AAGxG,SAAO;AACT;AAEM,SAAU,0BAA0B,mBAA2B;AACnE,QAAM,0BAA0B,kBAAkB;AAClD,MAAI,4BAA4B,GAAG;AACjC,UAAM,IAAI,WAAW,4BAA4B;EACnD;AACA,MAAI,0BAA0B,qCAAqC;AACjE,UAAM,IAAI,WAAW,mCAAmC,mCAAmC,WAAW;EACxG;AACF;;;;;;;;;;;;;;;;;;;;;;;;;AChBM,IAAO,oBAAP,MAAO,mBAAiB;EAmB5B,YAAoB,QAAiC,OAAmC;AAlBxF,uCAAA,IAAA,MAAA,MAAA;AACA,8CAAA,IAAA,MAAA,MAAA;AACA,+BAAA,IAAA,MAAA,MAAA;AACA,sCAAA,IAAA,MAAA,MAAA;AACA,iEAAA,IAAA,MAAA,MAAA;AACA,0DAAA,IAAA,MAAA,MAAA;AACA,wCAAA,IAAA,MAAA,MAAA;AACA,0CAAA,IAAA,MAAA,MAAA;AACA,mCAAA,IAAA,MAAA,MAAA;AACA,qCAAA,IAAA,MAAA,MAAA;AAEA,6DAAA,IAAA,MAAA,MAAA;AAQE,oBACE,OAAO,2CACP,kDAAkD;AAEpD,oBAAgB,OAAO,oCAAoC,2CAA2C;AACtG,mBAAe,OAAO,gBAAgB,uBAAuB;AAE7D,IAAAC,yBAAA,MAAI,oCAAoB,MAAM,iBAAe,GAAA;AAC7C,IAAAA,yBAAA,MAAI,2CAA2B,MAAM,wBAAsB,GAAA;AAC3D,IAAAA,yBAAA,MAAI,4BAAY,OAAO,SAAO,GAAA;AAC9B,IAAAA,yBAAA,MAAI,mCAAmB,OAAO,gBAAc,GAAA;AAC5C,IAAAA,yBAAA,MAAI,8DAA8C,OAAO,2CAAyC,GAAA;AAClG,IAAAA,yBAAA,MAAI,uDAAuC,OAAO,oCAAkC,GAAA;AACpF,IAAAA,yBAAA,MAAI,qCAAqB,OAAO,SAAO,GAAA;AACvC,IAAAA,yBAAA,MAAI,uCAAuB,OAAO,oBAAkB,GAAA;AACpD,IAAAA,yBAAA,MAAI,gCAAgB,MAAM,aAAW,GAAA;AACrC,IAAAA,yBAAA,MAAI,kCAAkB,MAAM,eAAa,GAAA;AACzC,IAAAA,yBAAA,MAAI,0DAA0C,aAC5CC,yBAAA,MAAI,uDAAA,GAAA,GACJA,yBAAA,MAAI,qCAAA,GAAA,CAAkB,GACvB,GAAA;EACH;EAEA,IAAW,UAAO;AAChB,WAAOA,yBAAA,MAAI,4BAAA,GAAA;EACb;EAEO,aAAa,OAClB,iBACA,wBACA,QAA+B;AAE/B,UAAM,cAAc,MAAM,YAAY,OAAO,wBAAwB,OAAO,kBAAkB;AAC9F,UAAM,gBAAgB,MAAM,cAAc,OAAO,wBAAwB,OAAO,4BAA4B;AAE5G,UAAM,WAAW,IAAI,mBAAkB,QAAQ;MAC7C;MACA;MACA;MACA;KACD;AAED,WAAO;EACT;EAEO,OAAO,aACZ,WACA,mBACA,gBACA,cACA,oCACA,kBAAwB;AAExB,yBAAqB,mBAAmB,mBAAmB;AAE3D,UAAM,aAAa,aAAkC,oCAAoC,gBAAgB;AACzG,UAAM,SAAS,WAAW,WAAW,mBAAmB,gBAAgB,YAAY;AAGpF,gBAAY,OAAO,OAAO,YAAY,kBAAU,sBAAsB,OAAO,QAAQ,SAAQ,CAAE;AAC/F,gBAAY,OAAO,OAAO,SAAS,kBAAU,sBAAsB,OAAO,IAAI;AAE9E,WAAO;EACT;;EAGO,aACL,WACA,mBACA,gBACA,cAA6B;AAE7B,yBAAqB,mBAAmB,mBAAmB;AAE3D,UAAM,SAASA,yBAAA,MAAI,0DAAA,GAAA,EAAuC,KAA3C,MACb,WACA,mBACA,gBACA,YAAY;AAId,gBAAY,OAAOA,yBAAA,MAAI,mCAAA,GAAA,CAAgB,MAAMA,yBAAA,MAAI,gCAAA,GAAA,EAAc,aAAa,OAAO;AACnF,gBAAY,OAAO,OAAO,sBAAsBA,yBAAA,MAAI,gCAAA,GAAA,EAAc,aAAa,iBAAiB;AAChG,gBAAY,OAAO,OAAO,YAAYA,yBAAA,MAAI,gCAAA,GAAA,EAAc,aAAa,OAAO;AAC5E,gBAAY,OAAO,OAAO,SAASA,yBAAA,MAAI,gCAAA,GAAA,EAAc,aAAa,IAAI;AACtE,gBAAY,OAAO,OAAO,OAAO,OAAO,MAAM,OAAOA,yBAAA,MAAI,qCAAA,GAAA,CAAkB,CAAC;AAE5E,WAAO;EACT;EAEO,qBAAqB,iBAAyB,aAAmB;AAEtE,gBAAYA,yBAAA,MAAI,8DAAA,GAAA,MAAgDA,yBAAA,MAAI,kCAAA,GAAA,EAAgB,aAAa,iBAAiB;AAClH,gBAAY,OAAOA,yBAAA,MAAI,mCAAA,GAAA,CAAgB,MAAMA,yBAAA,MAAI,kCAAA,GAAA,EAAgB,aAAa,OAAO;AAErF,WAAO,IAAI,0BACTA,yBAAA,MAAI,oCAAA,GAAA,GACJA,yBAAA,MAAI,4BAAA,GAAA,GACJ,iBACA,aACAA,yBAAA,MAAI,uCAAA,GAAA,GACJA,yBAAA,MAAI,kCAAA,GAAA,CAAe;EAEvB;EAEO,kBAAe;AACpB,WAAO,gBAAuB;EAChC;EAEO,eAAY;AAIjB,UAAM,IAAI,WAAW,4BAA4B;EACnD;EAEO,gBAAgB,OAAyB;AAI9C,UAAM,IAAI,WAAW,4BAA4B;EACnD;EAEO,MAAM,cAAc,SAAgC;AACzD,UAAM,YAA2B;AAGjC,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACvC,kBACE,OAAO,QAAQ,CAAC,MAAM,YAAY,QAAQ,CAAC,aAAa,YACxD,wCAAwC;IAE5C;AAGA,UAAM,iBAAkC,QAAQ,IAAI,CAAC,MACnD,OAAO,MAAM,WAAW,YAAY,cAAc,CAAC,CAAC,IAAI,YAAY,CAAC,CAAC;AAIxE,uBAAmB,cAAc;AAEjC,UAAM,mBAAkB,2BACtBA,yBAAA,MAAI,2CAAA,GAAA,GACJA,yBAAA,MAAI,uCAAA,GAAA,GACJ,cAAc;AAIhB,UAAM,oBAAmD;MACvD,mBAAmB;MACnB;;AAIF,UAAM,OAAO,MAAc,8BAA8BA,yBAAA,MAAI,oCAAA,GAAA,GAAmB,iBAAiB;AACjG,UAAM,SAAS,KAAK,SAAS,CAAC;AAG9B,UAAM,kBAAkB,SAAS,OAAO,eAAe;AACvD,UAAM,aAAa,OAAO,WAAW,IAAI,QAAQ;AAGjD,UAAM,SAAS;MACb,MAAM,kBAAU,sBAAsB,OAAO;MAC7C,SAAS,kBAAU,sBAAsB,OAAO;MAChD,SAASA,yBAAA,MAAI,mCAAA,GAAA;MACb,mBAAmBA,yBAAA,MAAI,uDAAA,GAAA;;AAEzB,UAAM,QAAQ,kBAAU,sBAAsB;AAI9C,UAAM,kBAAkB;AAExB,UAAM,qBAAqB,WAAW,IAAI,CAAC,cAA4B;AACrE,kBAAY,UAAU,WAAW,IAAI,CAAC;AACtC,YAAM,mBAAmB,eAAQ,gBAC/B,QACA,OACA,EAAE,WAAW,SAAS,iBAAiB,WAAW,gBAAe,GACjE,SAAS;AAEX,aAAO;IACT,CAAC;AAED,UAAM,mBAAmB,mBACvBA,yBAAA,MAAI,gCAAA,GAAA,EAAc,uBAAsB,GACxC,oBACAA,yBAAA,MAAI,gCAAA,GAAA,EAAc,aAAY,GAC9B,KAAK;AAGP,QAAI,CAAC,kBAAkB;AACrB,YAAM,MAAM,sCAAsC;IACpD;AAEA,UAAM,UAAU,2BAA2B,gBAAgB,eAAe;AAE1E,WAAO;EACT;EAEO,MAAM,YACX,SACA,aACA,WACA,WACA,mBACA,aACA,gBACA,cAA6B;AAE7B,UAAM,YAA2B;AAGjC,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACvC,kBACE,OAAO,QAAQ,CAAC,EAAE,WAAW,YAAY,QAAQ,CAAC,EAAE,kBAAkB,YACtE,wCAAwC;IAE5C;AAGA,UAAM,iBAA2D,QAAQ,IAAI,CAAC,OAAO;MACnF,QAAQ,OAAO,EAAE,WAAW,WAAW,YAAY,cAAc,EAAE,MAAM,CAAC,IAAI,YAAY,EAAE,MAAM;MAClG,iBAAiB,EAAE;MACnB;AAGF,uBAAmB,eAAe,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC;AAGtD,0BAAsB,OAAO,cAAc,GAAG,OAAO,YAAY,CAAC;AAElE,UAAM,mBAAkB,yBACtBA,yBAAA,MAAI,2CAAA,GAAA,GACJA,yBAAA,MAAI,uCAAA,GAAA,GACJ,gBACA,WAAW;AAIb,8BAA0B,iBAAiB;AAE3C,uBAAkB,8BAA8B,gBAAgB,iBAAiB;AAGjF,UAAM,mBAAkB,2BACtB,WACA,WACA,mBACA,aACA,gBACA,cACAA,yBAAA,MAAI,uDAAA,GAAA,GACJA,yBAAA,MAAI,qCAAA,GAAA,CAAkB;AAIxB,UAAM,oBAAiD;MACrD,qBAAqB;MACrB,iBAAiB;QACf,gBAAgB,eAAe,SAAQ;;QACvC,cAAc,aAAa,SAAQ;;;MAErC,kBAAkBA,yBAAA,MAAI,4BAAA,GAAA,EAAU,SAAQ;;MACxC,mBAAmB,kBAAkB,IAAI,CAAC,MAAM,eAAQ,WAAW,CAAC,CAAC;MACrE,aAAa,eAAQ,WAAW,WAAW;MAC3C,WAAW,SAAS,SAAS;MAC7B,WAAW,SAAS,SAAS;MAC7B;;AAIF,UAAM,OAAO,MAAc,4BAA4BA,yBAAA,MAAI,oCAAA,GAAA,GAAmB,iBAAiB;AAC/F,UAAM,SAAS,KAAK,SAAS,CAAC;AAE9B,UAAM,mBAAmB,OAAO,QAAQ;AAExC,UAAM,wBAAwB,iBAAiB,IAAI,eAAQ,QAAQ;AAEnE,UAAM,UAAU,yBACd,eAAe,IAAI,CAAC,MAAM,EAAE,MAAM,GAClC,qBAAqB;AAGvB,WAAO;EACT;;;;EAKO,aAAa,2BAClB,WACA,WACA,mBACA,aACA,gBACA,cACA,oCACA,kBAAwB;AAExB,gBAAY,SAAS,SAAS;AAC9B,gBAAY,SAAS,SAAS;AAE9B,UAAM,SAAiB,mBAAkB,aACvC,WACA,mBACA,gBACA,cACA,oCACA,gBAAgB;AAGlB,UAAM,QAAsC,CAAA;AAC5C,UAAM,OAAO,WAAW,IAAI,OAAO,MAAM,OAAO,WAAW;AAE3D,UAAM,gBAAgB,eAAQ,gBAAgB,OAAO,QAAQ,OAAO,OAAO,SAAS,SAAS;AAE7F,UAAM,0BAA0B,eAAQ,WAAW,aAAa;AAChE,UAAM,wBAAwB,eAAQ,WAAW,WAAW;AAE5D,QAAI,4BAA4B,uBAAuB;AACrD,YAAM,IAAI,WAAW,4BAA4B;IACnD;EACF;EAEO,aAAa,2BAClB,wBACA,oBACA,SAAiB;AAEjB,UAAM,SAAS,CAAC,qEAAqE;AACrF,UAAM,MAAM,IAAI,eAAQ,SAAS,oBAAoB,QAAQ,sBAAsB;AAEnF,UAAM,gBAAgB,QAAQ,IAAI,OAAO,MAAK;AAC5C,YAAM,cAAc,eAAQ,QAAQ,eAAQ,SAAS,CAAC,GAAG,EAAE;AAE3D,YAAM,UAAU,MAAM,IAAI,uBAAuB,WAAW;AAC5D,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI,WAAW,UAAU,CAAC,wCAAwC;MAC1E;IACF,CAAC;AAED,WAAO,QAAQ,IAAI,aAAa,EAAE,MAAM,CAAC,MAAK;AAC5C,YAAM;IACR,CAAC;EACH;;EAGO,aAAa,yBAClB,wBACA,oBACA,SACA,aAAmB;AAEnB,UAAM,SAAS,CAAC,8EAA8E;AAC9F,UAAM,MAAM,IAAI,eAAQ,SAAS,oBAAoB,QAAQ,sBAAsB;AAEnF,UAAM,gBAAgB,QAAQ,IAAI,OAAO,EAAE,QAAQ,gBAAe,MAAM;AACtE,YAAM,cAAc,eAAQ,QAAQ,eAAQ,SAAS,MAAM,GAAG,EAAE;AAEhE,YAAM,cAAc,MAAM,IAAI,eAAe,aAAa,WAAW;AACrE,YAAM,kBAAkB,MAAM,IAAI,eAAe,aAAa,eAAe;AAC7E,UAAI,CAAC,aAAa;AAChB,cAAM,IAAI,WAAW,QAAQ,WAAW,6CAA6C,MAAM,GAAG;MAChG;AACA,UAAI,CAAC,iBAAiB;AACpB,cAAM,IAAI,WAAW,iBAAiB,eAAe,6CAA6C,MAAM,GAAG;MAC7G;AACA,UAAI,gBAAgB,iBAAiB;AACnC,cAAM,IAAI,WACR,eAAe,WAAW,qEAAqE;MAEnG;IACF,CAAC;AAED,WAAO,QAAQ,IAAI,aAAa,EAAE,MAAM,CAAC,MAAK;AAC5C,YAAM;IACR,CAAC;EACH;EAEO,OAAO,8BAA8B,SAA+B,mBAA2B;AACpG,UAAM,MAAM,oBAAI,IAAG;AAEnB,aAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,EAAE,GAAG;AACjD,YAAM,MAAM,kBAAkB,CAAC,EAAE,YAAW;AAC5C,UAAI,CAAC,IAAI,IAAI,GAAG,GAAG;AACjB,YAAI,IAAI,GAAG;MACb;IACF;AAEA,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACvC,UAAI,CAAC,IAAI,IAAI,QAAQ,CAAC,EAAE,gBAAgB,YAAW,CAAE,GAAG;AACtD,cAAM,IAAI,WACR,oBAAoB,QAAQ,CAAC,EAAE,eAAe,yBAAyB,QAAQ,CAAC,EAAE,MAAM,yDAAyD;MAErJ;IACF;EACF;;;;;AC7aF,eAAsB,yBACpB,UACA,qBACA,MACA,SAAmD;AAGnD,kCAAgC,mBAAmB;AAGnD,QAAM,kBAAkB,MAAM,2BAA2B,UAAU,OAAO;AAG1E,QAAM,UAAU,yBAAyB,QAAQ;AAGjD,kCAAgC,qBAAqB,OAAO;AAG5D,QAAM,EAAE,WAAW,kBAAiB,IAAK,MAAM,0CAC7C,UACA,qBACA,MACA,eAAe;AAOjB,QAAM,cAAc,MAAM,KAAK,WAAU;AAEzC,QAAM,UAAgC,oBAAoB,IAAI,CAAC,MAAK;AAClE,WAAO,EAAE,QAAQ,EAAE,eAAe,iBAAiB,EAAE,gBAAe;EACtE,CAAC;AAGD,QAAM,mBAAqC,MAAM,SAAS,YACxD,SACA,gBAAgB,QAAQ,YACxB,gBAAgB,QAAQ,WACxB,WACA,mBACA,aACA,gBAAgB,gBAChB,gBAAgB,YAAY;AAG9B,SAAO;AACT;AAaA,eAAe,2BACb,UACA,SAAiC;AArHnC;AAuHE,MAAI;AAEJ,OAAI,mCAAS,aAAY,QAAW;AAClC,cAAU,EAAE,GAAG,QAAQ,QAAO;AAC9B,kBAAc,OAAO;EACvB,OAAO;AACL,cAAU,SAAS,gBAAe;EACpC;AAEA,QAAM,mBAAiB,wCAAS,aAAT,mBAAmB,mBAAkB,aAAY;AACxE,QAAM,iBAAe,wCAAS,aAAT,mBAAmB,iBAAgB,kBAAU;AAElE,QAAM,uBAAuB,aAAa,gBAAgB,gBAAgB;AAC1E,QAAM,qBAAqB,aAAa,cAAc,cAAc;AAEpE,SAAO;IACL;IACA,gBAAgB;IAChB,cAAc;;AAElB;AAEA,eAAe,0CACb,UACA,mBACA,MACA,iBAA0C;AAE1C,MAAI,kBAAkB,WAAW,GAAG;AAClC,UAAM,IAAI,WAAW,mCAAmC;EAC1D;AAGA,QAAM,8BAA8B,yCAAyC,iBAAiB;AAE9F,MAAI,4BAA4B,WAAW,GAAG;AAC5C,UAAM,IAAI,WAAW,yCAAyC;EAChE;AAEA,QAAM,SAAS,SAAS,aACtB,gBAAgB,QAAQ,WACxB,6BACA,gBAAgB,gBAChB,gBAAgB,YAAY;AAG9B,QAAM,YAAY,MAAM,KAAK,cAC3B,OAAO,QACP,EAAE,gCAAgC,OAAO,MAAM,+BAA8B,GAC7E,OAAO,OAAO;AAGhB,SAAO;IACL;IACA,mBAAmB;;AAEvB;AAEA,SAAS,yBAAyB,UAAuB;AACvD,QAAM,cAAc,SAAS,aAAa,IAAI,CAAC,eAAQ,WAAW,GAAG,GAAG,CAAC;AACzE,SAAO,YAAY,QAAQ;AAC7B;AAEA,SAAS,yCACP,mBAA2D;AAE3D,QAAM,MAAM,oBAAI,IAAG;AAGnB,WAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,EAAE,GAAG;AACjD,UAAM,KAAK,kBAAkB,CAAC;AAC9B,QAAI;AACJ,QAAI,OAAO,OAAO,UAAU;AAC1B,wBAAkB;IACpB,OAAO;AACL,wBAAkB,GAAG;IACvB;AACA,UAAM,MAAM,eAAQ,WAAW,eAAe;AAC9C,QAAI,CAAC,IAAI,IAAI,GAAG,GAAG;AACjB,UAAI,IAAI,GAAG;IACb;EACF;AAGA,SAAO,CAAC,GAAG,GAAG,EAAE,KAAK,CAAC,GAAG,MAAK;AAC5B,UAAM,QAAQ,EAAE,YAAW;AAC3B,UAAM,QAAQ,EAAE,YAAW;AAC3B,QAAI,QAAQ,OAAO;AACjB,aAAO;IACT;AACA,QAAI,QAAQ,OAAO;AACjB,aAAO;IACT;AACA,WAAO;EACT,CAAC;AACH;AAEA,SAAS,gCAAgC,mBAA2D;AAClG,MAAI,kBAAkB,WAAW,GAAG;AAClC,UAAM,IAAI,WAAW,mCAAmC;EAC1D;AAEA,WAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,EAAE,GAAG;AACjD,UAAM,KAAK,kBAAkB,CAAC;AAE9B,QAAI;AACJ,QAAI,OAAO,OAAO,UAAU;AAC1B,wBAAkB;IACpB,OAAO;AACL,wBAAkB,GAAG;IACvB;AACA,oBAAgB,iBAAiB,iBAAiB;EACpD;AACF;AAEA,SAAS,gCACP,qBACA,SAAgB;AAEhB,MAAI,oBAAoB,WAAW,GAAG;AACpC,UAAM,IAAI,WAAW,sCAAsC;EAC7D;AAEA,WAAS,IAAI,GAAG,IAAI,oBAAoB,QAAQ,EAAE,GAAG;AACnD,UAAM,OAAO,oBAAoB,CAAC;AAElC,gBAAY,OAAO,KAAK,eAAe;MACrC,GAAI,KAAK,cAAc,UAAa,EAAE,WAAW,KAAK,UAAS;MAC/D,GAAI,YAAY,UAAa,EAAE,QAAgB;KAChD;AAED,oBAAgB,KAAK,iBAAiB,iBAAiB;EACzD;AACF;;;AC7OM,SAAU,uBAAuB,aAAmB;AACxD,QAAM,MAAM,eAAQ,SAAS,gBAAe,EAAG,OAC7C,CAAC,SAAS,GACV,CAAC,OAAO,eAAQ,UAAU,eAAQ,YAAY,WAAW,CAAC,CAAC,IAAI,EAAE,CAAC;AAEpE,SAAO,eAAQ,QACb,OAAO,eAAQ,UAAU,GAAG,CAAC,IAAI,qEACjC,EAAE;AAEN;AAeA,eAAsB,aAAa,UAA2B,SAAiB,OAAa;AAC1F,kBAAgB,OAAO;AACvB,QAAM,aAAa,eAAQ,QAAQ,OAAO,EAAE;AAE5C,QAAM,OAAO,MAAM,oBAAoB,UAAU,oBAAoB,CAAC,SAAS,YAAY,QAAQ,CAAC;AAEpG,wBAAsB,IAAI;AAE1B,SAAO;AACT;AAEA,eAAsB,aACpB,UACA,YACA,SACA,OACA,cAAoB;AAEpB,kBAAgB,OAAO;AACvB,wBAAsB,YAAY;AAElC,MAAI,eAAe,wBAAwB;AACzC,UAAM,IAAI,WAAW,+CAA+C,UAAU,WAAW;EAC3F;AAEA,QAAM,aAAa,eAAQ,QAAQ,OAAO,EAAE;AAE5C,QAAM,oBAAoB,UAAU,YAAY,CAAC,SAAS,YAAY,YAAY,CAAC;AACrF;AAaA,eAAsB,wBACpB,UACA,iBACA,wBACA,cAAoB;AAEpB,QAAM,YAAsB,CAAA;AAC5B,WAAS,IAAI,GAAG,IAAI,cAAc,EAAE,GAAG;AACrC,UAAM,OAAO,MAAM,aAAa,UAAU,iBAAiB,OAAO,sBAAsB,IAAI,OAAO,CAAC,CAAC;AACrG,cAAU,KAAK,IAAI;EACrB;AAEA,QAAM,WAAW,2BAA2B,eAAe;AAE3D,WAAS,IAAI,GAAG,IAAI,cAAc,EAAE,GAAG;AACrC,UAAM,OAAO,UAAU,CAAC;AACxB,QAAI,OAAO,SAAS,YAAY,CAAC,eAAQ,YAAY,IAAI,KAAK,KAAK,WAAW,IAAI;AAChF,YAAM,IAAI,WAAW,QAAQ;IAC/B;AAEA,UAAM,MAAM,eAAQ,QAAQ,OAAO,IAAI,GAAG,EAAE;AAC5C,QAAI;AACF,gBAAU,CAAC,IAAI,eAAQ,WAAW,GAAG;IACvC,QAAQ;AACN,YAAM,IAAI,WAAW,QAAQ;IAC/B;EACF;AAEA,SAAO;AACT;AAEA,eAAsB,wBACpB,UACA,iBAAuB;AAEvB,QAAM,yBAAyB,uBAAuB,oCAAoC;AAC1F,cACE,2BAA2B,sEAC3B,6DAA6D;AAM/D,MAAI,OAAO,MAAM,aAAa,UAAU,iBAAiB,OAAO,sBAAsB,IAAI,OAAO,CAAC,CAAC;AACnG,SAAO,KAAK,QAAQ,OAAO,EAAE,EAAE,SAAS,IAAI,GAAG;AAG/C,QAAM,iBAAiB,OAAO,KAAK,MAAM,GAAG;AAC5C,QAAM,cAAc,OAAO,cAAc;AAGzC,QAAM,mBAAmB,SAAS,KAAK,MAAM,KAAK,GAAG,GAAG,EAAE;AAC1D,QAAM,eAAe,qBAAqB;AAE1C,SAAO,EAAE,aAAa,aAAY;AACpC;AAEA,eAAsB,wBACpB,UACA,iBACA,OAAqD;AAkBrD,QAAM,yBAAyB,uBAAuB,oCAAoC;AAC1F,cACE,2BAA2B,sEAC3B,6DAA6D;AAI/D,QAAM,mBAAmB,eAAQ,QAAQ,MAAM,aAAa,CAAC;AAE7D,QAAM,mBAAmB,MAAM,eAAe,SAAS;AAEvD,QAAM,YAAY,mBAAmB,iBAAiB,MAAM,CAAC;AAC7D,QAAM,kBAAkB,eAAQ,aAAa,WAAW,EAAE;AAE1D,QAAM,aACJ,UACA,wBACA,iBACA,OAAO,sBAAsB,IAAI,OAAO,CAAC,GACzC,eAAe;AAEnB;AAEA,eAAsB,kBAAkB,UAA2B,iBAAyB,cAAoB;AAa9G,QAAM,yBAAyB,uBAAuB,8BAA8B;AACpF,cACE,2BAA2B,sEAC3B,uDAAuD;AAGzD,QAAM,kBAAkB,eAAQ,aAAa,cAAc,EAAE;AAE7D,QAAM,aACJ,UACA,wBACA,iBACA,OAAO,sBAAsB,IAAI,OAAO,CAAC,GACzC,eAAe;AAEnB;;;AChKA,eAAsB,qBACpB,UACA,iBAAuB;AAEvB,QAAM,mCAAmC,uBAAuB,6BAA6B;AAC7F,cACE,qCAAqC,oEAAoE;AAa3G,QAAM,YAAsB,MAAM;IAChC;IACA;IACA;IACA;;EAAyC;AAG3C,SAAO;IACL,YAAY,UAAU,CAAC;IACvB,oBAAoB,UAAU,CAAC;IAC/B,yBAAyB,UAAU,CAAC;IACpC,oBAAoB,UAAU,CAAC;;AAEnC;;;AClFO,IAAM,UAAkB;",
  "names": ["FheType", "FhevmType", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "version", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "FhevmOperator", "__classPrivateFieldSet", "__classPrivateFieldGet", "FhevmMockProviderType", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "__classPrivateFieldGet"]
}
