import {
  JsonRpcProvider,
  ethers_exports
} from "./chunk-VNYHJJGT.js";
import "./chunk-PNK6QTI4.js";
import "./chunk-MYKOZ2SL.js";
import {
  __export
} from "./chunk-ONY6HBPH.js";

// node_modules/@fhevm/mock-utils/_esm/constants.js
var constants = {
  FHEVM_HANDLE_VERSION: 0,
  DEFAULT_DURATION_DAYS: 365,
  PUBLIC_DECRYPT_EIP712: {
    domain: { version: "1", name: "Decryption" },
    types: {
      PublicDecryptVerification: [
        {
          name: "ctHandles",
          type: "bytes32[]"
        },
        {
          name: "decryptedResult",
          type: "bytes"
        },
        {
          name: "extraData",
          type: "bytes"
        }
      ]
    }
  },
  INPUT_VERIFICATION_EIP712: {
    domain: { version: "1", name: "InputVerification" },
    types: {
      CiphertextVerification: [
        {
          name: "ctHandles",
          type: "bytes32[]"
        },
        {
          name: "userAddress",
          type: "address"
        },
        {
          name: "contractAddress",
          type: "address"
        },
        {
          name: "contractChainId",
          type: "uint256"
        },
        {
          name: "extraData",
          type: "bytes"
        }
      ]
    }
  },
  TEST_MNEMONIC: "test test test test test test test future home encrypt virtual machine",
  DEFAULT_KMS_SIGNERS_ACCOUNTS: {
    initialIndex: 0,
    path: "m/44'/60'/1'/0"
  },
  DEFAULT_COPROCESSOR_SIGNERS_ACCOUNTS: {
    initialIndex: 0,
    path: "m/44'/60'/2'/0"
  },
  DEFAULT_RELAYER_SIGNERS_ACCOUNTS: {
    initialIndex: 0,
    path: "m/44'/60'/3'/0"
  },
  SEPOLIA_ETHEREUM_TESTNET_CHAINID: 11155111,
  FHEVM_CORE_CONTRACTS_PACKAGE_NAME: "@fhevm/core-contracts",
  ZAMA_FHE_ORACLE_SOLIDITY_PACKAGE_NAME: "@zama-fhe/oracle-solidity"
};
Object.freeze(constants);
var constants_default = constants;

// node_modules/@fhevm/mock-utils/_esm/fhevm/relayer/index.js
var relayer_exports = {};
__export(relayer_exports, {
  FHEVM_AWAIT_DECRYPTION_ORACLE: () => FHEVM_AWAIT_DECRYPTION_ORACLE,
  FHEVM_CREATE_DECRYPTION_SIGNATURES: () => FHEVM_CREATE_DECRYPTION_SIGNATURES,
  FHEVM_GET_CLEAR_TEXT: () => FHEVM_GET_CLEAR_TEXT,
  RELAYER_METADATA: () => RELAYER_METADATA,
  RELAYER_V1_INPUT_PROOF: () => RELAYER_V1_INPUT_PROOF,
  RELAYER_V1_PUBLIC_DECRYPT: () => RELAYER_V1_PUBLIC_DECRYPT,
  RELAYER_V1_USER_DECRYPT: () => RELAYER_V1_USER_DECRYPT,
  assertIsMockRelayerV1InputProofPayload: () => assertIsMockRelayerV1InputProofPayload,
  assertIsRelayerMetadata: () => assertIsRelayerMetadata,
  assertIsRelayerV1InputProofResponse: () => assertIsRelayerV1InputProofResponse,
  assertIsRelayerV1PublicDecryptPayload: () => assertIsRelayerV1PublicDecryptPayload,
  assertIsRelayerV1PublicDecryptResponse: () => assertIsRelayerV1PublicDecryptResponse,
  assertIsRelayerV1UserDecryptPayload: () => assertIsRelayerV1UserDecryptPayload,
  assertIsRelayerV1UserDecryptResponse: () => assertIsRelayerV1UserDecryptResponse,
  requestFhevmAwaitDecryptionOracle: () => requestFhevmAwaitDecryptionOracle,
  requestFhevmCreateDecryptionSignatures: () => requestFhevmCreateDecryptionSignatures,
  requestFhevmGetClearText: () => requestFhevmGetClearText,
  requestRelayerMetadata: () => requestRelayerMetadata,
  requestRelayerV1InputProof: () => requestRelayerV1InputProof,
  requestRelayerV1PublicDecrypt: () => requestRelayerV1PublicDecrypt,
  requestRelayerV1UserDecrypt: () => requestRelayerV1UserDecrypt
});

// node_modules/@fhevm/mock-utils/_esm/fhevm/relayer/methods.js
var RELAYER_METADATA = "fhevm_relayer_metadata";
var RELAYER_V1_PUBLIC_DECRYPT = "fhevm_relayer_v1_public_decrypt";
var RELAYER_V1_USER_DECRYPT = "fhevm_relayer_v1_user_decrypt";
var RELAYER_V1_INPUT_PROOF = "fhevm_relayer_v1_input_proof";
var FHEVM_GET_CLEAR_TEXT = "fhevm_getClearText";
var FHEVM_AWAIT_DECRYPTION_ORACLE = "fhevm_awaitDecryptionOracle";
var FHEVM_CREATE_DECRYPTION_SIGNATURES = "fhevm_createDecryptionSignatures";

// node_modules/@fhevm/mock-utils/_esm/utils/error.js
function assertFhevm(check, message) {
  if (!check) {
    const title = "Fhevm assertion failed";
    message = message ? title + ": " + message : title;
    throw new FhevmError(message);
  }
}
function assertIsArray(value, valueName) {
  assertFhevm(Array.isArray(value), `${valueName ?? "value"} is not an array`);
}
function assertIsArrayProperty(value, propertyNames, typeName) {
  if (typeof value !== "object" || value === null) {
    throw new FhevmError(`${typeName} must be a non-null object.`);
  }
  for (const key of propertyNames) {
    const prop = value[key];
    if (prop === void 0 || prop === null) {
      throw new FhevmError(`Invalid ${typeName}. Missing '${key}' property.`);
    }
    if (!Array.isArray(prop)) {
      throw new FhevmError(`Expected '${key}' in ${typeName} to be an array.`);
    }
  }
}
function assertIsObjectProperty(value, propertyNames, typeName) {
  if (typeof value !== "object" || value === null) {
    throw new FhevmError(`${typeName} must be a non-null object.`);
  }
  for (const key of propertyNames) {
    const prop = value[key];
    if (prop === void 0 || prop === null) {
      throw new FhevmError(`Invalid ${typeName}. Missing '${key}' property.`);
    }
    if (typeof prop !== "object") {
      throw new FhevmError(`Expected '${key}' in ${typeName} to be an object. Got ${typeof prop} instead.`);
    }
  }
}
var FhevmError = class extends Error {
  constructor(message, options) {
    super(message, options);
    Object.defineProperty(this, "__isFhevmError", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.__isFhevmError = true;
  }
};
function isHardhatProviderError(other) {
  if (other === void 0 || other === null) {
    return false;
  }
  if (!(other instanceof Error)) {
    return false;
  }
  if (!("code" in other)) {
    return false;
  }
  if (!("_isProviderError" in other)) {
    return false;
  }
  return other._isProviderError === true;
}
function isHardhatError(other) {
  if (other === void 0 || other === null) {
    return false;
  }
  if (!(other instanceof Error)) {
    return false;
  }
  if (!("number" in other)) {
    return false;
  }
  if (!("_isHardhatError" in other)) {
    return false;
  }
  return other._isHardhatError === true;
}

// node_modules/@fhevm/mock-utils/_esm/utils/runtime.js
function isNodeRuntime() {
  return typeof process !== "undefined" && process.versions != null && process.versions.node != null;
}

// node_modules/@fhevm/mock-utils/_esm/ethers/provider.js
async function minimalProviderSend(provider, method, params) {
  let response;
  if ("send" in provider && typeof provider.send === "function") {
    response = await provider.send(method, params);
  } else if ("request" in provider && typeof provider.request === "function") {
    response = await provider.request({ method, params });
  } else {
    throw new FhevmError("Invalid provider: must implement request() or send()");
  }
  return response;
}
async function connectedChainId(provider) {
  try {
    return await getProviderChainId(provider);
  } catch (e) {
    if (isHardhatProviderError(e)) {
      if (e.code === -32004) {
        throw e;
      }
    } else if (isHardhatError(e)) {
      if (e.number === 108) {
        return void 0;
      }
    } else if (isNodeRuntime()) {
      if (e instanceof Error && "code" in e) {
        if (e.code === "ECONNREFUSED") {
          return void 0;
        }
      }
    }
    throw e;
  }
}
async function getProviderChainId(provider) {
  const chainIdHex = await minimalProviderSend(provider, "eth_chainId", []);
  return Number(BigInt(chainIdHex));
}
async function connectedWeb3Client(provider) {
  try {
    return { client: await getWeb3ClientVersion(provider), couldNotConnect: false };
  } catch (e) {
    if (isHardhatProviderError(e)) {
      if (e.code === -32004) {
        return { client: void 0, couldNotConnect: false };
      }
    } else if (isHardhatError(e)) {
      if (e.number === 108) {
        return { client: void 0, couldNotConnect: true };
      }
    } else if (isNodeRuntime()) {
      if (e instanceof Error && "code" in e) {
        if (e.code === "ECONNREFUSED") {
          return { client: void 0, couldNotConnect: true };
        }
      }
    }
    throw e;
  }
}
async function getWeb3ClientVersion(provider) {
  return minimalProviderSend(provider, "web3_clientVersion", []);
}

// node_modules/@fhevm/mock-utils/_esm/utils/string.js
function removePrefix(s, prefix) {
  return s.startsWith(prefix) ? s.substring(prefix.length) : s;
}
function ensure0x(s) {
  return !s.startsWith("0x") ? `0x${s}` : s;
}
function remove0x(s) {
  return s.startsWith("0x") ? s.substring(2) : s;
}
function ensurePrefix(s, prefix) {
  return !s.startsWith(prefix) ? prefix + s : s;
}
function ensureSuffix(s, suffix) {
  return !s.endsWith(suffix) ? s + suffix : s;
}
function assertIsString(value, valueName) {
  assertFhevm(typeof value === "string", `${valueName ?? "value"} is not of type string, got ${typeof value} instead`);
}
function assertIsStringArray(value, valueName) {
  if (!Array.isArray(value)) {
    throw new FhevmError(`${valueName ?? "value"} is not an array of string`);
  }
  for (let i = 0; i < value.length; ++i) {
    assertFhevm(typeof value[i] === "string", `${valueName ?? "value"}[${i}] is not of type string, got ${typeof value[i]} instead`);
  }
}
function assertIsStringProperty(value, propertyNames, typeName) {
  if (typeof value !== "object" || value === null) {
    throw new FhevmError(`${typeName} must be a non-null object.`);
  }
  for (const key of propertyNames) {
    const prop = value[key];
    if (typeof prop !== "string") {
      throw new FhevmError(`Expected '${key}' in ${typeName} to be a string, but got ${typeof prop} instead.`);
    }
  }
}
function assertIsStringArrayProperty(value, propertyNames, typeName) {
  if (typeof value !== "object" || value === null) {
    throw new FhevmError(`${typeName} must be a non-null object.`);
  }
  for (const key of propertyNames) {
    const prop = value[key];
    assertIsStringArray(prop, ` ${typeName}.${key}`);
  }
}

// node_modules/@fhevm/mock-utils/_esm/utils/math.js
var MAX_UINT8 = 0xffn;
var MAX_UINT64 = 0xffffffffffffffffn;
var MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn;
function toUIntNumber(value, name) {
  try {
    const bn = ethers_exports.getUint(value, name);
    return ethers_exports.getNumber(bn);
  } catch {
    throw new FhevmError(`${name} is not a positive integer`);
  }
}
function isInt(value) {
  if (typeof value === "bigint") {
    return true;
  }
  if (typeof value === "number") {
    return Number.isInteger(value);
  }
  return false;
}
function isUInt(value) {
  if (!isInt(value)) {
    return false;
  }
  return value >= 0;
}
function boolToBigInt(value) {
  if (value === null || value === void 0) {
    throw new FhevmError("Missing value");
  }
  let zeroOrOne = 0n;
  if (typeof value === "bigint") {
    if (value !== 1n && value !== 0n) {
      throw new FhevmError("The value must be 1 or 0.");
    }
    zeroOrOne = value;
  } else if (typeof value === "number") {
    if (value !== 1 && value !== 0) {
      throw new FhevmError("The value must be 1 or 0.");
    }
    zeroOrOne = value === 0 ? 0n : 1n;
  } else if (typeof value === "boolean") {
    zeroOrOne = value === true ? 1n : 0n;
  } else {
    throw new FhevmError("The value must be a boolean, a number or a bigint.");
  }
  return zeroOrOne;
}
function bitwiseNotUIntBits(value, numBits) {
  if (typeof value !== "bigint") {
    throw new FhevmError("The input value must be a BigInt.");
  }
  if (!isUInt(numBits)) {
    throw new FhevmError("The numBits parameter must be a positive integer.");
  }
  const BIT_MASK = (BigInt(1) << BigInt(numBits)) - BigInt(1);
  return ~value & BIT_MASK;
}
function getMaxBigInt(bitLength) {
  if (!isUInt(bitLength)) {
    throw new FhevmError(`Invalid bitLength argument (${bitLength}), expecting a positive integer value.`);
  }
  return (1n << BigInt(bitLength)) - 1n;
}
function log2BigInt(x) {
  const n = x.toString(2).length - 1;
  return x <= 0n ? 0n : BigInt(n);
}
function getRandomBigInt(numBits) {
  if (numBits <= 0) {
    throw new TypeError("Number of bits must be greater than 0");
  }
  const numBytes = Math.ceil(numBits / 8);
  const randomBytes = ethers_exports.randomBytes(numBytes);
  let randomBigInt = BigInt(0);
  for (let i = 0; i < numBytes; i++) {
    randomBigInt = randomBigInt << BigInt(8) | BigInt(randomBytes[i]);
  }
  const mask = (BigInt(1) << BigInt(numBits)) - BigInt(1);
  randomBigInt = randomBigInt & mask;
  return randomBigInt;
}
function assertIsUintNumber(value, valueName) {
  assertFhevm(typeof value === "number", `${valueName ?? "value"} is not of type number, got ${typeof value} instead`);
  assertFhevm(isUInt(value), `${valueName ?? "value"} is not an uint, got ${typeof value} instead`);
}
function assertIsBigUint8(value, valueName) {
  _assertIsBigUint(value, 8, MAX_UINT8, valueName);
}
function assertIsBigUint256(value, valueName) {
  _assertIsBigUint(value, 256, MAX_UINT256, valueName);
}
function _assertIsBigUint(value, bitLen, max, valueName) {
  assertFhevm(typeof value === "bigint", `${valueName ?? "value"} is not of type bigint, got ${typeof value} instead`);
  assertFhevm(value >= 0 && value <= max, `${valueName ?? "value"} is larger than uint${bitLen} maximum value, got ${value} > ${max}`);
}
function assertIsNumber(value, valueName) {
  assertFhevm(typeof value === "number", `${valueName ?? "value"} is not of type number, got ${typeof value} instead`);
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/FheType.js
var FheType;
(function(FheType2) {
  FheType2[FheType2["Bool"] = 0] = "Bool";
  FheType2[FheType2["Uint4"] = 1] = "Uint4";
  FheType2[FheType2["Uint8"] = 2] = "Uint8";
  FheType2[FheType2["Uint16"] = 3] = "Uint16";
  FheType2[FheType2["Uint32"] = 4] = "Uint32";
  FheType2[FheType2["Uint64"] = 5] = "Uint64";
  FheType2[FheType2["Uint128"] = 6] = "Uint128";
  FheType2[FheType2["Uint160"] = 7] = "Uint160";
  FheType2[FheType2["Uint256"] = 8] = "Uint256";
  FheType2[FheType2["Uint512"] = 9] = "Uint512";
  FheType2[FheType2["Uint1024"] = 10] = "Uint1024";
  FheType2[FheType2["Uint2048"] = 11] = "Uint2048";
  FheType2[FheType2["Uint2"] = 12] = "Uint2";
  FheType2[FheType2["Uint6"] = 13] = "Uint6";
  FheType2[FheType2["Uint10"] = 14] = "Uint10";
  FheType2[FheType2["Uint12"] = 15] = "Uint12";
  FheType2[FheType2["Uint14"] = 16] = "Uint14";
  FheType2[FheType2["Int2"] = 17] = "Int2";
  FheType2[FheType2["Int4"] = 18] = "Int4";
  FheType2[FheType2["Int6"] = 19] = "Int6";
  FheType2[FheType2["Int8"] = 20] = "Int8";
  FheType2[FheType2["Int10"] = 21] = "Int10";
  FheType2[FheType2["Int12"] = 22] = "Int12";
  FheType2[FheType2["Int14"] = 23] = "Int14";
  FheType2[FheType2["Int16"] = 24] = "Int16";
  FheType2[FheType2["Int32"] = 25] = "Int32";
  FheType2[FheType2["Int64"] = 26] = "Int64";
  FheType2[FheType2["Int128"] = 27] = "Int128";
  FheType2[FheType2["Int160"] = 28] = "Int160";
  FheType2[FheType2["Int256"] = 29] = "Int256";
  FheType2[FheType2["AsciiString"] = 30] = "AsciiString";
  FheType2[FheType2["Int512"] = 31] = "Int512";
  FheType2[FheType2["Int1024"] = 32] = "Int1024";
  FheType2[FheType2["Int2048"] = 33] = "Int2048";
  FheType2[FheType2["Uint24"] = 34] = "Uint24";
  FheType2[FheType2["Uint40"] = 35] = "Uint40";
  FheType2[FheType2["Uint48"] = 36] = "Uint48";
  FheType2[FheType2["Uint56"] = 37] = "Uint56";
  FheType2[FheType2["Uint72"] = 38] = "Uint72";
  FheType2[FheType2["Uint80"] = 39] = "Uint80";
  FheType2[FheType2["Uint88"] = 40] = "Uint88";
  FheType2[FheType2["Uint96"] = 41] = "Uint96";
  FheType2[FheType2["Uint104"] = 42] = "Uint104";
  FheType2[FheType2["Uint112"] = 43] = "Uint112";
  FheType2[FheType2["Uint120"] = 44] = "Uint120";
  FheType2[FheType2["Uint136"] = 45] = "Uint136";
  FheType2[FheType2["Uint144"] = 46] = "Uint144";
  FheType2[FheType2["Uint152"] = 47] = "Uint152";
  FheType2[FheType2["Uint168"] = 48] = "Uint168";
  FheType2[FheType2["Uint176"] = 49] = "Uint176";
  FheType2[FheType2["Uint184"] = 50] = "Uint184";
  FheType2[FheType2["Uint192"] = 51] = "Uint192";
  FheType2[FheType2["Uint200"] = 52] = "Uint200";
  FheType2[FheType2["Uint208"] = 53] = "Uint208";
  FheType2[FheType2["Uint216"] = 54] = "Uint216";
  FheType2[FheType2["Uint224"] = 55] = "Uint224";
  FheType2[FheType2["Uint232"] = 56] = "Uint232";
  FheType2[FheType2["Uint240"] = 57] = "Uint240";
  FheType2[FheType2["Uint248"] = 58] = "Uint248";
  FheType2[FheType2["Int24"] = 59] = "Int24";
  FheType2[FheType2["Int40"] = 60] = "Int40";
  FheType2[FheType2["Int48"] = 61] = "Int48";
  FheType2[FheType2["Int56"] = 62] = "Int56";
  FheType2[FheType2["Int72"] = 63] = "Int72";
  FheType2[FheType2["Int80"] = 64] = "Int80";
  FheType2[FheType2["Int88"] = 65] = "Int88";
  FheType2[FheType2["Int96"] = 66] = "Int96";
  FheType2[FheType2["Int104"] = 67] = "Int104";
  FheType2[FheType2["Int112"] = 68] = "Int112";
  FheType2[FheType2["Int120"] = 69] = "Int120";
  FheType2[FheType2["Int136"] = 70] = "Int136";
  FheType2[FheType2["Int144"] = 71] = "Int144";
  FheType2[FheType2["Int152"] = 72] = "Int152";
  FheType2[FheType2["Int168"] = 73] = "Int168";
  FheType2[FheType2["Int176"] = 74] = "Int176";
  FheType2[FheType2["Int184"] = 75] = "Int184";
  FheType2[FheType2["Int192"] = 76] = "Int192";
  FheType2[FheType2["Int200"] = 77] = "Int200";
  FheType2[FheType2["Int208"] = 78] = "Int208";
  FheType2[FheType2["Int216"] = 79] = "Int216";
  FheType2[FheType2["Int224"] = 80] = "Int224";
  FheType2[FheType2["Int232"] = 81] = "Int232";
  FheType2[FheType2["Int240"] = 82] = "Int240";
  FheType2[FheType2["Int248"] = 83] = "Int248";
})(FheType || (FheType = {}));
var ALL_FHE_TYPES = [
  {
    type: "Bool",
    value: 0,
    supportedOperators: ["and", "or", "xor", "eq", "ne", "not", "select", "rand"],
    bitLength: 2,
    clearMatchingType: "bool"
  },
  {
    type: "Uint4",
    value: 1,
    supportedOperators: [],
    bitLength: 4,
    clearMatchingType: "uint8"
  },
  {
    type: "Uint8",
    value: 2,
    supportedOperators: [
      "add",
      "sub",
      "mul",
      "div",
      "rem",
      "and",
      "or",
      "xor",
      "shl",
      "shr",
      "rotl",
      "rotr",
      "eq",
      "ne",
      "ge",
      "gt",
      "le",
      "lt",
      "min",
      "max",
      "neg",
      "not",
      "select",
      "rand",
      "randBounded"
    ],
    bitLength: 8,
    clearMatchingType: "uint8",
    aliases: [
      {
        type: "Bytes1",
        supportedOperators: [],
        clearMatchingType: "bytes1"
      }
    ]
  },
  {
    type: "Uint16",
    value: 3,
    supportedOperators: [
      "add",
      "sub",
      "mul",
      "div",
      "rem",
      "and",
      "or",
      "xor",
      "shl",
      "shr",
      "rotl",
      "rotr",
      "eq",
      "ne",
      "ge",
      "gt",
      "le",
      "lt",
      "min",
      "max",
      "neg",
      "not",
      "select",
      "rand",
      "randBounded"
    ],
    bitLength: 16,
    clearMatchingType: "uint16",
    aliases: [
      {
        type: "Bytes2",
        supportedOperators: [],
        clearMatchingType: "bytes2"
      }
    ]
  },
  {
    type: "Uint32",
    value: 4,
    supportedOperators: [
      "add",
      "sub",
      "mul",
      "div",
      "rem",
      "and",
      "or",
      "xor",
      "shl",
      "shr",
      "rotl",
      "rotr",
      "eq",
      "ne",
      "ge",
      "gt",
      "le",
      "lt",
      "min",
      "max",
      "neg",
      "not",
      "select",
      "rand",
      "randBounded"
    ],
    bitLength: 32,
    clearMatchingType: "uint32",
    aliases: [
      {
        type: "Bytes4",
        supportedOperators: [],
        clearMatchingType: ""
      }
    ]
  },
  {
    type: "Uint64",
    value: 5,
    supportedOperators: [
      "add",
      "sub",
      "mul",
      "div",
      "rem",
      "and",
      "or",
      "xor",
      "shl",
      "shr",
      "rotl",
      "rotr",
      "eq",
      "ne",
      "ge",
      "gt",
      "le",
      "lt",
      "min",
      "max",
      "neg",
      "not",
      "select",
      "rand",
      "randBounded"
    ],
    bitLength: 64,
    clearMatchingType: "uint64",
    aliases: [
      {
        type: "Bytes8",
        supportedOperators: [],
        clearMatchingType: "bytes8"
      }
    ]
  },
  {
    type: "Uint128",
    value: 6,
    supportedOperators: [
      "add",
      "sub",
      "mul",
      "div",
      "rem",
      "and",
      "or",
      "xor",
      "shl",
      "shr",
      "rotl",
      "rotr",
      "eq",
      "ne",
      "ge",
      "gt",
      "le",
      "lt",
      "min",
      "max",
      "neg",
      "not",
      "select",
      "rand",
      "randBounded"
    ],
    bitLength: 128,
    clearMatchingType: "uint128",
    aliases: [
      {
        type: "Bytes16",
        supportedOperators: [],
        clearMatchingType: "bytes16"
      }
    ]
  },
  {
    type: "Uint160",
    value: 7,
    supportedOperators: [],
    bitLength: 160,
    clearMatchingType: "uint160",
    aliases: [
      {
        type: "Address",
        supportedOperators: ["eq", "ne", "select"],
        clearMatchingType: "address"
      },
      {
        type: "Bytes20",
        supportedOperators: [],
        clearMatchingType: "bytes20"
      }
    ]
  },
  {
    type: "Uint256",
    value: 8,
    supportedOperators: [
      "and",
      "or",
      "xor",
      "shl",
      "shr",
      "rotl",
      "rotr",
      "eq",
      "ne",
      "neg",
      "not",
      "select",
      "rand",
      "randBounded"
    ],
    bitLength: 256,
    clearMatchingType: "uint256",
    aliases: [
      {
        type: "Bytes32",
        supportedOperators: [],
        clearMatchingType: "bytes32"
      }
    ]
  },
  {
    type: "Uint512",
    value: 9,
    supportedOperators: [],
    bitLength: 512,
    clearMatchingType: "bytes memory",
    aliases: [
      {
        type: "Bytes64",
        supportedOperators: ["eq", "ne", "select", "rand"],
        clearMatchingType: ""
      }
    ]
  },
  {
    type: "Uint1024",
    value: 10,
    supportedOperators: [],
    bitLength: 1024,
    clearMatchingType: "bytes memory",
    aliases: [
      {
        type: "Bytes128",
        supportedOperators: ["eq", "ne", "select", "rand"],
        clearMatchingType: ""
      }
    ]
  },
  {
    type: "Uint2048",
    value: 11,
    supportedOperators: [],
    bitLength: 2048,
    clearMatchingType: "bytes memory",
    aliases: [
      {
        type: "Bytes256",
        supportedOperators: ["eq", "ne", "select", "rand"],
        clearMatchingType: ""
      }
    ]
  },
  {
    type: "Uint2",
    value: 12,
    supportedOperators: [],
    bitLength: 2,
    clearMatchingType: "uint8"
  },
  {
    type: "Uint6",
    value: 13,
    supportedOperators: [],
    bitLength: 6,
    clearMatchingType: "uint8"
  },
  {
    type: "Uint10",
    value: 14,
    supportedOperators: [],
    bitLength: 10,
    clearMatchingType: "uint16"
  },
  {
    type: "Uint12",
    value: 15,
    supportedOperators: [],
    bitLength: 12,
    clearMatchingType: "uint16"
  },
  {
    type: "Uint14",
    value: 16,
    supportedOperators: [],
    bitLength: 14,
    clearMatchingType: "uint16"
  },
  {
    type: "Int2",
    value: 17,
    supportedOperators: [],
    bitLength: 2,
    clearMatchingType: "int8"
  },
  {
    type: "Int4",
    value: 18,
    supportedOperators: [],
    bitLength: 4,
    clearMatchingType: "int8"
  },
  {
    type: "Int6",
    value: 19,
    supportedOperators: [],
    bitLength: 6,
    clearMatchingType: "int8"
  },
  {
    type: "Int8",
    value: 20,
    supportedOperators: [],
    bitLength: 8,
    clearMatchingType: "int8"
  },
  {
    type: "Int10",
    value: 21,
    supportedOperators: [],
    bitLength: 10,
    clearMatchingType: "int16"
  },
  {
    type: "Int12",
    value: 22,
    supportedOperators: [],
    bitLength: 12,
    clearMatchingType: "int16"
  },
  {
    type: "Int14",
    value: 23,
    supportedOperators: [],
    bitLength: 14,
    clearMatchingType: "int16"
  },
  {
    type: "Int16",
    value: 24,
    supportedOperators: [],
    bitLength: 16,
    clearMatchingType: "int16"
  },
  {
    type: "Int32",
    value: 25,
    supportedOperators: [],
    bitLength: 32,
    clearMatchingType: "int32"
  },
  {
    type: "Int64",
    value: 26,
    supportedOperators: [],
    bitLength: 64,
    clearMatchingType: "int64"
  },
  {
    type: "Int128",
    value: 27,
    supportedOperators: [],
    bitLength: 128,
    clearMatchingType: "int128"
  },
  {
    type: "Int160",
    value: 28,
    supportedOperators: [],
    bitLength: 160,
    clearMatchingType: "int160"
  },
  {
    type: "Int256",
    value: 29,
    supportedOperators: [],
    bitLength: 256,
    clearMatchingType: "int256"
  },
  {
    type: "AsciiString",
    value: 30,
    supportedOperators: [],
    bitLength: 0,
    clearMatchingType: "string memory"
  },
  {
    type: "Int512",
    value: 31,
    supportedOperators: [],
    bitLength: 512,
    clearMatchingType: "bytes memory"
  },
  {
    type: "Int1024",
    value: 32,
    supportedOperators: [],
    bitLength: 1024,
    clearMatchingType: "bytes memory"
  },
  {
    type: "Int2048",
    value: 33,
    supportedOperators: [],
    bitLength: 2048,
    clearMatchingType: "bytes memory"
  },
  {
    type: "Uint24",
    value: 34,
    supportedOperators: [],
    bitLength: 24,
    clearMatchingType: "uint24",
    aliases: [
      {
        type: "Bytes3",
        supportedOperators: [],
        clearMatchingType: "bytes3"
      }
    ]
  },
  {
    type: "Uint40",
    value: 35,
    supportedOperators: [],
    bitLength: 40,
    clearMatchingType: "uint40",
    aliases: [
      {
        type: "Bytes5",
        supportedOperators: [],
        clearMatchingType: "bytes5"
      }
    ]
  },
  {
    type: "Uint48",
    value: 36,
    supportedOperators: [],
    bitLength: 48,
    clearMatchingType: "uint48",
    aliases: [
      {
        type: "Bytes6",
        supportedOperators: [],
        clearMatchingType: "bytes6"
      }
    ]
  },
  {
    type: "Uint56",
    value: 37,
    supportedOperators: [],
    bitLength: 56,
    clearMatchingType: "uint56",
    aliases: [
      {
        type: "Bytes7",
        supportedOperators: [],
        clearMatchingType: ""
      }
    ]
  },
  {
    type: "Uint72",
    value: 38,
    supportedOperators: [],
    bitLength: 72,
    clearMatchingType: "uint72",
    aliases: [
      {
        type: "Bytes9",
        supportedOperators: [],
        clearMatchingType: "bytes9"
      }
    ]
  },
  {
    type: "Uint80",
    value: 39,
    supportedOperators: [],
    bitLength: 80,
    clearMatchingType: "uint80",
    aliases: [
      {
        type: "Bytes10",
        supportedOperators: [],
        clearMatchingType: "bytes10"
      }
    ]
  },
  {
    type: "Uint88",
    value: 40,
    supportedOperators: [],
    bitLength: 88,
    clearMatchingType: "uint88",
    aliases: [
      {
        type: "Bytes11",
        supportedOperators: [],
        clearMatchingType: "bytes11"
      }
    ]
  },
  {
    type: "Uint96",
    value: 41,
    supportedOperators: [],
    bitLength: 96,
    clearMatchingType: "uint96",
    aliases: [
      {
        type: "Bytes12",
        supportedOperators: [],
        clearMatchingType: "bytes12"
      }
    ]
  },
  {
    type: "Uint104",
    value: 42,
    supportedOperators: [],
    bitLength: 104,
    clearMatchingType: "uint104",
    aliases: [
      {
        type: "Bytes13",
        supportedOperators: [],
        clearMatchingType: "bytes13"
      }
    ]
  },
  {
    type: "Uint112",
    value: 43,
    supportedOperators: [],
    bitLength: 112,
    clearMatchingType: "uint112",
    aliases: [
      {
        type: "Bytes14",
        supportedOperators: [],
        clearMatchingType: "bytes14"
      }
    ]
  },
  {
    type: "Uint120",
    value: 44,
    supportedOperators: [],
    bitLength: 120,
    clearMatchingType: "uint120",
    aliases: [
      {
        type: "Bytes15",
        supportedOperators: [],
        clearMatchingType: "bytes15"
      }
    ]
  },
  {
    type: "Uint136",
    value: 45,
    supportedOperators: [],
    bitLength: 136,
    clearMatchingType: "uint136",
    aliases: [
      {
        type: "Bytes17",
        supportedOperators: [],
        clearMatchingType: "bytes17"
      }
    ]
  },
  {
    type: "Uint144",
    value: 46,
    supportedOperators: [],
    bitLength: 144,
    clearMatchingType: "uint144",
    aliases: [
      {
        type: "Bytes18",
        supportedOperators: [],
        clearMatchingType: "bytes18"
      }
    ]
  },
  {
    type: "Uint152",
    value: 47,
    supportedOperators: [],
    bitLength: 152,
    clearMatchingType: "uint152",
    aliases: [
      {
        type: "Bytes19",
        supportedOperators: [],
        clearMatchingType: "bytes19"
      }
    ]
  },
  {
    type: "Uint168",
    value: 48,
    supportedOperators: [],
    bitLength: 168,
    clearMatchingType: "uint168",
    aliases: [
      {
        type: "Bytes21",
        supportedOperators: [],
        clearMatchingType: "bytes21"
      }
    ]
  },
  {
    type: "Uint176",
    value: 49,
    supportedOperators: [],
    bitLength: 176,
    clearMatchingType: "uint176",
    aliases: [
      {
        type: "Bytes22",
        supportedOperators: [],
        clearMatchingType: "bytes22"
      }
    ]
  },
  {
    type: "Uint184",
    value: 50,
    supportedOperators: [],
    bitLength: 184,
    clearMatchingType: "uint184",
    aliases: [
      {
        type: "Bytes23",
        supportedOperators: [],
        clearMatchingType: "bytes23"
      }
    ]
  },
  {
    type: "Uint192",
    value: 51,
    supportedOperators: [],
    bitLength: 192,
    clearMatchingType: "uint192",
    aliases: [
      {
        type: "Bytes24",
        supportedOperators: [],
        clearMatchingType: "24"
      }
    ]
  },
  {
    type: "Uint200",
    value: 52,
    supportedOperators: [],
    bitLength: 200,
    clearMatchingType: "uint200",
    aliases: [
      {
        type: "Bytes25",
        supportedOperators: [],
        clearMatchingType: "25"
      }
    ]
  },
  {
    type: "Uint208",
    value: 53,
    supportedOperators: [],
    bitLength: 208,
    clearMatchingType: "uint208",
    aliases: [
      {
        type: "Bytes26",
        supportedOperators: [],
        clearMatchingType: "26"
      }
    ]
  },
  {
    type: "Uint216",
    value: 54,
    supportedOperators: [],
    bitLength: 216,
    clearMatchingType: "uint216",
    aliases: [
      {
        type: "Bytes27",
        supportedOperators: [],
        clearMatchingType: "27"
      }
    ]
  },
  {
    type: "Uint224",
    value: 55,
    supportedOperators: [],
    bitLength: 224,
    clearMatchingType: "uint224",
    aliases: [
      {
        type: "Bytes28",
        supportedOperators: [],
        clearMatchingType: "28"
      }
    ]
  },
  {
    type: "Uint232",
    value: 56,
    supportedOperators: [],
    bitLength: 232,
    clearMatchingType: "uint232",
    aliases: [
      {
        type: "Bytes29",
        supportedOperators: [],
        clearMatchingType: "bytes29"
      }
    ]
  },
  {
    type: "Uint240",
    value: 57,
    supportedOperators: [],
    bitLength: 240,
    clearMatchingType: "uint240",
    aliases: [
      {
        type: "Bytes30",
        supportedOperators: [],
        clearMatchingType: "bytes30"
      }
    ]
  },
  {
    type: "Uint248",
    value: 58,
    supportedOperators: [],
    bitLength: 248,
    clearMatchingType: "uint248",
    aliases: [
      {
        type: "Bytes31",
        supportedOperators: [],
        clearMatchingType: "bytes31"
      }
    ]
  },
  {
    type: "Int24",
    value: 59,
    supportedOperators: [],
    bitLength: 24,
    clearMatchingType: "int24"
  },
  {
    type: "Int40",
    value: 60,
    supportedOperators: [],
    bitLength: 40,
    clearMatchingType: "int40"
  },
  {
    type: "Int48",
    value: 61,
    supportedOperators: [],
    bitLength: 48,
    clearMatchingType: "int48"
  },
  {
    type: "Int56",
    value: 62,
    supportedOperators: [],
    bitLength: 56,
    clearMatchingType: "int56"
  },
  {
    type: "Int72",
    value: 63,
    supportedOperators: [],
    bitLength: 72,
    clearMatchingType: "int72"
  },
  {
    type: "Int80",
    value: 64,
    supportedOperators: [],
    bitLength: 80,
    clearMatchingType: "int80"
  },
  {
    type: "Int88",
    value: 65,
    supportedOperators: [],
    bitLength: 88,
    clearMatchingType: "int88"
  },
  {
    type: "Int96",
    value: 66,
    supportedOperators: [],
    bitLength: 96,
    clearMatchingType: "int96"
  },
  {
    type: "Int104",
    value: 67,
    supportedOperators: [],
    bitLength: 104,
    clearMatchingType: "int104"
  },
  {
    type: "Int112",
    value: 68,
    supportedOperators: [],
    bitLength: 112,
    clearMatchingType: "int112"
  },
  {
    type: "Int120",
    value: 69,
    supportedOperators: [],
    bitLength: 120,
    clearMatchingType: "int120"
  },
  {
    type: "Int136",
    value: 70,
    supportedOperators: [],
    bitLength: 136,
    clearMatchingType: "int136"
  },
  {
    type: "Int144",
    value: 71,
    supportedOperators: [],
    bitLength: 144,
    clearMatchingType: "int144"
  },
  {
    type: "Int152",
    value: 72,
    supportedOperators: [],
    bitLength: 152,
    clearMatchingType: "int152"
  },
  {
    type: "Int168",
    value: 73,
    supportedOperators: [],
    bitLength: 168,
    clearMatchingType: "int168"
  },
  {
    type: "Int176",
    value: 74,
    supportedOperators: [],
    bitLength: 176,
    clearMatchingType: "int176"
  },
  {
    type: "Int184",
    value: 75,
    supportedOperators: [],
    bitLength: 184,
    clearMatchingType: "int184"
  },
  {
    type: "Int192",
    value: 76,
    supportedOperators: [],
    bitLength: 192,
    clearMatchingType: "int192"
  },
  {
    type: "Int200",
    value: 77,
    supportedOperators: [],
    bitLength: 200,
    clearMatchingType: "int200"
  },
  {
    type: "Int208",
    value: 78,
    supportedOperators: [],
    bitLength: 208,
    clearMatchingType: "int208"
  },
  {
    type: "Int216",
    value: 79,
    supportedOperators: [],
    bitLength: 216,
    clearMatchingType: "int216"
  },
  {
    type: "Int224",
    value: 80,
    supportedOperators: [],
    bitLength: 224,
    clearMatchingType: "int224"
  },
  {
    type: "Int232",
    value: 81,
    supportedOperators: [],
    bitLength: 232,
    clearMatchingType: "int232"
  },
  {
    type: "Int240",
    value: 82,
    supportedOperators: [],
    bitLength: 240,
    clearMatchingType: "int240"
  },
  {
    type: "Int248",
    value: 83,
    supportedOperators: [],
    bitLength: 248,
    clearMatchingType: "int248"
  }
];
function checkFheType(fheType) {
  if (!isUInt(fheType)) {
    throw new FhevmError(`Invalid FheType ${fheType}`);
  }
  const theFheType = fheType;
  if (theFheType >= ALL_FHE_TYPES.length) {
    throw new FhevmError(`Invalid FheType ${fheType}`);
  }
}
function getFheTypeByteLength(fheType) {
  const fheBitLen = getFheTypeBitLength(fheType);
  return Math.ceil(fheBitLen / 8);
}
function getFheTypeBitLength(fheType) {
  return getFheTypeInfo(fheType).bitLength;
}
function getFheTypeInfo(type) {
  return ALL_FHE_TYPES[type];
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/FhevmType.js
var FhevmType;
(function(FhevmType2) {
  FhevmType2[FhevmType2["ebool"] = 0] = "ebool";
  FhevmType2[FhevmType2["euint4"] = 1] = "euint4";
  FhevmType2[FhevmType2["euint8"] = 2] = "euint8";
  FhevmType2[FhevmType2["euint16"] = 3] = "euint16";
  FhevmType2[FhevmType2["euint32"] = 4] = "euint32";
  FhevmType2[FhevmType2["euint64"] = 5] = "euint64";
  FhevmType2[FhevmType2["euint128"] = 6] = "euint128";
  FhevmType2[FhevmType2["eaddress"] = 7] = "eaddress";
  FhevmType2[FhevmType2["euint256"] = 8] = "euint256";
  FhevmType2[FhevmType2["ebytes64"] = 9] = "ebytes64";
  FhevmType2[FhevmType2["ebytes128"] = 10] = "ebytes128";
  FhevmType2[FhevmType2["ebytes256"] = 11] = "ebytes256";
})(FhevmType || (FhevmType = {}));
var FhevmTypeMap = {
  ebool: FhevmType.ebool,
  euint4: FhevmType.euint4,
  euint8: FhevmType.euint8,
  euint16: FhevmType.euint16,
  euint32: FhevmType.euint32,
  euint64: FhevmType.euint64,
  euint128: FhevmType.euint128,
  eaddress: FhevmType.eaddress,
  euint256: FhevmType.euint256,
  ebytes64: FhevmType.ebytes64,
  ebytes128: FhevmType.ebytes128,
  ebytes256: FhevmType.ebytes256
};
Object.freeze(FhevmTypeMap);
var FhevmTypeNameMap = {
  [FhevmType.ebool]: "ebool",
  [FhevmType.euint4]: "euint4",
  [FhevmType.euint8]: "euint8",
  [FhevmType.euint16]: "euint16",
  [FhevmType.euint32]: "euint32",
  [FhevmType.euint64]: "euint64",
  [FhevmType.euint128]: "euint128",
  [FhevmType.euint256]: "euint256",
  [FhevmType.eaddress]: "eaddress",
  [FhevmType.ebytes64]: "ebytes64",
  [FhevmType.ebytes128]: "ebytes128",
  [FhevmType.ebytes256]: "ebytes256"
};
Object.freeze(FhevmTypeNameMap);
var allFhevmTypes = [
  FhevmType.ebool,
  FhevmType.euint4,
  FhevmType.euint8,
  FhevmType.euint16,
  FhevmType.euint32,
  FhevmType.euint64,
  FhevmType.euint128,
  FhevmType.eaddress,
  FhevmType.euint256,
  FhevmType.ebytes64,
  FhevmType.ebytes128,
  FhevmType.ebytes256
];
Object.freeze(allFhevmTypes);
var allFhevmTypeNames = [
  "ebool",
  "euint4",
  "euint8",
  "euint16",
  "euint32",
  "euint64",
  "euint128",
  "eaddress",
  "euint256",
  "ebytes64",
  "ebytes128",
  "ebytes256"
];
Object.freeze(allFhevmTypeNames);
var allFhevmTypeInfos = Object.freeze([
  Object.freeze({
    type: FhevmType.ebool,
    fheType: FheType.Bool,
    // 0
    name: "ebool",
    solidityTypeName: "bool",
    clearTextBitLength: 1
  }),
  Object.freeze({
    type: FhevmType.euint4,
    fheType: FheType.Uint4,
    // 1 (Deprecated ?)
    name: "euint4",
    solidityTypeName: "uint4",
    clearTextBitLength: 4
  }),
  Object.freeze({
    type: FhevmType.euint8,
    fheType: FheType.Uint8,
    // 2
    name: "euint8",
    solidityTypeName: "uint8",
    clearTextBitLength: 8
  }),
  Object.freeze({
    type: FhevmType.euint16,
    fheType: FheType.Uint16,
    // 3
    name: "euint16",
    solidityTypeName: "uint16",
    clearTextBitLength: 16
  }),
  Object.freeze({
    type: FhevmType.euint32,
    fheType: FheType.Uint32,
    // 4
    name: "euint32",
    solidityTypeName: "uint32",
    clearTextBitLength: 32
  }),
  Object.freeze({
    type: FhevmType.euint64,
    fheType: FheType.Uint64,
    // 5
    name: "euint64",
    solidityTypeName: "uint64",
    clearTextBitLength: 64
  }),
  Object.freeze({
    name: "euint128",
    type: FhevmType.euint128,
    fheType: FheType.Uint128,
    // 6
    solidityTypeName: "uint128",
    clearTextBitLength: 128
  }),
  Object.freeze({
    name: "eaddress",
    type: FhevmType.eaddress,
    fheType: FheType.Uint160,
    // 7
    solidityTypeName: "address",
    clearTextBitLength: 160
  }),
  Object.freeze({
    name: "euint256",
    type: FhevmType.euint256,
    fheType: FheType.Uint256,
    // 8
    solidityTypeName: "uint256",
    clearTextBitLength: 256
  }),
  Object.freeze({
    name: "ebytes64",
    type: FhevmType.ebytes64,
    fheType: FheType.Uint512,
    // 9
    solidityTypeName: "bytes",
    clearTextBitLength: 512
  }),
  Object.freeze({
    name: "ebytes128",
    type: FhevmType.ebytes128,
    fheType: FheType.Uint1024,
    // 10
    solidityTypeName: "bytes",
    clearTextBitLength: 1024
  }),
  Object.freeze({
    name: "ebytes256",
    type: FhevmType.ebytes256,
    fheType: FheType.Uint2048,
    // 11
    solidityTypeName: "bytes",
    clearTextBitLength: 2048
  })
]);
function isFhevmType(fhevmType) {
  if (!isUInt(fhevmType)) {
    return false;
  }
  const theFhevmType = fhevmType;
  if (theFhevmType >= allFhevmTypeInfos.length) {
    return false;
  }
  return true;
}
function isFhevmEbytes(fhevmType) {
  return fhevmType === FhevmType.ebytes64 || fhevmType === FhevmType.ebytes128 || fhevmType === FhevmType.ebytes256;
}
function isFhevmEuint(fhevmType) {
  return fhevmType === FhevmType.euint4 || fhevmType === FhevmType.euint8 || fhevmType === FhevmType.euint16 || fhevmType === FhevmType.euint32 || fhevmType === FhevmType.euint64 || fhevmType === FhevmType.euint128 || fhevmType === FhevmType.euint256;
}
function isFhevmEbool(fhevmType) {
  return fhevmType === FhevmType.ebool;
}
function isFhevmEaddress(fhevmType) {
  return fhevmType === FhevmType.eaddress;
}
function checkFhevmType(fhevmType) {
  if (!isFhevmType(fhevmType)) {
    throw new FhevmError(`Invalid FhevmType ${fhevmType}`);
  }
}
function FhevmTypeToFheType(fhevmType) {
  checkFhevmType(fhevmType);
  if (fhevmType >= ALL_FHE_TYPES.length) {
    throw new FhevmError(`Cannot convert FhevmType: ${fhevmType} to FheType`);
  }
  return fhevmType;
}
function getFhevmTypeInfo(type) {
  if (typeof type === "string") {
    return allFhevmTypeInfos[FhevmTypeMap[type]];
  }
  return allFhevmTypeInfos[type];
}
function tryParseFhevmType(name) {
  if (typeof name !== "string") {
    return void 0;
  }
  if (!(name in FhevmTypeMap)) {
    return void 0;
  }
  try {
    return FhevmTypeMap[name];
  } catch {
    return void 0;
  }
}

// node_modules/@fhevm/mock-utils/_esm/utils/address.js
function assertIsAddress(value, valueName) {
  assertIsString(value, valueName);
  assertFhevm(ethers_exports.isAddress(value), `${valueName ?? "value"}: '${value}' is not a valid address`);
}
function assertIsAddressArray(value, valueName) {
  assertIsArray(value, valueName);
  for (let i = 0; i < value.length; ++i) {
    assertIsAddress(value[i], valueName ? `${valueName}[${i}]` : void 0);
  }
}
function assertIsAddressProperty(value, propertyNames, typeName) {
  if (typeof value !== "object" || value === null) {
    throw new FhevmError(`${typeName} must be a non-null object.`);
  }
  for (const key of propertyNames) {
    const prop = value[key];
    if (typeof prop !== "string") {
      throw new FhevmError(`Expected '${key}' in ${typeName} to be a valid address, but got ${typeof prop} instead.`);
    }
    if (!ethers_exports.isAddress(prop)) {
      throw new FhevmError(`Expected '${key}' in ${typeName} to be a valid address, but got ${typeof prop} instead.`);
    }
  }
}
function addressToBytes(value, valueName) {
  assertIsAddress(value, valueName);
  assertFhevm(ethers_exports.zeroPadValue(value, 20).toLocaleLowerCase() === ethers_exports.toBeHex(value, 20));
  return ethers_exports.getBytes(ethers_exports.toBeHex(value, 20));
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/relayer/payloads.js
function _assertIsRelayerV1UserDecryptValidity(value) {
  const stringFields = ["durationDays", "startTimestamp"];
  assertIsStringProperty(value, stringFields, "RelayerV1UserDecryptValidity");
}
function assertIsRelayerV1InputProofPayload(value) {
  const stringFields = [
    "contractAddress",
    "userAddress",
    "ciphertextWithInputVerification",
    "contractChainId",
    "extraData"
  ];
  assertIsStringProperty(value, stringFields, "RelayerV1InputProofPayload");
}
function assertIsRelayerV1InputProofResponse(value) {
  const keys = ["handles", "signatures"];
  assertIsStringArrayProperty(value, keys, "RelayerV1InputProofResponse");
}
function assertIsRelayerV1PublicDecryptPayload(value) {
  const arrayKeys = ["ciphertextHandles"];
  const stringKeys = ["extraData"];
  assertIsStringArrayProperty(value, arrayKeys, "RelayerV1PublicDecryptPayload");
  assertIsStringProperty(value, stringKeys, "RelayerV1PublicDecryptResponse");
}
function assertIsRelayerV1PublicDecryptResponse(value) {
  const arrayKeys = ["signatures"];
  const stringKeys = ["decrypted_value"];
  assertIsStringArrayProperty(value, arrayKeys, "RelayerV1PublicDecryptResponse");
  assertIsStringProperty(value, stringKeys, "RelayerV1PublicDecryptResponse");
}
function assertIsRelayerV1UserDecryptResponse(value) {
  const stringKeys = ["signature"];
  const objectKeys = ["payload"];
  assertIsStringProperty(value, stringKeys, "RelayerV1UserDecryptResponse");
  assertIsObjectProperty(value, objectKeys, "RelayerV1UserDecryptResponse");
  assertIsStringArrayProperty(value.payload, ["decrypted_values"], "RelayerV1UserDecryptResponse");
}
function assertIsRelayerV1UserDecryptPayload(value) {
  const arrayKeys = ["handleContractPairs", "contractAddresses"];
  const stringKeys = [
    "contractsChainId",
    "publicKey",
    "signature",
    "userAddress",
    "extraData"
  ];
  const objectKeys = ["requestValidity"];
  assertIsStringProperty(value, stringKeys, "RelayerV1UserDecryptPayload");
  assertIsArrayProperty(value, arrayKeys, "RelayerV1UserDecryptPayload");
  assertIsObjectProperty(value, objectKeys, "RelayerV1UserDecryptPayload");
  _assertIsRelayerV1UserDecryptValidity(value.requestValidity);
}
function assertIsRelayerMetadata(value) {
  const stringKeys = ["version"];
  assertIsStringProperty(value, stringKeys, "RelayerMetadata");
  const keys = [
    "ACLAddress",
    "CoprocessorAddress",
    "InputVerifierAddress",
    "KMSVerifierAddress",
    "relayerSignerAddress"
  ];
  assertIsAddressProperty(value, keys, "RelayerMetadata");
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/relayer/mock_payloads.js
function assertIsMockRelayerV1InputProofPayload(value) {
  const objectKeys = ["mockData"];
  assertIsRelayerV1InputProofPayload(value);
  assertIsObjectProperty(value, objectKeys, "MockRelayerV1InputProofPayload");
  _assertIsMockRelayerData(value.mockData);
}
function _assertIsMockRelayerData(value) {
  const arrayKeys = [
    "clearTextValuesBigIntHex",
    "metadatas",
    "fheTypes",
    "fhevmTypes",
    "random32List"
  ];
  const stringKeys = ["aclContractAddress"];
  assertIsStringProperty(value, stringKeys, "MockRelayerData");
  assertIsArrayProperty(value, arrayKeys, "MockRelayerData");
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/relayer/MockRelayer.js
async function requestRelayerV1InputProof(relayerProvider, payload) {
  assertIsMockRelayerV1InputProofPayload(payload);
  const response = await minimalProviderSend(relayerProvider, RELAYER_V1_INPUT_PROOF, [payload]);
  assertIsRelayerV1InputProofResponse(response);
  return response;
}
async function requestRelayerV1UserDecrypt(relayerProvider, payload) {
  assertIsRelayerV1UserDecryptPayload(payload);
  const response = await minimalProviderSend(relayerProvider, RELAYER_V1_USER_DECRYPT, [payload]);
  assertIsRelayerV1UserDecryptResponse(response);
  return { response: [response] };
}
async function requestRelayerV1PublicDecrypt(relayerProvider, payload) {
  assertIsRelayerV1PublicDecryptPayload(payload);
  const response = await minimalProviderSend(relayerProvider, RELAYER_V1_PUBLIC_DECRYPT, [payload]);
  assertIsRelayerV1PublicDecryptResponse(response);
  return { response: [response] };
}
async function requestRelayerMetadata(relayerProvider) {
  const response = await minimalProviderSend(relayerProvider, RELAYER_METADATA, []);
  assertIsRelayerMetadata(response);
  return response;
}
async function requestFhevmAwaitDecryptionOracle(relayerProvider) {
  return await minimalProviderSend(relayerProvider, FHEVM_AWAIT_DECRYPTION_ORACLE, []);
}
async function requestFhevmGetClearText(relayerProvider, payload) {
  return await minimalProviderSend(relayerProvider, FHEVM_GET_CLEAR_TEXT, [payload]);
}
async function requestFhevmCreateDecryptionSignatures(relayerProvider, payload) {
  return await minimalProviderSend(relayerProvider, FHEVM_CREATE_DECRYPTION_SIGNATURES, [payload]);
}

// node_modules/@fhevm/mock-utils/_esm/utils/index.js
var utils_exports = {};
__export(utils_exports, {
  FhevmError: () => FhevmError,
  assertIsAddress: () => assertIsAddress,
  ensurePrefix: () => ensurePrefix,
  ensureSuffix: () => ensureSuffix,
  removePrefix: () => removePrefix,
  timestampNow: () => timestampNow,
  toUIntNumber: () => toUIntNumber,
  verifyKeypair: () => verifyKeypair
});

// node_modules/@fhevm/mock-utils/_esm/utils/time.js
function timestampNow() {
  return Math.floor(Date.now() / 1e3);
}

// node_modules/@fhevm/mock-utils/_esm/utils/keypair.js
function verifyKeypair(keyPair) {
  keyPair.publicKey = removePrefix(keyPair.publicKey, "0x");
  keyPair.privateKey = removePrefix(keyPair.privateKey, "0x");
  if (!ethers_exports.isHexString("0x" + keyPair.publicKey, 80)) {
    throw new FhevmError(`Invalid key pair's publicKey. Call FhevmInstance.generateKeyPair() to generate a valid FHEVM key pair.`);
  }
  if (!ethers_exports.isHexString("0x" + keyPair.privateKey, 80)) {
    throw new FhevmError(`Invalid key pair's publicKey. Call FhevmInstance.generateKeyPair() to generate a valid FHEVM key pair.`);
  }
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/index.js
var contracts_exports = {};
__export(contracts_exports, {
  ACL: () => ACL,
  FHEVMExecutor: () => FHEVMExecutor,
  FhevmContractWrapper: () => FhevmContractWrapper,
  FhevmContractsRepository: () => FhevmContractsRepository,
  FhevmCoprocessorContractWrapper: () => FhevmCoprocessorContractWrapper,
  FhevmDecryptionOracleContractWrapper: () => FhevmDecryptionOracleContractWrapper,
  HCULimit: () => HCULimit,
  InputVerifier: () => InputVerifier,
  KMSVerifier: () => KMSVerifier
});

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/FhevmContractWrapper.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FhevmContractWrapper_name;
var FhevmContractWrapper = class {
  constructor(name) {
    _FhevmContractWrapper_name.set(this, void 0);
    __classPrivateFieldSet(this, _FhevmContractWrapper_name, name, "f");
  }
  get name() {
    return __classPrivateFieldGet(this, _FhevmContractWrapper_name, "f");
  }
  get properties() {
    return {
      address: this.address,
      contract: this.readonlyContract,
      package: this.package,
      contractName: this.name
    };
  }
  async _callOrThrow(p, funcName) {
    try {
      return await p;
    } catch (e) {
      console.error(`invalid deployed ${this.name} contact at ${this.address}. Function ${funcName} does not exist.`);
      throw e;
    }
  }
};
_FhevmContractWrapper_name = /* @__PURE__ */ new WeakMap();
var FhevmCoprocessorContractWrapper = class extends FhevmContractWrapper {
  constructor(name) {
    super(name);
  }
  get package() {
    return constants_default.FHEVM_CORE_CONTRACTS_PACKAGE_NAME;
  }
};
var FhevmDecryptionOracleContractWrapper = class extends FhevmContractWrapper {
  constructor(name) {
    super(name);
  }
  get package() {
    return constants_default.ZAMA_FHE_ORACLE_SOLIDITY_PACKAGE_NAME;
  }
};

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/interfaces/ACL.itf.js
var ACLPartialInterface = new ethers_exports.Interface([
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "delegatee",
        type: "address"
      },
      {
        internalType: "address",
        name: "contractAddress",
        type: "address"
      }
    ],
    name: "AlreadyDelegated",
    type: "error"
  },
  {
    inputs: [],
    name: "ContractAddressesIsEmpty",
    type: "error"
  },
  {
    inputs: [],
    name: "ContractAddressesMaxLengthExceeded",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  {
    inputs: [],
    name: "ERC1967NonPayable",
    type: "error"
  },
  {
    inputs: [],
    name: "EnforcedPause",
    type: "error"
  },
  {
    inputs: [],
    name: "ExpectedPause",
    type: "error"
  },
  {
    inputs: [],
    name: "FailedCall",
    type: "error"
  },
  {
    inputs: [],
    name: "HandlesListIsEmpty",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidInitialization",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidNullPauser",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "delegatee",
        type: "address"
      },
      {
        internalType: "address",
        name: "contractAddress",
        type: "address"
      }
    ],
    name: "NotDelegatedYet",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializing",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializingFromEmptyProxy",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "NotPauser",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "contractAddress",
        type: "address"
      }
    ],
    name: "SenderCannotBeContractAddress",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "SenderNotAllowed",
    type: "error"
  },
  {
    inputs: [],
    name: "UUPSUnauthorizedCallContext",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "slot",
        type: "bytes32"
      }
    ],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "handle",
        type: "bytes32"
      }
    ],
    name: "Allowed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32[]",
        name: "handlesList",
        type: "bytes32[]"
      }
    ],
    name: "AllowedForDecryption",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "delegatee",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address[]",
        name: "contractAddresses",
        type: "address[]"
      }
    ],
    name: "NewDelegation",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "delegatee",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address[]",
        name: "contractAddresses",
        type: "address[]"
      }
    ],
    name: "RevokedDelegation",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newPauser",
        type: "address"
      }
    ],
    name: "UpdatePauser",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "handle",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "allow",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32[]",
        name: "handlesList",
        type: "bytes32[]"
      }
    ],
    name: "allowForDecryption",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "handle",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "allowTransient",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "delegatee",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "handle",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "contractAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "allowedOnBehalf",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "handle",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "allowedTransient",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "cleanTransientStorage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "delegatee",
        type: "address"
      },
      {
        internalType: "address[]",
        name: "contractAddresses",
        type: "address[]"
      }
    ],
    name: "delegateAccount",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getFHEVMExecutorAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPauser",
    outputs: [
      {
        internalType: "address",
        name: "pauser",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVersion",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "initialPauser",
        type: "address"
      }
    ],
    name: "initializeFromEmptyProxy",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "handle",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "isAllowed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "handle",
        type: "bytes32"
      }
    ],
    name: "isAllowedForDecryption",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "handle",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "persistAllowed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "initialPauser",
        type: "address"
      }
    ],
    name: "reinitializeV2",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "delegatee",
        type: "address"
      },
      {
        internalType: "address[]",
        name: "contractAddresses",
        type: "address[]"
      }
    ],
    name: "revokeDelegation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newPauser",
        type: "address"
      }
    ],
    name: "updatePauser",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
]);

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/ACL.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ACL_aclReadOnlyContract;
var _ACL_aclContractAddress;
var _ACL_fhevmExecutorAddress;
var _ACL_version;
var ACL = class _ACL extends FhevmCoprocessorContractWrapper {
  constructor() {
    super("ACL");
    _ACL_aclReadOnlyContract.set(this, void 0);
    _ACL_aclContractAddress.set(this, void 0);
    _ACL_fhevmExecutorAddress.set(this, void 0);
    _ACL_version.set(this, void 0);
  }
  static async create(runner, aclContractAddress, abi, properties) {
    assertIsAddress(aclContractAddress, "aclContractAddress");
    const acl = new _ACL();
    __classPrivateFieldSet2(acl, _ACL_aclContractAddress, aclContractAddress, "f");
    __classPrivateFieldSet2(acl, _ACL_aclReadOnlyContract, new ethers_exports.Contract(aclContractAddress, abi ?? ACLPartialInterface, runner), "f");
    __classPrivateFieldSet2(acl, _ACL_fhevmExecutorAddress, properties == null ? void 0 : properties.fhevmExecutorAddress, "f");
    __classPrivateFieldSet2(acl, _ACL_version, properties == null ? void 0 : properties.version, "f");
    await acl._initialize();
    return acl;
  }
  get readonlyContract() {
    assertFhevm(__classPrivateFieldGet2(this, _ACL_aclReadOnlyContract, "f") !== void 0, `ACL wrapper is not yet initialized`);
    return __classPrivateFieldGet2(this, _ACL_aclReadOnlyContract, "f");
  }
  get interface() {
    assertFhevm(__classPrivateFieldGet2(this, _ACL_aclReadOnlyContract, "f") !== void 0, `ACL wrapper is not yet initialized`);
    return __classPrivateFieldGet2(this, _ACL_aclReadOnlyContract, "f").interface;
  }
  get address() {
    assertFhevm(__classPrivateFieldGet2(this, _ACL_aclContractAddress, "f") !== void 0, `ACL wrapper is not yet initialized`);
    return __classPrivateFieldGet2(this, _ACL_aclContractAddress, "f");
  }
  get version() {
    assertFhevm(__classPrivateFieldGet2(this, _ACL_version, "f") !== void 0, `ACL wrapper is not yet initialized`);
    return __classPrivateFieldGet2(this, _ACL_version, "f");
  }
  get fhevmExecutorAddress() {
    assertFhevm(__classPrivateFieldGet2(this, _ACL_fhevmExecutorAddress, "f") !== void 0, `ACL wrapper is not yet initialized`);
    return __classPrivateFieldGet2(this, _ACL_fhevmExecutorAddress, "f");
  }
  async _initialize() {
    assertFhevm(__classPrivateFieldGet2(this, _ACL_aclReadOnlyContract, "f") !== void 0, `ACL wrapper is not yet initialized`);
    if (!__classPrivateFieldGet2(this, _ACL_fhevmExecutorAddress, "f")) {
      __classPrivateFieldSet2(this, _ACL_fhevmExecutorAddress, await __classPrivateFieldGet2(this, _ACL_aclReadOnlyContract, "f").getFHEVMExecutorAddress(), "f");
    }
    assertIsAddress(__classPrivateFieldGet2(this, _ACL_fhevmExecutorAddress, "f"), "fhemExecutorAddress");
    if (!__classPrivateFieldGet2(this, _ACL_version, "f")) {
      __classPrivateFieldSet2(this, _ACL_version, await __classPrivateFieldGet2(this, _ACL_aclReadOnlyContract, "f").getVersion(), "f");
    }
    assertIsString(__classPrivateFieldGet2(this, _ACL_version, "f"), "version");
  }
  async checkIsAllowedForDecryption(handlesBytes32Hex, readonlyProvider) {
    assertFhevm(__classPrivateFieldGet2(this, _ACL_aclReadOnlyContract, "f") !== void 0, `ACL wrapper is not yet initialized`);
    const c = __classPrivateFieldGet2(this, _ACL_aclReadOnlyContract, "f").connect(readonlyProvider);
    const isAllowedForDec = await Promise.all(handlesBytes32Hex.map(async (handleBytes32Hex) => c.isAllowedForDecryption(handleBytes32Hex)));
    for (let i = 0; i < isAllowedForDec.length; ++i) {
      if (!isAllowedForDec[i]) {
        throw new FhevmError(`Handle ${handlesBytes32Hex[i]} is not authorized for decryption`);
      }
    }
  }
};
_ACL_aclReadOnlyContract = /* @__PURE__ */ new WeakMap(), _ACL_aclContractAddress = /* @__PURE__ */ new WeakMap(), _ACL_fhevmExecutorAddress = /* @__PURE__ */ new WeakMap(), _ACL_version = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/interfaces/FHEVMExecutor.itf.js
var FHEVMExecutorPartialInterface = new ethers_exports.Interface([
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "handle",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "ACLNotAllowed",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [],
    name: "DivisionByZero",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  {
    inputs: [],
    name: "ERC1967NonPayable",
    type: "error"
  },
  {
    inputs: [],
    name: "FailedCall",
    type: "error"
  },
  {
    inputs: [],
    name: "IncompatibleTypes",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "typeOf",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "length",
        type: "uint256"
      }
    ],
    name: "InvalidByteLength",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidInitialization",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidType",
    type: "error"
  },
  {
    inputs: [],
    name: "IsNotScalar",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "NotHostOwner",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializing",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializingFromEmptyProxy",
    type: "error"
  },
  {
    inputs: [],
    name: "NotPowerOfTwo",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [],
    name: "SecondOperandIsNotScalar",
    type: "error"
  },
  {
    inputs: [],
    name: "UUPSUnauthorizedCallContext",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "slot",
        type: "bytes32"
      }
    ],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    inputs: [],
    name: "UnsupportedType",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "ct",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "enum FheType",
        name: "toType",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "Cast",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheAdd",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheBitAnd",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheBitOr",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheBitXor",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheDiv",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheEq",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheGe",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheGt",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "control",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "ifTrue",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "ifFalse",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheIfThenElse",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheLe",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheLt",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheMax",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheMin",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheMul",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheNe",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "ct",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheNeg",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "ct",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheNot",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "enum FheType",
        name: "randType",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "bytes16",
        name: "seed",
        type: "bytes16"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheRand",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "upperBound",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "enum FheType",
        name: "randType",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "bytes16",
        name: "seed",
        type: "bytes16"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheRandBounded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheRem",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheRotl",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheRotr",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheShl",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheShr",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "FheSub",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "pt",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "enum FheType",
        name: "toType",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "TrivialEncrypt",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "inputHandle",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "userAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "inputProof",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "enum FheType",
        name: "inputType",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "VerifyCiphertext",
    type: "event"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "ct",
        type: "bytes32"
      },
      {
        internalType: "enum FheType",
        name: "toType",
        type: "uint8"
      }
    ],
    name: "cast",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheAdd",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheBitAnd",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheBitOr",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheBitXor",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheDiv",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheEq",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheGe",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheGt",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "control",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "ifTrue",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "ifFalse",
        type: "bytes32"
      }
    ],
    name: "fheIfThenElse",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheLe",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheLt",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheMax",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheMin",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheMul",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheNe",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "ct",
        type: "bytes32"
      }
    ],
    name: "fheNeg",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "ct",
        type: "bytes32"
      }
    ],
    name: "fheNot",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "randType",
        type: "uint8"
      }
    ],
    name: "fheRand",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "upperBound",
        type: "uint256"
      },
      {
        internalType: "enum FheType",
        name: "randType",
        type: "uint8"
      }
    ],
    name: "fheRandBounded",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheRem",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheRotl",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheRotr",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheShl",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheShr",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      }
    ],
    name: "fheSub",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getACLAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getHCULimitAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getHandleVersion",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getInputVerifierAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVersion",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "initializeFromEmptyProxy",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "reinitializeV3",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "pt",
        type: "uint256"
      },
      {
        internalType: "enum FheType",
        name: "toType",
        type: "uint8"
      }
    ],
    name: "trivialEncrypt",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "inputHandle",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "userAddress",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "inputProof",
        type: "bytes"
      },
      {
        internalType: "enum FheType",
        name: "inputType",
        type: "uint8"
      }
    ],
    name: "verifyCiphertext",
    outputs: [
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
]);

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/FHEVMExecutor.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FHEVMExecutor_fhevmExecutorReadonlyContract;
var _FHEVMExecutor_fhevmExecutorContractAddress;
var _FHEVMExecutor_aclAddress;
var _FHEVMExecutor_hcuLimitAddress;
var _FHEVMExecutor_inputVerifierAddress;
var _FHEVMExecutor_version;
var FHEVMExecutor = class _FHEVMExecutor extends FhevmCoprocessorContractWrapper {
  constructor() {
    super("FHEVMExecutor");
    _FHEVMExecutor_fhevmExecutorReadonlyContract.set(this, void 0);
    _FHEVMExecutor_fhevmExecutorContractAddress.set(this, void 0);
    _FHEVMExecutor_aclAddress.set(this, void 0);
    _FHEVMExecutor_hcuLimitAddress.set(this, void 0);
    _FHEVMExecutor_inputVerifierAddress.set(this, void 0);
    _FHEVMExecutor_version.set(this, void 0);
  }
  static async create(runner, fhevmExecutorContractAddress, abi, properties) {
    assertIsAddress(fhevmExecutorContractAddress, "fhevmExecutorContractAddress");
    const fhevmExecutor = new _FHEVMExecutor();
    __classPrivateFieldSet3(fhevmExecutor, _FHEVMExecutor_fhevmExecutorContractAddress, fhevmExecutorContractAddress, "f");
    __classPrivateFieldSet3(fhevmExecutor, _FHEVMExecutor_fhevmExecutorReadonlyContract, new ethers_exports.Contract(fhevmExecutorContractAddress, abi ?? FHEVMExecutorPartialInterface, runner), "f");
    __classPrivateFieldSet3(fhevmExecutor, _FHEVMExecutor_aclAddress, properties == null ? void 0 : properties.aclAddress, "f");
    __classPrivateFieldSet3(fhevmExecutor, _FHEVMExecutor_hcuLimitAddress, properties == null ? void 0 : properties.hcuLimitAddress, "f");
    __classPrivateFieldSet3(fhevmExecutor, _FHEVMExecutor_inputVerifierAddress, properties == null ? void 0 : properties.inputVerifierAddress, "f");
    __classPrivateFieldSet3(fhevmExecutor, _FHEVMExecutor_version, properties == null ? void 0 : properties.version, "f");
    await fhevmExecutor._initialize();
    return fhevmExecutor;
  }
  get readonlyContract() {
    assertFhevm(__classPrivateFieldGet3(this, _FHEVMExecutor_fhevmExecutorReadonlyContract, "f") !== void 0, `FHEVMExecutor wrapper is not yet initialized`);
    return __classPrivateFieldGet3(this, _FHEVMExecutor_fhevmExecutorReadonlyContract, "f");
  }
  get interface() {
    assertFhevm(__classPrivateFieldGet3(this, _FHEVMExecutor_fhevmExecutorReadonlyContract, "f") !== void 0, `FHEVMExecutor wrapper is not yet initialized`);
    return __classPrivateFieldGet3(this, _FHEVMExecutor_fhevmExecutorReadonlyContract, "f").interface;
  }
  get address() {
    assertFhevm(__classPrivateFieldGet3(this, _FHEVMExecutor_fhevmExecutorContractAddress, "f") !== void 0, `FHEVMExecutor wrapper is not yet initialized`);
    return __classPrivateFieldGet3(this, _FHEVMExecutor_fhevmExecutorContractAddress, "f");
  }
  get version() {
    assertFhevm(__classPrivateFieldGet3(this, _FHEVMExecutor_version, "f") !== void 0, `FHEVMExecutor wrapper is not yet initialized`);
    return __classPrivateFieldGet3(this, _FHEVMExecutor_version, "f");
  }
  get aclAddress() {
    assertFhevm(__classPrivateFieldGet3(this, _FHEVMExecutor_aclAddress, "f") !== void 0, `FHEVMExecutor wrapper is not yet initialized`);
    return __classPrivateFieldGet3(this, _FHEVMExecutor_aclAddress, "f");
  }
  get hcuLimitAddress() {
    assertFhevm(__classPrivateFieldGet3(this, _FHEVMExecutor_hcuLimitAddress, "f") !== void 0, `FHEVMExecutor wrapper is not yet initialized`);
    return __classPrivateFieldGet3(this, _FHEVMExecutor_hcuLimitAddress, "f");
  }
  get inputVerifierAddress() {
    assertFhevm(__classPrivateFieldGet3(this, _FHEVMExecutor_inputVerifierAddress, "f") !== void 0, `FHEVMExecutor wrapper is not yet initialized`);
    return __classPrivateFieldGet3(this, _FHEVMExecutor_inputVerifierAddress, "f");
  }
  async _initialize() {
    assertFhevm(__classPrivateFieldGet3(this, _FHEVMExecutor_fhevmExecutorReadonlyContract, "f") !== void 0, `FHEVMExecutor wrapper is not initialized`);
    if (!__classPrivateFieldGet3(this, _FHEVMExecutor_aclAddress, "f")) {
      __classPrivateFieldSet3(this, _FHEVMExecutor_aclAddress, await this._callOrThrow(__classPrivateFieldGet3(this, _FHEVMExecutor_fhevmExecutorReadonlyContract, "f").getACLAddress(), "getACLAddress()"), "f");
    }
    assertIsAddress(__classPrivateFieldGet3(this, _FHEVMExecutor_aclAddress, "f"), "aclAddress");
    if (!__classPrivateFieldGet3(this, _FHEVMExecutor_hcuLimitAddress, "f")) {
      __classPrivateFieldSet3(this, _FHEVMExecutor_hcuLimitAddress, await this._callOrThrow(__classPrivateFieldGet3(this, _FHEVMExecutor_fhevmExecutorReadonlyContract, "f").getHCULimitAddress(), "getHCULimitAddress()"), "f");
    }
    assertIsAddress(__classPrivateFieldGet3(this, _FHEVMExecutor_hcuLimitAddress, "f"), "hcuLimitAddress");
    if (!__classPrivateFieldGet3(this, _FHEVMExecutor_inputVerifierAddress, "f")) {
      __classPrivateFieldSet3(this, _FHEVMExecutor_inputVerifierAddress, await this._callOrThrow(__classPrivateFieldGet3(this, _FHEVMExecutor_fhevmExecutorReadonlyContract, "f").getInputVerifierAddress(), "getInputVerifierAddress()"), "f");
    }
    assertIsAddress(__classPrivateFieldGet3(this, _FHEVMExecutor_inputVerifierAddress, "f"), "inputVerifierAddress");
    if (!__classPrivateFieldGet3(this, _FHEVMExecutor_version, "f")) {
      __classPrivateFieldSet3(this, _FHEVMExecutor_version, await this._callOrThrow(__classPrivateFieldGet3(this, _FHEVMExecutor_fhevmExecutorReadonlyContract, "f").getVersion(), "getVersion()"), "f");
    }
    assertIsString(__classPrivateFieldGet3(this, _FHEVMExecutor_version, "f"), "version");
  }
};
_FHEVMExecutor_fhevmExecutorReadonlyContract = /* @__PURE__ */ new WeakMap(), _FHEVMExecutor_fhevmExecutorContractAddress = /* @__PURE__ */ new WeakMap(), _FHEVMExecutor_aclAddress = /* @__PURE__ */ new WeakMap(), _FHEVMExecutor_hcuLimitAddress = /* @__PURE__ */ new WeakMap(), _FHEVMExecutor_inputVerifierAddress = /* @__PURE__ */ new WeakMap(), _FHEVMExecutor_version = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/interfaces/HCULimit.itf.js
var HCULimitPartialInterface = new ethers_exports.Interface([
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [],
    name: "CallerMustBeFHEVMExecutorContract",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  {
    inputs: [],
    name: "ERC1967NonPayable",
    type: "error"
  },
  {
    inputs: [],
    name: "FailedCall",
    type: "error"
  },
  {
    inputs: [],
    name: "HCUTransactionDepthLimitExceeded",
    type: "error"
  },
  {
    inputs: [],
    name: "HCUTransactionLimitExceeded",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidInitialization",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "NotHostOwner",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializing",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializingFromEmptyProxy",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyScalarOperationsAreSupported",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [],
    name: "UUPSUnauthorizedCallContext",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "slot",
        type: "bytes32"
      }
    ],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    inputs: [],
    name: "UnsupportedOperation",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "ct",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForCast",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheAdd",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheBitAnd",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheBitOr",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheBitXor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheDiv",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheEq",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheGe",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheGt",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheLe",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheLt",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheMax",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheMin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheMul",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheNe",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "ct",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheNeg",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "ct",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheNot",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheRand",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheRandBounded",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheRem",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheRotl",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheRotr",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheShl",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheShr",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes1",
        name: "scalarByte",
        type: "bytes1"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForFheSub",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "lhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "middle",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "rhs",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForIfThenElse",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum FheType",
        name: "resultType",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "result",
        type: "bytes32"
      }
    ],
    name: "checkHCUForTrivialEncrypt",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getFHEVMExecutorAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVersion",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "initializeFromEmptyProxy",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "reinitializeV4",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
]);

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/HCULimit.js
var __classPrivateFieldSet4 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HCULimit_hcuLimitContract;
var _HCULimit_hcuLimitContractAddress;
var _HCULimit_fhemExecutorAddress;
var _HCULimit_version;
var HCULimit = class _HCULimit extends FhevmCoprocessorContractWrapper {
  constructor() {
    super("HCULimit");
    _HCULimit_hcuLimitContract.set(this, void 0);
    _HCULimit_hcuLimitContractAddress.set(this, void 0);
    _HCULimit_fhemExecutorAddress.set(this, void 0);
    _HCULimit_version.set(this, void 0);
  }
  static async create(runner, hcuLimitContractAddress, abi, properties) {
    assertIsAddress(hcuLimitContractAddress, "hcuLimitContractAddress");
    if (properties !== void 0) {
      throw new FhevmError("Not yet implemented");
    }
    const hcuLimit = new _HCULimit();
    __classPrivateFieldSet4(hcuLimit, _HCULimit_hcuLimitContractAddress, hcuLimitContractAddress, "f");
    __classPrivateFieldSet4(hcuLimit, _HCULimit_hcuLimitContract, new ethers_exports.Contract(hcuLimitContractAddress, abi ?? HCULimitPartialInterface, runner), "f");
    await hcuLimit._initialize();
    return hcuLimit;
  }
  get readonlyContract() {
    assertFhevm(__classPrivateFieldGet4(this, _HCULimit_hcuLimitContract, "f") !== void 0, `HCULimit wrapper is not yet initialized`);
    return __classPrivateFieldGet4(this, _HCULimit_hcuLimitContract, "f");
  }
  get interface() {
    assertFhevm(__classPrivateFieldGet4(this, _HCULimit_hcuLimitContract, "f") !== void 0, `HCULimit wrapper is not yet initialized`);
    return __classPrivateFieldGet4(this, _HCULimit_hcuLimitContract, "f").interface;
  }
  get address() {
    assertFhevm(__classPrivateFieldGet4(this, _HCULimit_hcuLimitContractAddress, "f") !== void 0, `HCULimit wrapper is not yet initialized`);
    return __classPrivateFieldGet4(this, _HCULimit_hcuLimitContractAddress, "f");
  }
  get version() {
    assertFhevm(__classPrivateFieldGet4(this, _HCULimit_version, "f") !== void 0, `HCULimit wrapper is not yet initialized`);
    return __classPrivateFieldGet4(this, _HCULimit_version, "f");
  }
  get fhemExecutorAddress() {
    assertFhevm(__classPrivateFieldGet4(this, _HCULimit_fhemExecutorAddress, "f") !== void 0, `HCULimit wrapper is not yet initialized`);
    return __classPrivateFieldGet4(this, _HCULimit_fhemExecutorAddress, "f");
  }
  async _initialize() {
    assertFhevm(__classPrivateFieldGet4(this, _HCULimit_hcuLimitContract, "f") !== void 0, `HCULimit wrapper is not yet initialized`);
    assertFhevm(__classPrivateFieldGet4(this, _HCULimit_fhemExecutorAddress, "f") === void 0, `HCULimit wrapper already initialized`);
    __classPrivateFieldSet4(this, _HCULimit_fhemExecutorAddress, await __classPrivateFieldGet4(this, _HCULimit_hcuLimitContract, "f").getFHEVMExecutorAddress(), "f");
    assertIsAddress(__classPrivateFieldGet4(this, _HCULimit_fhemExecutorAddress, "f"), "fhemExecutorAddress");
    __classPrivateFieldSet4(this, _HCULimit_version, await __classPrivateFieldGet4(this, _HCULimit_hcuLimitContract, "f").getVersion(), "f");
    assertIsString(__classPrivateFieldGet4(this, _HCULimit_version, "f"), "version");
  }
};
_HCULimit_hcuLimitContract = /* @__PURE__ */ new WeakMap(), _HCULimit_hcuLimitContractAddress = /* @__PURE__ */ new WeakMap(), _HCULimit_fhemExecutorAddress = /* @__PURE__ */ new WeakMap(), _HCULimit_version = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/ethers/eip712.js
async function signEIP712(signer, domain, types, message) {
  const signature = await signer.signTypedData(domain, types, message);
  const sigRSV = ethers_exports.Signature.from(signature);
  const v = 27 + sigRSV.yParity;
  const r = sigRSV.r;
  const s = sigRSV.s;
  const result = r + removePrefix(s, "0x") + v.toString(16);
  return result;
}
async function multiSignEIP712(signers, domain, types, message) {
  const signatures = [];
  for (let idx = 0; idx < signers.length; idx++) {
    const signer = signers[idx];
    const signature = await signEIP712(signer, domain, types, message);
    signatures.push(signature);
  }
  return signatures;
}
function assertIsEIP712Domain(eip712Domain, name, expectedDomain) {
  assertFhevm(Array.isArray(eip712Domain), `Invalid ${name} EIP712 domain`);
  assertFhevm(eip712Domain.length >= 5, `Invalid ${name} EIP712 domain`);
  assertFhevm(eip712Domain[1] === expectedDomain.name, `Invalid ${name} EIP712 domain name. Got ${eip712Domain[1]}, expected ${expectedDomain.name}`);
  assertFhevm(eip712Domain[2] === expectedDomain.version, `Invalid ${name} EIP712 domain name. Got ${eip712Domain[2]}, expected ${expectedDomain.version}`);
  assertFhevm(eip712Domain[3] === expectedDomain.chainId, `Invalid ${name} EIP712 domain name. Got ${eip712Domain[3]}, expected ${expectedDomain.chainId}`);
  assertFhevm(eip712Domain[4] === expectedDomain.verifyingContract, `Invalid ${name} EIP712 domain name. Got ${eip712Domain[4]}, expected ${expectedDomain.verifyingContract}`);
}
function isThresholdReached(signersAddress, recoveredAddresses, threshold, signerType) {
  const addressMap = /* @__PURE__ */ new Map();
  recoveredAddresses.forEach((address, index) => {
    if (addressMap.has(address)) {
      const duplicateValue = address;
      throw new FhevmError(`Duplicate ${signerType} signer address found: ${duplicateValue} appears multiple times in recovered addresses`);
    }
    addressMap.set(address, index);
  });
  for (const address of recoveredAddresses) {
    if (!signersAddress.includes(address)) {
      throw new FhevmError(`Invalid address found: ${address} is not in the list of ${signerType} signers`);
    }
  }
  return recoveredAddresses.length >= threshold;
}

// node_modules/@fhevm/mock-utils/_esm/utils/bytes.js
function assertIsUint8Array(value, valueName) {
  assertFhevm(value instanceof Uint8Array, `${valueName ?? "value"} is not of type Uint8Array`);
}
function assertIsBytes32String(value, valueName) {
  assertIsBytesString(value, 32, valueName);
}
function assertIsBytesString(value, width, valueName) {
  assertIsString(value, valueName);
  if (width === void 0) {
    assertFhevm(ethers_exports.isBytesLike(value), `${valueName ?? "value"} : ${value} is not a valid bytes string`);
  } else {
    assertFhevm(value === ethers_exports.toBeHex(value, width), `${valueName ?? "value"} : ${value} is not a valid bytes${width} string`);
  }
}
function assertIsBytes1(value, valueName) {
  assertIsBytes(value, 1, valueName);
}
function assertIsBytes20(value, valueName) {
  assertIsBytes(value, 20, valueName);
}
function assertIsBytes32(value, valueName) {
  assertIsBytes(value, 32, valueName);
}
function assertIsBytes(value, width, valueName) {
  assertIsUint8Array(value, valueName);
  if (width === void 0) {
    assertFhevm(ethers_exports.isBytesLike(value), `${valueName ?? "value"} : ${value} is not a valid bytes string`);
  } else {
    assertFhevm(value.length === width, `${valueName ?? "value"} : ${value} is not a valid bytes${width} Uint8Array. Expecting length ${width}, got ${value.length} instead`);
  }
}
function uintToBytes(value, width) {
  return ethers_exports.getBytes(ethers_exports.toBeHex(value, width));
}
function concatBytes(...arrays) {
  const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const arr of arrays) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}

// node_modules/@fhevm/mock-utils/_esm/utils/hex.js
function numberToHexNoPrefix(num) {
  const hex = num.toString(16);
  return hex.length % 2 ? "0" + hex : hex;
}
var fromHexString = (hexString) => {
  const arr = hexString.replace(/^(0x)/, "").match(/.{1,2}/g);
  if (!arr)
    return new Uint8Array();
  return Uint8Array.from(arr.map((byte) => parseInt(byte, 16)));
};
var toHexString = (bytes) => `0x${bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "")}`;
function assertIsHexString(value, valueName) {
  assertIsString(value, valueName);
  assertFhevm(ethers_exports.isHexString(value), `${valueName ?? "value"}: ${value} is not a valid hex string.`);
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/interfaces/InputVerifier.itf.js
var InputVerifierPartialInterface = new ethers_exports.Interface([
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [],
    name: "AlreadySigner",
    type: "error"
  },
  {
    inputs: [],
    name: "AtLeastOneSignerIsRequired",
    type: "error"
  },
  {
    inputs: [],
    name: "DeserializingInputProofFail",
    type: "error"
  },
  {
    inputs: [],
    name: "ECDSAInvalidSignature",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "length",
        type: "uint256"
      }
    ],
    name: "ECDSAInvalidSignatureLength",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "ECDSAInvalidSignatureS",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  {
    inputs: [],
    name: "ERC1967NonPayable",
    type: "error"
  },
  {
    inputs: [],
    name: "EmptyInputProof",
    type: "error"
  },
  {
    inputs: [],
    name: "FailedCall",
    type: "error"
  },
  {
    inputs: [],
    name: "InitialSignersSetIsEmpty",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidChainId",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidHandleVersion",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidIndex",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidInitialization",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidInputHandle",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signerRecovered",
        type: "address"
      }
    ],
    name: "InvalidSigner",
    type: "error"
  },
  {
    inputs: [],
    name: "NotASigner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "NotHostOwner",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializing",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializingFromEmptyProxy",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "numSignatures",
        type: "uint256"
      }
    ],
    name: "SignatureThresholdNotReached",
    type: "error"
  },
  {
    inputs: [],
    name: "SignaturesVerificationFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "SignerNull",
    type: "error"
  },
  {
    inputs: [],
    name: "UUPSUnauthorizedCallContext",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "slot",
        type: "bytes32"
      }
    ],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    inputs: [],
    name: "ZeroSignature",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "SignerAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "SignerRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    inputs: [],
    name: "EIP712_INPUT_VERIFICATION_TYPE",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "EIP712_INPUT_VERIFICATION_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "addSigner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "cleanTransientStorage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCoprocessorSigners",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getHandleVersion",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getThreshold",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVersion",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "verifyingContractSource",
        type: "address"
      },
      {
        internalType: "uint64",
        name: "chainIDSource",
        type: "uint64"
      },
      {
        internalType: "address[]",
        name: "initialSigners",
        type: "address[]"
      }
    ],
    name: "initializeFromEmptyProxy",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "isSigner",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "reinitializeV3",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "removeSigner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "userAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "contractAddress",
            type: "address"
          }
        ],
        internalType: "struct FHEVMExecutor.ContextUserInputs",
        name: "context",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "inputHandle",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "inputProof",
        type: "bytes"
      }
    ],
    name: "verifyCiphertext",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
]);

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/InputVerifier.js
var __classPrivateFieldSet5 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet5 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InputVerifier_inputVerifierReadonlyContract;
var _InputVerifier_inputVerifierContractAddress;
var _InputVerifier_signersAddresses;
var _InputVerifier_threshold;
var _InputVerifier_eip712Domain;
var InputVerifier = class _InputVerifier extends FhevmCoprocessorContractWrapper {
  constructor() {
    super("InputVerifier");
    _InputVerifier_inputVerifierReadonlyContract.set(this, void 0);
    _InputVerifier_inputVerifierContractAddress.set(this, void 0);
    _InputVerifier_signersAddresses.set(this, void 0);
    _InputVerifier_threshold.set(this, void 0);
    _InputVerifier_eip712Domain.set(this, void 0);
  }
  static async create(runner, inputVerifierContractAddress, abi, properties) {
    assertIsAddress(inputVerifierContractAddress, "inputVerifierContractAddress");
    const inputVerifier = new _InputVerifier();
    __classPrivateFieldSet5(inputVerifier, _InputVerifier_inputVerifierContractAddress, inputVerifierContractAddress, "f");
    __classPrivateFieldSet5(inputVerifier, _InputVerifier_inputVerifierReadonlyContract, new ethers_exports.Contract(inputVerifierContractAddress, abi ?? InputVerifierPartialInterface, runner), "f");
    __classPrivateFieldSet5(inputVerifier, _InputVerifier_eip712Domain, properties == null ? void 0 : properties.eip712Domain, "f");
    __classPrivateFieldSet5(inputVerifier, _InputVerifier_signersAddresses, properties == null ? void 0 : properties.signersAddresses, "f");
    __classPrivateFieldSet5(inputVerifier, _InputVerifier_threshold, properties == null ? void 0 : properties.threshold, "f");
    await inputVerifier._initialize();
    return inputVerifier;
  }
  get readonlyContract() {
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_inputVerifierReadonlyContract, "f") !== void 0, `InputVerifier wrapper is not initialized`);
    return __classPrivateFieldGet5(this, _InputVerifier_inputVerifierReadonlyContract, "f");
  }
  get interface() {
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_inputVerifierReadonlyContract, "f") !== void 0, `InputVerifier wrapper is not yet initialized`);
    return __classPrivateFieldGet5(this, _InputVerifier_inputVerifierReadonlyContract, "f").interface;
  }
  async _initialize() {
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_inputVerifierReadonlyContract, "f") !== void 0, `InputVerifier wrapper is not initialized`);
    if (!__classPrivateFieldGet5(this, _InputVerifier_signersAddresses, "f")) {
      const signers = await __classPrivateFieldGet5(this, _InputVerifier_inputVerifierReadonlyContract, "f").getCoprocessorSigners();
      __classPrivateFieldSet5(this, _InputVerifier_signersAddresses, signers, "f");
    }
    assertIsAddressArray(__classPrivateFieldGet5(this, _InputVerifier_signersAddresses, "f"));
    if (__classPrivateFieldGet5(this, _InputVerifier_threshold, "f") === void 0) {
      const threshold = await __classPrivateFieldGet5(this, _InputVerifier_inputVerifierReadonlyContract, "f").getThreshold();
      assertIsBigUint8(threshold);
      __classPrivateFieldSet5(this, _InputVerifier_threshold, Number(threshold), "f");
    }
    if (__classPrivateFieldGet5(this, _InputVerifier_eip712Domain, "f") === void 0) {
      const eip712Domain = await __classPrivateFieldGet5(this, _InputVerifier_inputVerifierReadonlyContract, "f").eip712Domain();
      assertFhevm(eip712Domain.length === 7);
      assertIsString(eip712Domain[0], "eip712Domain[0]");
      assertIsString(eip712Domain[1], "eip712Domain[1]");
      assertIsString(eip712Domain[2], "eip712Domain[2]");
      assertIsBigUint256(eip712Domain[3], "eip712Domain[3]");
      assertIsAddress(eip712Domain[4], "eip712Domain[4]");
      assertIsBytes32String(eip712Domain[5], "eip712Domain[5]");
      assertFhevm(Array.isArray(eip712Domain[6]) && eip712Domain[6].length === 0, "eip712Domain[6]");
      __classPrivateFieldSet5(this, _InputVerifier_eip712Domain, {
        fields: Number(BigInt(eip712Domain[0])),
        name: eip712Domain[1],
        version: eip712Domain[2],
        chainId: eip712Domain[3],
        verifyingContract: eip712Domain[4],
        salt: eip712Domain[5]
        // last field is ignored
      }, "f");
    }
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_eip712Domain, "f").fields === Number(15));
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_eip712Domain, "f").salt === ethers_exports.ZeroHash);
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_eip712Domain, "f").name === constants_default.INPUT_VERIFICATION_EIP712.domain.name);
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_eip712Domain, "f").version === constants_default.INPUT_VERIFICATION_EIP712.domain.version);
  }
  get address() {
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_inputVerifierContractAddress, "f") !== void 0, `InputVerifier wrapper not initialized`);
    return __classPrivateFieldGet5(this, _InputVerifier_inputVerifierContractAddress, "f");
  }
  // The InputVerifier is always using the gatewayChainId in its eip712 domain
  get gatewayChainId() {
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_eip712Domain, "f") !== void 0, `InputVerifier wrapper not initialized`);
    return __classPrivateFieldGet5(this, _InputVerifier_eip712Domain, "f").chainId;
  }
  // The InputVerifier is always using the address of the "InputVerification.sol" contract deployed
  // on the gateway chainId in its eip712 domain
  get gatewayInputVerificationAddress() {
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_eip712Domain, "f") !== void 0, `InputVerifier wrapper not initialized`);
    return __classPrivateFieldGet5(this, _InputVerifier_eip712Domain, "f").verifyingContract;
  }
  get eip712Domain() {
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_eip712Domain, "f") !== void 0, `InputVerifier wrapper not initialized`);
    return __classPrivateFieldGet5(this, _InputVerifier_eip712Domain, "f");
  }
  getCoprocessorSigners() {
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_signersAddresses, "f") !== void 0, `InputVerifier wrapper not initialized`);
    return __classPrivateFieldGet5(this, _InputVerifier_signersAddresses, "f");
  }
  getThreshold() {
    assertFhevm(__classPrivateFieldGet5(this, _InputVerifier_threshold, "f") !== void 0, `InputVerifier wrapper not initialized`);
    return __classPrivateFieldGet5(this, _InputVerifier_threshold, "f");
  }
  async assertMatchCoprocessorSigners(signers) {
    const addresses = this.getCoprocessorSigners();
    assertIsArray(signers, "signers");
    assertFhevm(signers.length === addresses.length, "signers.length === addresses.length");
    for (let i = 0; i < addresses.length; ++i) {
      const s = await signers[i].getAddress();
      assertFhevm(addresses[i] === s, `addresses[${i}] === await signers[${i}].getAddress()`);
    }
  }
  verifySignatures(handlesBytes32List, userAddress, contractAddress, contractChainId, extraData, signatures) {
    assertIsArray(signatures);
    const domain = this.eip712Domain;
    const recoveredAddresses = signatures.map((signature) => {
      const sig = ensure0x(signature);
      const recoveredAddress = ethers_exports.verifyTypedData({
        name: domain.name,
        version: domain.version,
        chainId: domain.chainId,
        verifyingContract: domain.verifyingContract
      }, constants_default.INPUT_VERIFICATION_EIP712.types, {
        ctHandles: handlesBytes32List,
        userAddress,
        contractAddress,
        contractChainId,
        extraData
      }, sig);
      return recoveredAddress;
    });
    if (!isThresholdReached(this.getCoprocessorSigners(), recoveredAddresses, this.getThreshold(), "coprocessor")) {
      throw new FhevmError("Coprocessor signers threshold is not reached");
    }
  }
  // See: fhevm-gateway/contracts/InputVerification.sol
  createCiphertextVerificationEIP712(handlesBytes32List, contractChainId, contractAddress, userAddress, extraData) {
    assertIsAddress(userAddress, "userAddress");
    assertIsAddress(contractAddress, "contractAddress");
    const domain = this.eip712Domain;
    const eip712 = {
      domain: {
        chainId: domain.chainId,
        name: domain.name,
        version: domain.version,
        verifyingContract: domain.verifyingContract
      },
      types: constants_default.INPUT_VERIFICATION_EIP712.types,
      message: {
        ctHandles: handlesBytes32List.map((handle) => ethers_exports.zeroPadValue(ethers_exports.toBeHex(handle), 32)),
        userAddress,
        contractAddress,
        contractChainId,
        extraData
      }
    };
    return eip712;
  }
};
_InputVerifier_inputVerifierReadonlyContract = /* @__PURE__ */ new WeakMap(), _InputVerifier_inputVerifierContractAddress = /* @__PURE__ */ new WeakMap(), _InputVerifier_signersAddresses = /* @__PURE__ */ new WeakMap(), _InputVerifier_threshold = /* @__PURE__ */ new WeakMap(), _InputVerifier_eip712Domain = /* @__PURE__ */ new WeakMap();
function computeInputProofHex(handlesBytes32Hex, coprocessorsSignaturesHex, extraData) {
  const numHandles = handlesBytes32Hex.length;
  const numCoprocessorSigners = coprocessorsSignaturesHex.length;
  const numHandlesHexByte1 = numberToHexNoPrefix(numHandles);
  assertFhevm(numHandlesHexByte1.length === 2);
  const numCoprocessorSignersHexByte1 = numberToHexNoPrefix(numCoprocessorSigners);
  assertFhevm(numCoprocessorSignersHexByte1.length === 2);
  let inputProofHex = "0x" + numHandlesHexByte1 + numCoprocessorSignersHexByte1;
  for (let i = 0; i < numHandles; ++i) {
    const handlesBytes32HexNoPrefix = removePrefix(handlesBytes32Hex[i], "0x");
    assertFhevm(handlesBytes32HexNoPrefix.length === 2 * 32);
    inputProofHex += handlesBytes32HexNoPrefix;
  }
  coprocessorsSignaturesHex.map((signatureHex) => {
    const signatureBytes65HexNoPrefix = removePrefix(signatureHex, "0x");
    if (signatureBytes65HexNoPrefix.length !== 2 * 65) {
      throw new FhevmError(`Invalid coprocessor signature: ${signatureBytes65HexNoPrefix}. Invalid length.`);
    }
    inputProofHex += signatureBytes65HexNoPrefix;
  });
  inputProofHex = ethers_exports.concat([inputProofHex, extraData]);
  return inputProofHex;
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/FhevmHandle.js
var __classPrivateFieldSet6 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet6 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FhevmHandle_hash21;
var _FhevmHandle_chainId;
var _FhevmHandle_fhevmType;
var _FhevmHandle_fheType;
var _FhevmHandle_version;
var _FhevmHandle_computed;
var _FhevmHandle_index;
var FhevmHandle = class _FhevmHandle {
  constructor(hash21, chainId, fhevmType, fheType, version2, computed, index) {
    _FhevmHandle_hash21.set(this, void 0);
    _FhevmHandle_chainId.set(this, void 0);
    _FhevmHandle_fhevmType.set(this, void 0);
    _FhevmHandle_fheType.set(this, void 0);
    _FhevmHandle_version.set(this, void 0);
    _FhevmHandle_computed.set(this, void 0);
    _FhevmHandle_index.set(this, void 0);
    __classPrivateFieldSet6(this, _FhevmHandle_hash21, hash21, "f");
    __classPrivateFieldSet6(this, _FhevmHandle_chainId, chainId, "f");
    __classPrivateFieldSet6(this, _FhevmHandle_fhevmType, fhevmType, "f");
    __classPrivateFieldSet6(this, _FhevmHandle_fheType, fheType, "f");
    __classPrivateFieldSet6(this, _FhevmHandle_version, version2, "f");
    __classPrivateFieldSet6(this, _FhevmHandle_computed, computed, "f");
    if (index !== void 0) {
      __classPrivateFieldSet6(this, _FhevmHandle_index, index, "f");
    }
  }
  get hash21() {
    return __classPrivateFieldGet6(this, _FhevmHandle_hash21, "f");
  }
  get chainId() {
    return __classPrivateFieldGet6(this, _FhevmHandle_chainId, "f");
  }
  get fhevmType() {
    return __classPrivateFieldGet6(this, _FhevmHandle_fhevmType, "f");
  }
  get fheType() {
    return __classPrivateFieldGet6(this, _FhevmHandle_fheType, "f");
  }
  get version() {
    return __classPrivateFieldGet6(this, _FhevmHandle_version, "f");
  }
  get computed() {
    return __classPrivateFieldGet6(this, _FhevmHandle_computed, "f");
  }
  get index() {
    return __classPrivateFieldGet6(this, _FhevmHandle_index, "f");
  }
  get fhevmTypeInfo() {
    return getFhevmTypeInfo(__classPrivateFieldGet6(this, _FhevmHandle_fhevmType, "f"));
  }
  get fheTypeInfo() {
    return getFheTypeInfo(__classPrivateFieldGet6(this, _FhevmHandle_fheType, "f"));
  }
  /**
   * Handles have the following format:
   * [21 first random bytes from hashing] | index_21 | chainID_22...29 | type_30 | version_31
   *
   * Handle format for user inputs and ops results are as such:
   * keccak256(keccak256(CiphertextFHEList)||index_handle)[0:20] || index_handle[21] || chainID [22:29] ||  handle_type [30] || handle_version [31]
   * If the handle stems from computation, the index_handle must be set to 0xff.
   * The CiphertextFHEList actually contains: 1 byte (= N) for size of handles_list, N bytes for the handles_types : 1 per handle, then the original fhe160list raw ciphertext
   */
  static fromBytes32Hex(handleBytes32Hex) {
    assertFhevm(typeof handleBytes32Hex === "string", `handle argument type mismatch. Got a ${typeof handleBytes32Hex}, expecting a string.`);
    if (!ethers_exports.isHexString(handleBytes32Hex, 32)) {
      throw new FhevmError(`Invalid handle ${handleBytes32Hex}, handle length sould be 66`);
    }
    const hash21 = handleBytes32Hex.slice(0, 44);
    const handleIndexHex = handleBytes32Hex.slice(44, 46);
    let handleIndex = 0;
    try {
      handleIndex = toUIntNumber("0x" + handleIndexHex);
    } catch {
      throw new FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 21 does not contain a valid index`);
    }
    const computed = handleIndex === 255;
    const handleChainIdHex = handleBytes32Hex.slice(46, 62);
    let chainId = 0;
    try {
      chainId = toUIntNumber("0x" + handleChainIdHex);
    } catch {
      throw new FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 22-29 does not contain a valid chainId`);
    }
    const handleTypeHex = handleBytes32Hex.slice(62, 64);
    let fheType = void 0;
    let fhevmType = void 0;
    try {
      const t = toUIntNumber("0x" + handleTypeHex);
      fheType = t;
      fhevmType = t;
    } catch {
      throw new FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 30 does not contain the a valid (got 0x${handleTypeHex}).`);
    }
    checkFheType(fheType);
    checkFhevmType(fhevmType);
    const handleVersionHex = handleBytes32Hex.slice(64, 66);
    let version2 = 0;
    try {
      version2 = toUIntNumber("0x" + handleVersionHex);
    } catch {
      throw new FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 31 does not contain a valid version number.`);
    }
    if (version2 !== constants_default.FHEVM_HANDLE_VERSION) {
      throw new FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 31 does not contain the expected version=${constants_default.FHEVM_HANDLE_VERSION}, got ${version2} instead`);
    }
    const fhevmHandle = new _FhevmHandle(hash21, chainId, fhevmType, fheType, version2, computed, handleIndex < 255 ? handleIndex : void 0);
    return fhevmHandle;
  }
  static verify(handleBytes32, expected) {
    assertIsBytes32String(handleBytes32, "handleBytes32");
    if (handleBytes32 === ethers_exports.ZeroHash) {
      throw new FhevmError("Handle is not initialized");
    }
    const fhevmHandle = _FhevmHandle.fromBytes32Hex(handleBytes32);
    if ((expected == null ? void 0 : expected.chainId) !== void 0) {
      if (fhevmHandle.chainId !== expected.chainId) {
        throw new FhevmError(`Chain ID mismatch for handle ${handleBytes32}, expected ${expected.chainId}, but got ${fhevmHandle.chainId} instead.`);
      }
    }
    if ((expected == null ? void 0 : expected.fhevmType) !== void 0) {
      if (fhevmHandle.fhevmType !== expected.fhevmType) {
        const fhevmTypeInfo = fhevmHandle.fhevmTypeInfo;
        const expectedFhevmTypeInfo = getFhevmTypeInfo(expected.fhevmType);
        throw new FhevmError(`Type mismatch for handle '${handleBytes32}': expected '${expectedFhevmTypeInfo.name}', but got '${fhevmTypeInfo.name}' instead.`);
      }
    }
    if ((expected == null ? void 0 : expected.fheType) !== void 0) {
      if (fhevmHandle.fheType !== expected.fheType) {
        const fheTypeInfo = fhevmHandle.fheTypeInfo;
        const expectedFheTypeInfo = getFheTypeInfo(expected.fheType);
        throw new FhevmError(`Type mismatch for handle '${handleBytes32}': expected '${expectedFheTypeInfo.type}', but got '${fheTypeInfo.type}' instead.`);
      }
    }
    return fhevmHandle;
  }
  toHandleBytes32() {
    assertFhevm(Number(__classPrivateFieldGet6(this, _FhevmHandle_fheType, "f")) === Number(__classPrivateFieldGet6(this, _FhevmHandle_fhevmType, "f")));
    assertFhevm(__classPrivateFieldGet6(this, _FhevmHandle_index, "f") === void 0 && __classPrivateFieldGet6(this, _FhevmHandle_computed, "f") || __classPrivateFieldGet6(this, _FhevmHandle_index, "f") !== void 0 && __classPrivateFieldGet6(this, _FhevmHandle_index, "f") < 255 && !__classPrivateFieldGet6(this, _FhevmHandle_computed, "f"));
    const chainId32Bytes = uintToBytes(__classPrivateFieldGet6(this, _FhevmHandle_chainId, "f"), 32);
    const chainId8Bytes = chainId32Bytes.subarray(24, 32);
    assertFhevm(chainId32Bytes.length === 32);
    assertFhevm(chainId8Bytes.length === 8);
    const handleHash = ethers_exports.getBytes(__classPrivateFieldGet6(this, _FhevmHandle_hash21, "f"));
    const handleBytes32AsBytes = new Uint8Array(32);
    handleBytes32AsBytes.set(handleHash, 0);
    handleBytes32AsBytes[21] = __classPrivateFieldGet6(this, _FhevmHandle_index, "f") === void 0 ? 255 : __classPrivateFieldGet6(this, _FhevmHandle_index, "f");
    handleBytes32AsBytes.set(chainId8Bytes, 22);
    handleBytes32AsBytes[30] = __classPrivateFieldGet6(this, _FhevmHandle_fheType, "f");
    handleBytes32AsBytes[31] = __classPrivateFieldGet6(this, _FhevmHandle_version, "f");
    return handleBytes32AsBytes;
  }
  toHandleBytes32Hex() {
    return ethers_exports.hexlify(this.toHandleBytes32());
  }
  static createInputHandle(blobHashBytes32, aclAddress, chainId, fhevmType, ciphertextVersion, index) {
    const hash21 = _FhevmHandle._computeInputHash21(blobHashBytes32, aclAddress, chainId, index);
    return new _FhevmHandle(hash21, chainId, fhevmType, fhevmType, ciphertextVersion, false, index);
  }
  /**
   * blobHashBytes32 = keccak256(ciphertextWithZKProof)
   */
  static _computeInputHash21(blobHashBytes32, aclAddress, chainId, index) {
    assertIsBytes32(blobHashBytes32, "blobHash");
    assertIsAddress(aclAddress, "aclAddress");
    assertIsNumber(index, "index");
    assertIsNumber(chainId, "chainId");
    const encryptionIndex1Byte = new Uint8Array([index]);
    const aclContractAddress20Bytes = addressToBytes(aclAddress, "ACL address");
    const chainId32Bytes = uintToBytes(chainId, 32);
    assertIsBytes1(encryptionIndex1Byte);
    assertIsBytes20(aclContractAddress20Bytes);
    assertIsBytes32(chainId32Bytes);
    return ethers_exports.keccak256(concatBytes(blobHashBytes32, encryptionIndex1Byte, aclContractAddress20Bytes, chainId32Bytes));
  }
  static computeHandlesHex(ciphertextWithZKProof, fhevmTypes, aclContractAddress, chainId, ciphertextVersion) {
    const handlesAsBytes = _FhevmHandle.computeHandles(ciphertextWithZKProof, fhevmTypes, aclContractAddress, chainId, ciphertextVersion);
    return handlesAsBytes.map(ethers_exports.hexlify);
  }
  static computeHandles(ciphertextWithZKProof, fhevmTypes, aclContractAddress, chainId, ciphertextVersion) {
    if (BigInt(chainId) > MAX_UINT64) {
      throw new FhevmError("ChainId exceeds maximum allowed value (8 bytes)");
    }
    const blobHashBytes32Hex = ethers_exports.keccak256(ciphertextWithZKProof);
    const blobHashBytes32 = ethers_exports.getBytes(blobHashBytes32Hex);
    assertFhevm(blobHashBytes32.length === 32);
    const handles = fhevmTypes.map((fhevmType, encryptionIndex) => {
      const fhevmHandle = _FhevmHandle.createInputHandle(blobHashBytes32, aclContractAddress, chainId, fhevmType, ciphertextVersion, encryptionIndex);
      return fhevmHandle.toHandleBytes32();
    });
    return handles;
  }
};
_FhevmHandle_hash21 = /* @__PURE__ */ new WeakMap(), _FhevmHandle_chainId = /* @__PURE__ */ new WeakMap(), _FhevmHandle_fhevmType = /* @__PURE__ */ new WeakMap(), _FhevmHandle_fheType = /* @__PURE__ */ new WeakMap(), _FhevmHandle_version = /* @__PURE__ */ new WeakMap(), _FhevmHandle_computed = /* @__PURE__ */ new WeakMap(), _FhevmHandle_index = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/interfaces/KMSVerifier.itf.js
var KMSVerifierPartialInterface = new ethers_exports.Interface([
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [],
    name: "DeserializingDecryptionProofFail",
    type: "error"
  },
  {
    inputs: [],
    name: "ECDSAInvalidSignature",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "length",
        type: "uint256"
      }
    ],
    name: "ECDSAInvalidSignatureLength",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "ECDSAInvalidSignatureS",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  {
    inputs: [],
    name: "ERC1967NonPayable",
    type: "error"
  },
  {
    inputs: [],
    name: "EmptyDecryptionProof",
    type: "error"
  },
  {
    inputs: [],
    name: "FailedCall",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidInitialization",
    type: "error"
  },
  {
    inputs: [],
    name: "KMSAlreadySigner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "invalidSigner",
        type: "address"
      }
    ],
    name: "KMSInvalidSigner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "numSignatures",
        type: "uint256"
      }
    ],
    name: "KMSSignatureThresholdNotReached",
    type: "error"
  },
  {
    inputs: [],
    name: "KMSSignerNull",
    type: "error"
  },
  {
    inputs: [],
    name: "KMSZeroSignature",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "NotHostOwner",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializing",
    type: "error"
  },
  {
    inputs: [],
    name: "NotInitializingFromEmptyProxy",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [],
    name: "SignersSetIsEmpty",
    type: "error"
  },
  {
    inputs: [],
    name: "ThresholdIsAboveNumberOfSigners",
    type: "error"
  },
  {
    inputs: [],
    name: "ThresholdIsNull",
    type: "error"
  },
  {
    inputs: [],
    name: "UUPSUnauthorizedCallContext",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "slot",
        type: "bytes32"
      }
    ],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address[]",
        name: "newKmsSignersSet",
        type: "address[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newThreshold",
        type: "uint256"
      }
    ],
    name: "NewContextSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    inputs: [],
    name: "DECRYPTION_RESULT_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "EIP712_PUBLIC_DECRYPT_TYPE",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "newSignersSet",
        type: "address[]"
      },
      {
        internalType: "uint256",
        name: "newThreshold",
        type: "uint256"
      }
    ],
    name: "defineNewContext",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getKmsSigners",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getThreshold",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVersion",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "verifyingContractSource",
        type: "address"
      },
      {
        internalType: "uint64",
        name: "chainIDSource",
        type: "uint64"
      },
      {
        internalType: "address[]",
        name: "initialSigners",
        type: "address[]"
      },
      {
        internalType: "uint256",
        name: "initialThreshold",
        type: "uint256"
      }
    ],
    name: "initializeFromEmptyProxy",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "isSigner",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "reinitializeV3",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "threshold",
        type: "uint256"
      }
    ],
    name: "setThreshold",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32[]",
        name: "handlesList",
        type: "bytes32[]"
      },
      {
        internalType: "bytes",
        name: "decryptedResult",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "decryptionProof",
        type: "bytes"
      }
    ],
    name: "verifyDecryptionEIP712KMSSignatures",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
]);

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/KMSVerifier.js
var __classPrivateFieldSet7 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet7 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _KMSVerifier_kmsVerifierContract;
var _KMSVerifier_kmsVerifierContractAddress;
var _KMSVerifier_signersAddresses;
var _KMSVerifier_threshold;
var _KMSVerifier_eip712Domain;
var KMSVerifier = class _KMSVerifier extends FhevmCoprocessorContractWrapper {
  constructor() {
    super("KMSVerifier");
    _KMSVerifier_kmsVerifierContract.set(this, void 0);
    _KMSVerifier_kmsVerifierContractAddress.set(this, void 0);
    _KMSVerifier_signersAddresses.set(this, void 0);
    _KMSVerifier_threshold.set(this, void 0);
    _KMSVerifier_eip712Domain.set(this, void 0);
  }
  static async create(runner, kmsVerifierContractAddress, abi, properties) {
    assertIsAddress(kmsVerifierContractAddress, "kmsVerifierContractAddress");
    if (properties !== void 0) {
      throw new FhevmError("Not yet implemented");
    }
    const kmsVerifier = new _KMSVerifier();
    __classPrivateFieldSet7(kmsVerifier, _KMSVerifier_kmsVerifierContractAddress, kmsVerifierContractAddress, "f");
    __classPrivateFieldSet7(kmsVerifier, _KMSVerifier_kmsVerifierContract, new ethers_exports.Contract(kmsVerifierContractAddress, abi ?? KMSVerifierPartialInterface, runner), "f");
    await kmsVerifier._initialize();
    return kmsVerifier;
  }
  get readonlyContract() {
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_kmsVerifierContract, "f") !== void 0, `KMSVerifier wrapper is not initialized`);
    return __classPrivateFieldGet7(this, _KMSVerifier_kmsVerifierContract, "f");
  }
  get interface() {
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_kmsVerifierContract, "f") !== void 0, `KMSVerifier wrapper is not yet initialized`);
    return __classPrivateFieldGet7(this, _KMSVerifier_kmsVerifierContract, "f").interface;
  }
  async _initialize() {
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_kmsVerifierContract, "f") !== void 0, `KMSVerifier wrapper is not initialized`);
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_signersAddresses, "f") === void 0, `KMSVerifier wrapper already initialized`);
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_threshold, "f") === void 0, `KMSVerifier wrapper already initialized`);
    const signers = await __classPrivateFieldGet7(this, _KMSVerifier_kmsVerifierContract, "f").getKmsSigners();
    assertIsAddressArray(signers);
    __classPrivateFieldSet7(this, _KMSVerifier_signersAddresses, signers, "f");
    const threshold = await __classPrivateFieldGet7(this, _KMSVerifier_kmsVerifierContract, "f").getThreshold();
    assertIsBigUint8(threshold);
    __classPrivateFieldSet7(this, _KMSVerifier_threshold, Number(threshold), "f");
    if (__classPrivateFieldGet7(this, _KMSVerifier_eip712Domain, "f") === void 0) {
      const eip712Domain = await __classPrivateFieldGet7(this, _KMSVerifier_kmsVerifierContract, "f").eip712Domain();
      assertFhevm(eip712Domain.length === 7);
      assertIsString(eip712Domain[0], "eip712Domain[0]");
      assertIsString(eip712Domain[1], "eip712Domain[1]");
      assertIsString(eip712Domain[2], "eip712Domain[2]");
      assertIsBigUint256(eip712Domain[3], "eip712Domain[3]");
      assertIsAddress(eip712Domain[4], "eip712Domain[4]");
      assertIsBytes32String(eip712Domain[5], "eip712Domain[5]");
      __classPrivateFieldSet7(this, _KMSVerifier_eip712Domain, {
        fields: Number(BigInt(eip712Domain[0])),
        name: eip712Domain[1],
        version: eip712Domain[2],
        chainId: eip712Domain[3],
        verifyingContract: eip712Domain[4],
        salt: eip712Domain[5]
        // last field is ignored
      }, "f");
    }
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_eip712Domain, "f").fields === Number(15));
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_eip712Domain, "f").salt === ethers_exports.ZeroHash);
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_eip712Domain, "f").name === constants_default.PUBLIC_DECRYPT_EIP712.domain.name);
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_eip712Domain, "f").version === constants_default.PUBLIC_DECRYPT_EIP712.domain.version);
  }
  get address() {
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_kmsVerifierContractAddress, "f") !== void 0, `KMSVerifier wrapper not initialized`);
    return __classPrivateFieldGet7(this, _KMSVerifier_kmsVerifierContractAddress, "f");
  }
  // The KMSVerifier is always using the gatewayChainId in its eip712 domain
  get gatewayChainId() {
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_eip712Domain, "f") !== void 0, `KMSVerifier wrapper not initialized`);
    return __classPrivateFieldGet7(this, _KMSVerifier_eip712Domain, "f").chainId;
  }
  // The KMSVerifier is always using the address of the "Decryption.sol" contract deployed
  // on the gateway chainId in its eip712 domain
  get gatewayDecryptionAddress() {
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_eip712Domain, "f") !== void 0, `KMSVerifier wrapper not initialized`);
    return __classPrivateFieldGet7(this, _KMSVerifier_eip712Domain, "f").verifyingContract;
  }
  get eip712Domain() {
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_eip712Domain, "f") !== void 0, `KMSVerifier wrapper not initialized`);
    return __classPrivateFieldGet7(this, _KMSVerifier_eip712Domain, "f");
  }
  getKmsSignersAddresses() {
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_signersAddresses, "f") !== void 0, `KMSVerifier wrapper not initialized`);
    return __classPrivateFieldGet7(this, _KMSVerifier_signersAddresses, "f");
  }
  async assertMatchKmsSigners(signers) {
    const addresses = this.getKmsSignersAddresses();
    assertIsArray(signers, "signers");
    assertFhevm(signers.length === addresses.length, "signers.length === addresses.length");
    for (let i = 0; i < addresses.length; ++i) {
      const s = await signers[i].getAddress();
      assertFhevm(addresses[i] === s, `addresses[${i}] === await signers[${i}].getAddress()`);
    }
  }
  getThreshold() {
    assertFhevm(__classPrivateFieldGet7(this, _KMSVerifier_threshold, "f") !== void 0, `KMSVerifier wrapper not initialized`);
    return __classPrivateFieldGet7(this, _KMSVerifier_threshold, "f");
  }
  createPublicDecryptVerificationEIP712(handlesBytes32List, decryptedResult, extraData) {
    const domain = this.eip712Domain;
    const eip712 = {
      domain: {
        chainId: domain.chainId,
        name: domain.name,
        version: domain.version,
        verifyingContract: domain.verifyingContract
      },
      types: constants_default.PUBLIC_DECRYPT_EIP712.types,
      message: {
        ctHandles: handlesBytes32List,
        decryptedResult,
        extraData
      }
    };
    return eip712;
  }
};
_KMSVerifier_kmsVerifierContract = /* @__PURE__ */ new WeakMap(), _KMSVerifier_kmsVerifierContractAddress = /* @__PURE__ */ new WeakMap(), _KMSVerifier_signersAddresses = /* @__PURE__ */ new WeakMap(), _KMSVerifier_threshold = /* @__PURE__ */ new WeakMap(), _KMSVerifier_eip712Domain = /* @__PURE__ */ new WeakMap();
async function computeDecryptionSignatures(handlesBytes32Hex, clearTextValues, extraData, abiCoder, kmsVerifier, kmsSigners) {
  const fhevmHandles = handlesBytes32Hex.map((handleBytes32Hex) => FhevmHandle.fromBytes32Hex(handleBytes32Hex));
  assertFhevm(handlesBytes32Hex.length === clearTextValues.length);
  const abiTypes = [];
  const abiValues = [];
  for (let i = 0; i < handlesBytes32Hex.length; ++i) {
    let clearTextValue = clearTextValues[i];
    if (typeof clearTextValue === "boolean") {
      clearTextValue = clearTextValue ? "0x01" : "0x00";
    }
    const clearTextValueBigInt = BigInt(clearTextValue);
    const fhevmTypeInfo = fhevmHandles[i].fhevmTypeInfo;
    abiTypes.push(fhevmTypeInfo.solidityTypeName);
    switch (fhevmTypeInfo.type) {
      case FhevmType.eaddress: {
        abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(40, "0")}`);
        break;
      }
      case FhevmType.ebool: {
        abiValues.push(clearTextValueBigInt);
        break;
      }
      case FhevmType.euint4:
      case FhevmType.euint8:
      case FhevmType.euint16:
      case FhevmType.euint32:
      case FhevmType.euint64:
      case FhevmType.euint128:
      case FhevmType.euint256: {
        abiValues.push(clearTextValueBigInt);
        break;
      }
      case FhevmType.ebytes64: {
        abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(128, "0")}`);
        break;
      }
      case FhevmType.ebytes128: {
        abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(256, "0")}`);
        break;
      }
      case FhevmType.ebytes256: {
        abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(512, "0")}`);
        break;
      }
      default: {
        throw new FhevmError(`Unsupported Fhevm primitive type id: ${fhevmTypeInfo.type}, name: ${fhevmTypeInfo.name}, solidity: ${fhevmTypeInfo.solidityTypeName}`);
      }
    }
  }
  const encodedData = abiCoder.encode(["uint256", ...abiTypes, "bytes[]"], [31, ...abiValues, []]);
  const decryptedResult = "0x" + encodedData.slice(66).slice(0, -64);
  assertFhevm(decryptedResult === "0x" + encodedData.slice(66, -64), "decryptedResult === '0x' + encodedData.slice(66, -64)");
  const eip712 = kmsVerifier.createPublicDecryptVerificationEIP712(handlesBytes32Hex, decryptedResult, extraData);
  const decryptResultsEIP712signatures = await multiSignEIP712(kmsSigners, eip712.domain, eip712.types, eip712.message);
  return { signatures: decryptResultsEIP712signatures, types: abiTypes, values: abiValues, decryptedResult };
}
async function computeDecryptionCallbackSignaturesAndCalldata(handlesBytes32Hex, clearTextValuesString, extraData, requestID, callbackSelectorBytes4Hex, abiCoder, kmsVerifier, kmsSigners) {
  assertFhevm(extraData === ethers_exports.solidityPacked(["uint8"], [0]), "extraData must be 0x00");
  const { signatures, types, values } = await computeDecryptionSignatures(handlesBytes32Hex, clearTextValuesString, extraData, abiCoder, kmsVerifier, kmsSigners);
  const packedNumSigners = ethers_exports.solidityPacked(["uint8"], [signatures.length]);
  const packedSignatures = ethers_exports.solidityPacked(Array(signatures.length).fill("bytes"), signatures);
  const decryptionProof = ethers_exports.concat([packedNumSigners, packedSignatures, extraData]);
  const encodedCleartexts = abiCoder.encode([...types], [...values]);
  const calldata = callbackSelectorBytes4Hex + abiCoder.encode(["uint256", "bytes", "bytes"], [requestID, encodedCleartexts, decryptionProof]).slice(2);
  return { calldata };
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/ZamaFheDecryptionOracle.js
var __classPrivateFieldSet8 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet8 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContract;
var _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContractAddress;
var ZamaFheDecryptionOracle = class _ZamaFheDecryptionOracle extends FhevmDecryptionOracleContractWrapper {
  constructor() {
    super("DecryptionOracle");
    _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContract.set(this, void 0);
    _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContractAddress.set(this, void 0);
  }
  static async create(runner, zamaFheDecryptionOracleContractAddress, abi) {
    assertIsAddress(zamaFheDecryptionOracleContractAddress, "zamaFheDecryptionOracleContractAddress");
    const decryptionOracle = new _ZamaFheDecryptionOracle();
    __classPrivateFieldSet8(decryptionOracle, _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContractAddress, zamaFheDecryptionOracleContractAddress, "f");
    __classPrivateFieldSet8(decryptionOracle, _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContract, new ethers_exports.Contract(zamaFheDecryptionOracleContractAddress, abi ?? KMSVerifierPartialInterface, runner), "f");
    await decryptionOracle._initialize();
    return decryptionOracle;
  }
  get readonlyContract() {
    assertFhevm(__classPrivateFieldGet8(this, _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContract, "f") !== void 0, `ZamaFheDecryptionOracle wrapper is not yet initialized`);
    return __classPrivateFieldGet8(this, _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContract, "f");
  }
  get interface() {
    assertFhevm(__classPrivateFieldGet8(this, _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContract, "f") !== void 0, `ZamaFheDecryptionOracle wrapper is not yet initialized`);
    return __classPrivateFieldGet8(this, _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContract, "f").interface;
  }
  async _initialize() {
    assertFhevm(__classPrivateFieldGet8(this, _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContract, "f") !== void 0, `ZamaFheDecryptionOracle wrapper is not initialized`);
  }
  get address() {
    assertFhevm(__classPrivateFieldGet8(this, _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContractAddress, "f") !== void 0, `ZamaFheDecryptionOracle wrapper not initialized`);
    return __classPrivateFieldGet8(this, _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContractAddress, "f");
  }
};
_ZamaFheDecryptionOracle_zamaFheDecryptionOracleContract = /* @__PURE__ */ new WeakMap(), _ZamaFheDecryptionOracle_zamaFheDecryptionOracleContractAddress = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/contracts/FhevmContractsRepository.js
var __classPrivateFieldSet9 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet9 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FhevmContractsRepository_acl;
var _FhevmContractsRepository_fhevmExecutor;
var _FhevmContractsRepository_inputVerifier;
var _FhevmContractsRepository_kmsVerifier;
var _FhevmContractsRepository_hcuLimit;
var _FhevmContractsRepository_zamaFheDecryptionOracle;
var _FhevmContractsRepository_addressToContract;
var FhevmContractsRepository = class _FhevmContractsRepository {
  constructor() {
    _FhevmContractsRepository_acl.set(this, void 0);
    _FhevmContractsRepository_fhevmExecutor.set(this, void 0);
    _FhevmContractsRepository_inputVerifier.set(this, void 0);
    _FhevmContractsRepository_kmsVerifier.set(this, void 0);
    _FhevmContractsRepository_hcuLimit.set(this, void 0);
    _FhevmContractsRepository_zamaFheDecryptionOracle.set(this, void 0);
    _FhevmContractsRepository_addressToContract.set(this, void 0);
  }
  static async create(ethersReadonlyProvider, config) {
    if (!ethers_exports.isAddress(config.aclContractAddress)) {
      throw new FhevmError(`Invalid ACL contract address ${config.aclContractAddress}`);
    }
    if (!ethers_exports.isAddress(config.kmsContractAddress)) {
      throw new FhevmError(`Invalid KMSVerifier contract address ${config.kmsContractAddress}`);
    }
    if (config.zamaFheDecryptionOracleAddress !== void 0) {
      if (!ethers_exports.isAddress(config.zamaFheDecryptionOracleAddress)) {
        throw new FhevmError(`Invalid DecryptionOracle contract address ${config.zamaFheDecryptionOracleAddress}`);
      }
    }
    const repo = new _FhevmContractsRepository();
    __classPrivateFieldSet9(repo, _FhevmContractsRepository_acl, await ACL.create(ethersReadonlyProvider, config.aclContractAddress, config.aclAbi, config.aclProperties), "f");
    __classPrivateFieldSet9(repo, _FhevmContractsRepository_fhevmExecutor, await FHEVMExecutor.create(ethersReadonlyProvider, __classPrivateFieldGet9(repo, _FhevmContractsRepository_acl, "f").fhevmExecutorAddress, config.fhevmExecutorAbi, config.fhevmExecutorProperties), "f");
    __classPrivateFieldSet9(repo, _FhevmContractsRepository_inputVerifier, await InputVerifier.create(ethersReadonlyProvider, __classPrivateFieldGet9(repo, _FhevmContractsRepository_fhevmExecutor, "f").inputVerifierAddress, config.inputVerifierAbi), "f");
    __classPrivateFieldSet9(repo, _FhevmContractsRepository_kmsVerifier, await KMSVerifier.create(ethersReadonlyProvider, config.kmsContractAddress, config.kmsVerifierAbi), "f");
    __classPrivateFieldSet9(repo, _FhevmContractsRepository_hcuLimit, await HCULimit.create(ethersReadonlyProvider, __classPrivateFieldGet9(repo, _FhevmContractsRepository_fhevmExecutor, "f").hcuLimitAddress, config.hcuLimitAbi), "f");
    if (config.zamaFheDecryptionOracleAddress !== void 0) {
      __classPrivateFieldSet9(repo, _FhevmContractsRepository_zamaFheDecryptionOracle, await ZamaFheDecryptionOracle.create(ethersReadonlyProvider, config.zamaFheDecryptionOracleAddress, config.zamaFheDecryptionOracleAbi), "f");
    }
    if (__classPrivateFieldGet9(repo, _FhevmContractsRepository_inputVerifier, "f").gatewayChainId !== __classPrivateFieldGet9(repo, _FhevmContractsRepository_kmsVerifier, "f").gatewayChainId) {
      throw new FhevmError(`gateway chainId mismatch. InputVerifier.gatewayChainId=${__classPrivateFieldGet9(repo, _FhevmContractsRepository_inputVerifier, "f").gatewayChainId} differs from KMSVerifier.gatewayChainId=${__classPrivateFieldGet9(repo, _FhevmContractsRepository_kmsVerifier, "f").gatewayChainId}`);
    }
    __classPrivateFieldSet9(repo, _FhevmContractsRepository_addressToContract, {}, "f");
    __classPrivateFieldGet9(repo, _FhevmContractsRepository_addressToContract, "f")[__classPrivateFieldGet9(repo, _FhevmContractsRepository_acl, "f").address.toLowerCase()] = __classPrivateFieldGet9(repo, _FhevmContractsRepository_acl, "f");
    __classPrivateFieldGet9(repo, _FhevmContractsRepository_addressToContract, "f")[__classPrivateFieldGet9(repo, _FhevmContractsRepository_fhevmExecutor, "f").address.toLowerCase()] = __classPrivateFieldGet9(repo, _FhevmContractsRepository_fhevmExecutor, "f");
    if (__classPrivateFieldGet9(repo, _FhevmContractsRepository_zamaFheDecryptionOracle, "f")) {
      __classPrivateFieldGet9(repo, _FhevmContractsRepository_addressToContract, "f")[__classPrivateFieldGet9(repo, _FhevmContractsRepository_zamaFheDecryptionOracle, "f").address.toLowerCase()] = __classPrivateFieldGet9(repo, _FhevmContractsRepository_zamaFheDecryptionOracle, "f");
    }
    __classPrivateFieldGet9(repo, _FhevmContractsRepository_addressToContract, "f")[__classPrivateFieldGet9(repo, _FhevmContractsRepository_inputVerifier, "f").address.toLowerCase()] = __classPrivateFieldGet9(repo, _FhevmContractsRepository_inputVerifier, "f");
    __classPrivateFieldGet9(repo, _FhevmContractsRepository_addressToContract, "f")[__classPrivateFieldGet9(repo, _FhevmContractsRepository_kmsVerifier, "f").address.toLowerCase()] = __classPrivateFieldGet9(repo, _FhevmContractsRepository_kmsVerifier, "f");
    __classPrivateFieldGet9(repo, _FhevmContractsRepository_addressToContract, "f")[__classPrivateFieldGet9(repo, _FhevmContractsRepository_hcuLimit, "f").address.toLowerCase()] = __classPrivateFieldGet9(repo, _FhevmContractsRepository_hcuLimit, "f");
    Object.freeze(__classPrivateFieldGet9(repo, _FhevmContractsRepository_addressToContract, "f"));
    return repo;
  }
  addressToContractMap() {
    assertFhevm(__classPrivateFieldGet9(this, _FhevmContractsRepository_addressToContract, "f") !== void 0, "FhevmContractsRepository is not initialized");
    return __classPrivateFieldGet9(this, _FhevmContractsRepository_addressToContract, "f");
  }
  getContractFromAddress(address) {
    const a = address.toLowerCase();
    if (a === this.acl.address.toLowerCase()) {
      return this.acl;
    }
    if (a === this.fhevmExecutor.address.toLowerCase()) {
      return this.fhevmExecutor;
    }
    if (a === this.inputVerifier.address.toLowerCase()) {
      return this.inputVerifier;
    }
    if (a === this.kmsVerifier.address.toLowerCase()) {
      return this.kmsVerifier;
    }
    if (a === this.hcuLimit.address.toLowerCase()) {
      return this.hcuLimit;
    }
    if (this.zamaFheDecryptionOracle) {
      if (a === this.zamaFheDecryptionOracle.address.toLowerCase()) {
        return this.zamaFheDecryptionOracle;
      }
    }
    return void 0;
  }
  getContractFromName(name) {
    switch (name) {
      case "ACL":
        return this.acl;
      case "FHEVMExecutor":
        return this.fhevmExecutor;
      case "InputVerifier":
        return this.inputVerifier;
      case "KMSVerifier":
        return this.kmsVerifier;
      case "HCULimit":
        return this.hcuLimit;
      case "DecryptionOracle":
        return this.zamaFheDecryptionOracle;
      default: {
        throw new FhevmError(`Unsupported contract ${name}`);
      }
    }
  }
  getCoprocessorContractFromName(name) {
    switch (name) {
      case "ACL":
        return this.acl;
      case "FHEVMExecutor":
        return this.fhevmExecutor;
      case "InputVerifier":
        return this.inputVerifier;
      case "KMSVerifier":
        return this.kmsVerifier;
      case "HCULimit":
        return this.hcuLimit;
      default: {
        throw new FhevmError(`Unsupported coprocessor contract ${name}`);
      }
    }
  }
  getDecryptionOracleContractFromName(name) {
    switch (name) {
      case "DecryptionOracle":
        return this.zamaFheDecryptionOracle;
      default: {
        throw new FhevmError(`Unsupported decryption oracle contract ${name}`);
      }
    }
  }
  getCoprocessorInterfaceFromName(name) {
    return this.getCoprocessorContractFromName(name).interface;
  }
  getDecryptionOracleInterfaceFromName(name) {
    const c = this.getDecryptionOracleContractFromName(name);
    if (c === void 0) {
      return void 0;
    }
    return c.interface;
  }
  get zamaFheDecryptionOracle() {
    return __classPrivateFieldGet9(this, _FhevmContractsRepository_zamaFheDecryptionOracle, "f");
  }
  get acl() {
    assertFhevm(__classPrivateFieldGet9(this, _FhevmContractsRepository_acl, "f") !== void 0, "FhevmContractsRepository is not initialized");
    return __classPrivateFieldGet9(this, _FhevmContractsRepository_acl, "f");
  }
  get fhevmExecutor() {
    assertFhevm(__classPrivateFieldGet9(this, _FhevmContractsRepository_fhevmExecutor, "f") !== void 0, "FhevmContractsRepository is not initialized");
    return __classPrivateFieldGet9(this, _FhevmContractsRepository_fhevmExecutor, "f");
  }
  get inputVerifier() {
    assertFhevm(__classPrivateFieldGet9(this, _FhevmContractsRepository_inputVerifier, "f") !== void 0, "FhevmContractsRepository is not initialized");
    return __classPrivateFieldGet9(this, _FhevmContractsRepository_inputVerifier, "f");
  }
  get kmsVerifier() {
    assertFhevm(__classPrivateFieldGet9(this, _FhevmContractsRepository_kmsVerifier, "f") !== void 0, "FhevmContractsRepository is not initialized");
    return __classPrivateFieldGet9(this, _FhevmContractsRepository_kmsVerifier, "f");
  }
  get hcuLimit() {
    assertFhevm(__classPrivateFieldGet9(this, _FhevmContractsRepository_hcuLimit, "f") !== void 0, "FhevmContractsRepository is not initialized");
    return __classPrivateFieldGet9(this, _FhevmContractsRepository_hcuLimit, "f");
  }
  getFhevmInstanceConfig(params) {
    var _a, _b;
    assertFhevm(__classPrivateFieldGet9(this, _FhevmContractsRepository_acl, "f") !== void 0, "FhevmContractsRepository is not initialized");
    assertFhevm(__classPrivateFieldGet9(this, _FhevmContractsRepository_fhevmExecutor, "f") !== void 0, "FhevmContractsRepository is not initialized");
    assertFhevm(__classPrivateFieldGet9(this, _FhevmContractsRepository_kmsVerifier, "f") !== void 0, "FhevmContractsRepository is not initialized");
    assertFhevm(__classPrivateFieldGet9(this, _FhevmContractsRepository_inputVerifier, "f") !== void 0, "FhevmContractsRepository is not initialized");
    const decryptionOracleAddress = (_a = __classPrivateFieldGet9(this, _FhevmContractsRepository_zamaFheDecryptionOracle, "f")) == null ? void 0 : _a.address;
    return {
      aclContractAddress: __classPrivateFieldGet9(this, _FhevmContractsRepository_acl, "f").address,
      fhevmExecutorContractAddress: (_b = __classPrivateFieldGet9(this, _FhevmContractsRepository_fhevmExecutor, "f")) == null ? void 0 : _b.address,
      chainId: params.chainId,
      gatewayChainId: Number(__classPrivateFieldGet9(this, _FhevmContractsRepository_kmsVerifier, "f").gatewayChainId),
      inputVerifierContractAddress: __classPrivateFieldGet9(this, _FhevmContractsRepository_inputVerifier, "f").address,
      kmsContractAddress: __classPrivateFieldGet9(this, _FhevmContractsRepository_kmsVerifier, "f").address,
      verifyingContractAddressDecryption: __classPrivateFieldGet9(this, _FhevmContractsRepository_kmsVerifier, "f").gatewayDecryptionAddress,
      verifyingContractAddressInputVerification: __classPrivateFieldGet9(this, _FhevmContractsRepository_inputVerifier, "f").gatewayInputVerificationAddress,
      relayerUrl: params.relayerUrl,
      ...decryptionOracleAddress && { decryptionOracleAddress }
    };
  }
};
_FhevmContractsRepository_acl = /* @__PURE__ */ new WeakMap(), _FhevmContractsRepository_fhevmExecutor = /* @__PURE__ */ new WeakMap(), _FhevmContractsRepository_inputVerifier = /* @__PURE__ */ new WeakMap(), _FhevmContractsRepository_kmsVerifier = /* @__PURE__ */ new WeakMap(), _FhevmContractsRepository_hcuLimit = /* @__PURE__ */ new WeakMap(), _FhevmContractsRepository_zamaFheDecryptionOracle = /* @__PURE__ */ new WeakMap(), _FhevmContractsRepository_addressToContract = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/ethers/event.js
var __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet10 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BlockLogCursor_blockNumber;
var _BlockLogCursor_blockLogIndex;
function assertEventArgIsBigUint8(value, eventName, argIndex) {
  assertIsBigUint8(value, `${eventName} event arg #${argIndex}`);
}
function assertEventArgIsBigUint256(value, eventName, argIndex) {
  assertIsBigUint256(value, `${eventName} event arg #${argIndex}`);
}
function assertEventArgIsBytes1String(value, eventName, argIndex) {
  _assertEventArgIsBytesString(value, eventName, argIndex, 1);
}
function assertEventArgIsBytes4String(value, eventName, argIndex) {
  _assertEventArgIsBytesString(value, eventName, argIndex, 4);
}
function assertEventArgIsBytes16String(value, eventName, argIndex) {
  _assertEventArgIsBytesString(value, eventName, argIndex, 16);
}
function assertEventArgIsBytes32String(value, eventName, argIndex) {
  _assertEventArgIsBytesString(value, eventName, argIndex, 32);
}
function assertEventArgIsBytesString(value, eventName, argIndex) {
  _assertEventArgIsBytesString(value, eventName, argIndex);
}
function _assertEventArgIsBytesString(value, eventName, argIndex, width) {
  assertIsBytesString(value, width, `${eventName} event arg #${argIndex}`);
}
function assertEventArgIsAddress(value, eventName, argIndex) {
  assertIsAddress(value, `${eventName} event arg #${argIndex}`);
}
var BlockLogCursor = class _BlockLogCursor {
  constructor(fromBlockNumber) {
    _BlockLogCursor_blockNumber.set(this, -1);
    _BlockLogCursor_blockLogIndex.set(this, -1);
    __classPrivateFieldSet10(this, _BlockLogCursor_blockNumber, fromBlockNumber <= 0 ? -1 : fromBlockNumber - 1, "f");
  }
  static check(blockNumber, blockLogIndex) {
    if (blockNumber < 0 || blockLogIndex < 0) {
      throw new FhevmError(`Invalid event at blockNumber=${blockNumber}, logIndex=${blockLogIndex}.`);
    }
  }
  get isEmpty() {
    const empty = __classPrivateFieldGet10(this, _BlockLogCursor_blockNumber, "f") < 0;
    if (empty) {
      assertFhevm(__classPrivateFieldGet10(this, _BlockLogCursor_blockLogIndex, "f") < 0);
    } else {
      assertFhevm(__classPrivateFieldGet10(this, _BlockLogCursor_blockLogIndex, "f") >= 0);
    }
    return empty;
  }
  get nextBlockNumber() {
    if (__classPrivateFieldGet10(this, _BlockLogCursor_blockNumber, "f") < 0) {
      return 0;
    }
    return __classPrivateFieldGet10(this, _BlockLogCursor_blockNumber, "f") + 1;
  }
  get blockNumber() {
    return __classPrivateFieldGet10(this, _BlockLogCursor_blockNumber, "f");
  }
  get blockLogIndex() {
    return __classPrivateFieldGet10(this, _BlockLogCursor_blockLogIndex, "f");
  }
  /*
    Returns `true` if this > {blockNumber, blockLogIndex}
  */
  gt(blockNumber, blockLogIndex) {
    _BlockLogCursor.check(blockNumber, blockLogIndex);
    if (__classPrivateFieldGet10(this, _BlockLogCursor_blockNumber, "f") === blockNumber) {
      return __classPrivateFieldGet10(this, _BlockLogCursor_blockLogIndex, "f") > blockLogIndex;
    }
    return __classPrivateFieldGet10(this, _BlockLogCursor_blockNumber, "f") > blockNumber;
  }
  /*
    Returns `true` if this == {blockNumber, blockLogIndex}
  */
  eq(blockNumber, blockLogIndex) {
    _BlockLogCursor.check(blockNumber, blockLogIndex);
    return __classPrivateFieldGet10(this, _BlockLogCursor_blockNumber, "f") === blockNumber && __classPrivateFieldGet10(this, _BlockLogCursor_blockLogIndex, "f") === blockLogIndex;
  }
  /*
    Returns `true` if this >= {blockNumber, blockLogIndex}
  */
  ge(blockNumber, blockLogIndex) {
    return this.gt(blockNumber, blockLogIndex) || this.eq(blockNumber, blockLogIndex);
  }
  /*
    throws an error if this >= {blockNumber, blockLogIndex}
  */
  updateForward(blockNumber, blockLogIndex) {
    _BlockLogCursor.check(blockNumber, blockLogIndex);
    if (this.ge(blockNumber, blockLogIndex)) {
      throw new FhevmError(`Parse event at blockNumber=${blockNumber}, logIndex=${blockLogIndex} in backward order. Current blockNumber=${__classPrivateFieldGet10(this, _BlockLogCursor_blockNumber, "f")}, logIndex=${__classPrivateFieldGet10(this, _BlockLogCursor_blockLogIndex, "f")}`);
    }
    __classPrivateFieldSet10(this, _BlockLogCursor_blockNumber, blockNumber, "f");
    __classPrivateFieldSet10(this, _BlockLogCursor_blockLogIndex, blockLogIndex, "f");
  }
  /*
    throws an error if this == {blockNumber, blockLogIndex}
  */
  updateForwardOrBackward(blockNumber, blockLogIndex) {
    _BlockLogCursor.check(blockNumber, blockLogIndex);
    if (this.eq(blockNumber, blockLogIndex)) {
      throw new FhevmError(`Expecting event at a different position (blockNumber=${blockNumber}, logIndex=${blockLogIndex}).`);
    }
    __classPrivateFieldSet10(this, _BlockLogCursor_blockNumber, blockNumber, "f");
    __classPrivateFieldSet10(this, _BlockLogCursor_blockLogIndex, blockLogIndex, "f");
  }
  update(blockNumber, blockLogIndex) {
    _BlockLogCursor.check(blockNumber, blockLogIndex);
    __classPrivateFieldSet10(this, _BlockLogCursor_blockNumber, blockNumber, "f");
    __classPrivateFieldSet10(this, _BlockLogCursor_blockLogIndex, blockLogIndex, "f");
  }
};
_BlockLogCursor_blockNumber = /* @__PURE__ */ new WeakMap(), _BlockLogCursor_blockLogIndex = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/db/utils.js
function checkInsertArgs(handleBytes32Hex, clearText, metadata) {
  assertIsBytes32String(handleBytes32Hex);
  assertIsBytes32String(metadata.transactionHash);
  assertIsUintNumber(metadata.blockNumber);
  assertIsUintNumber(metadata.index);
  if (typeof clearText !== "bigint" && typeof clearText !== "string") {
    throw new FhevmError(`Invalid clearText argument, expecting bigint or string, got ${typeof clearText} instead`);
  }
  if (typeof clearText === "string") {
    assertIsHexString(clearText, "clearText argument");
  }
}
function checkQueryArgs(handleBytes32Hex) {
  assertIsBytes32String(handleBytes32Hex);
}
function fhevmDBEntryToString(entry) {
  return `${entry.metadata.blockNumber}:${entry.metadata.index}:${entry.metadata.transactionHash}:${entry.clearTextHex}`;
}
function stringToFhevmDBEntry(str) {
  const elements = str.split(":");
  return {
    clearTextHex: elements[3],
    metadata: {
      blockNumber: Number.parseInt(elements[0]),
      index: Number.parseInt(elements[1]),
      transactionHash: elements[2]
    }
  };
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/db/FhevmDBMap.js
var __classPrivateFieldGet11 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet11 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _FhevmDBMap_handleBytes32HexToClearText;
var _FhevmDBMap_counter;
var _FhevmDBMap_randomCounter;
var _FhevmDBMap_fromBlockNumber;
var __STRICT__ = false;
var FhevmDBMap = class {
  constructor() {
    _FhevmDBMap_handleBytes32HexToClearText.set(this, void 0);
    _FhevmDBMap_counter.set(this, void 0);
    _FhevmDBMap_randomCounter.set(this, 0);
    _FhevmDBMap_fromBlockNumber.set(this, -1);
  }
  incRand() {
    var _a;
    __classPrivateFieldSet11(this, _FhevmDBMap_randomCounter, (_a = __classPrivateFieldGet11(this, _FhevmDBMap_randomCounter, "f"), _a++, _a), "f");
  }
  get randomCounter() {
    return __classPrivateFieldGet11(this, _FhevmDBMap_randomCounter, "f");
  }
  get fromBlockNumber() {
    return __classPrivateFieldGet11(this, _FhevmDBMap_fromBlockNumber, "f");
  }
  get countHandles() {
    if (!__classPrivateFieldGet11(this, _FhevmDBMap_handleBytes32HexToClearText, "f")) {
      throw new FhevmError(`FhevmDB not yet initialized`);
    }
    return __classPrivateFieldGet11(this, _FhevmDBMap_handleBytes32HexToClearText, "f").size;
  }
  _get() {
    if (!__classPrivateFieldGet11(this, _FhevmDBMap_handleBytes32HexToClearText, "f")) {
      throw new FhevmError(`FhevmDB not yet initialized`);
    }
    return __classPrivateFieldGet11(this, _FhevmDBMap_handleBytes32HexToClearText, "f");
  }
  async init(fromBlockNumber) {
    if (__classPrivateFieldGet11(this, _FhevmDBMap_handleBytes32HexToClearText, "f")) {
      throw new FhevmError(`FhevmDB already initialized`);
    }
    __classPrivateFieldSet11(this, _FhevmDBMap_fromBlockNumber, fromBlockNumber, "f");
    __classPrivateFieldSet11(this, _FhevmDBMap_counter, new BlockLogCursor(fromBlockNumber), "f");
    __classPrivateFieldSet11(this, _FhevmDBMap_handleBytes32HexToClearText, /* @__PURE__ */ new Map(), "f");
    return true;
  }
  /**
   * Reset can be usefull to test deterministic handles like trivialEncrypt.
   */
  async reset() {
    this._get().clear();
  }
  async _insertHandleBytes32(handleBytes32Hex, clearTextBigIntOrHex, metadata, options) {
    if (!__classPrivateFieldGet11(this, _FhevmDBMap_counter, "f")) {
      throw new FhevmError(`FhevmDB not yet initialized`);
    }
    const map = this._get();
    if (__STRICT__) {
      if ((options == null ? void 0 : options.replace) !== true) {
        if (map.has(handleBytes32Hex)) {
          throw new FhevmError(`Handle ${handleBytes32Hex} already exists.`);
        }
      }
    }
    if (typeof clearTextBigIntOrHex !== "string") {
      clearTextBigIntOrHex = clearTextBigIntOrHex.toString();
    }
    const entryStr = fhevmDBEntryToString({ clearTextHex: clearTextBigIntOrHex, metadata });
    map.set(handleBytes32Hex, entryStr);
    if (metadata.transactionHash !== ethers_exports.ZeroHash) {
      if (__STRICT__) {
        __classPrivateFieldGet11(this, _FhevmDBMap_counter, "f").updateForward(metadata.blockNumber, metadata.index);
      } else {
        __classPrivateFieldGet11(this, _FhevmDBMap_counter, "f").update(metadata.blockNumber, metadata.index);
      }
    }
  }
  async _queryHandleBytes32(handleBytes32Hex) {
    const map = this._get();
    const entryStr = map.get(handleBytes32Hex);
    if (entryStr === void 0) {
      throw new FhevmError(`Handle ${handleBytes32Hex} does not exist.`);
    }
    return stringToFhevmDBEntry(entryStr);
  }
  async insertHandleBytes32(handleBytes32Hex, clearText, metadata, options) {
    checkInsertArgs(handleBytes32Hex, clearText, metadata);
    await this._insertHandleBytes32(handleBytes32Hex, clearText, metadata, options);
  }
  async queryHandleBytes32(handleBytes32Hex) {
    checkQueryArgs(handleBytes32Hex);
    return await this._queryHandleBytes32(handleBytes32Hex);
  }
  async tryInsertHandleBytes32(handleBytes32Hex, clearText, metadata, options) {
    checkInsertArgs(handleBytes32Hex, clearText, metadata);
    try {
      await this._insertHandleBytes32(handleBytes32Hex, clearText, metadata, options);
      return true;
    } catch {
      return false;
    }
  }
  async tryQueryHandleBytes32(handleBytes32Hex) {
    checkQueryArgs(handleBytes32Hex);
    try {
      return await this._queryHandleBytes32(handleBytes32Hex);
    } catch {
      return void 0;
    }
  }
};
_FhevmDBMap_handleBytes32HexToClearText = /* @__PURE__ */ new WeakMap(), _FhevmDBMap_counter = /* @__PURE__ */ new WeakMap(), _FhevmDBMap_randomCounter = /* @__PURE__ */ new WeakMap(), _FhevmDBMap_fromBlockNumber = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/FhevmHandleCoder.js
var __classPrivateFieldSet12 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet12 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FhevmHandleCoder_aclAddress;
var _FhevmHandleCoder_chainId;
var FhevmOperator;
(function(FhevmOperator2) {
  FhevmOperator2[FhevmOperator2["fheAdd"] = 0] = "fheAdd";
  FhevmOperator2[FhevmOperator2["fheSub"] = 1] = "fheSub";
  FhevmOperator2[FhevmOperator2["fheMul"] = 2] = "fheMul";
  FhevmOperator2[FhevmOperator2["fheDiv"] = 3] = "fheDiv";
  FhevmOperator2[FhevmOperator2["fheRem"] = 4] = "fheRem";
  FhevmOperator2[FhevmOperator2["fheBitAnd"] = 5] = "fheBitAnd";
  FhevmOperator2[FhevmOperator2["fheBitOr"] = 6] = "fheBitOr";
  FhevmOperator2[FhevmOperator2["fheBitXor"] = 7] = "fheBitXor";
  FhevmOperator2[FhevmOperator2["fheShl"] = 8] = "fheShl";
  FhevmOperator2[FhevmOperator2["fheShr"] = 9] = "fheShr";
  FhevmOperator2[FhevmOperator2["fheRotl"] = 10] = "fheRotl";
  FhevmOperator2[FhevmOperator2["fheRotr"] = 11] = "fheRotr";
  FhevmOperator2[FhevmOperator2["fheEq"] = 12] = "fheEq";
  FhevmOperator2[FhevmOperator2["fheNe"] = 13] = "fheNe";
  FhevmOperator2[FhevmOperator2["fheGe"] = 14] = "fheGe";
  FhevmOperator2[FhevmOperator2["fheGt"] = 15] = "fheGt";
  FhevmOperator2[FhevmOperator2["fheLe"] = 16] = "fheLe";
  FhevmOperator2[FhevmOperator2["fheLt"] = 17] = "fheLt";
  FhevmOperator2[FhevmOperator2["fheMin"] = 18] = "fheMin";
  FhevmOperator2[FhevmOperator2["fheMax"] = 19] = "fheMax";
  FhevmOperator2[FhevmOperator2["fheNeg"] = 20] = "fheNeg";
  FhevmOperator2[FhevmOperator2["fheNot"] = 21] = "fheNot";
  FhevmOperator2[FhevmOperator2["verifyCiphertext"] = 22] = "verifyCiphertext";
  FhevmOperator2[FhevmOperator2["cast"] = 23] = "cast";
  FhevmOperator2[FhevmOperator2["trivialEncrypt"] = 24] = "trivialEncrypt";
  FhevmOperator2[FhevmOperator2["fheIfThenElse"] = 25] = "fheIfThenElse";
  FhevmOperator2[FhevmOperator2["fheRand"] = 26] = "fheRand";
  FhevmOperator2[FhevmOperator2["fheRandBounded"] = 27] = "fheRandBounded";
})(FhevmOperator || (FhevmOperator = {}));
var FhevmHandleCoder = class {
  constructor(aclAddress, chainId) {
    _FhevmHandleCoder_aclAddress.set(this, void 0);
    _FhevmHandleCoder_chainId.set(this, void 0);
    if (!ethers_exports.isAddress(aclAddress)) {
      throw new FhevmError(`Invalid ACL address`);
    }
    if (typeof chainId !== "number") {
      throw new FhevmError(`Invalid chainId`);
    }
    __classPrivateFieldSet12(this, _FhevmHandleCoder_aclAddress, aclAddress, "f");
    __classPrivateFieldSet12(this, _FhevmHandleCoder_chainId, chainId, "f");
  }
  fheAdd(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createNumericalOpHandle(FhevmOperator.fheAdd, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheSub(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createNumericalOpHandle(FhevmOperator.fheSub, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheMul(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createNumericalOpHandle(FhevmOperator.fheMul, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheDiv(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createNumericalOpHandle(FhevmOperator.fheDiv, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheRem(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createNumericalOpHandle(FhevmOperator.fheRem, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheBitAnd(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createBitwiseOpHandle(FhevmOperator.fheBitAnd, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheBitOr(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createBitwiseOpHandle(FhevmOperator.fheBitOr, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheBitXor(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createBitwiseOpHandle(FhevmOperator.fheBitXor, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheShl(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createBitwiseOpHandle(FhevmOperator.fheShl, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheShr(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createBitwiseOpHandle(FhevmOperator.fheShr, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheRotl(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createBitwiseOpHandle(FhevmOperator.fheRotl, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheRotr(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createBitwiseOpHandle(FhevmOperator.fheRotr, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheEq(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createCompareOpHandle(FhevmOperator.fheEq, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheNe(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createCompareOpHandle(FhevmOperator.fheNe, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheGe(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createCompareOpHandle(FhevmOperator.fheGe, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheGt(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createCompareOpHandle(FhevmOperator.fheGt, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheLe(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createCompareOpHandle(FhevmOperator.fheLe, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
  fheLt(lhsBytes32Hex, rhsBytes32Hex, scalar) {
    return createCompareOpHandle(FhevmOperator.fheLt, lhsBytes32Hex, rhsBytes32Hex, scalar, __classPrivateFieldGet12(this, _FhevmHandleCoder_aclAddress, "f"), __classPrivateFieldGet12(this, _FhevmHandleCoder_chainId, "f"));
  }
};
_FhevmHandleCoder_aclAddress = /* @__PURE__ */ new WeakMap(), _FhevmHandleCoder_chainId = /* @__PURE__ */ new WeakMap();
function _appendMetadataToPrehandle(prehandle, handleType, chainId) {
  let result = prehandle & 0xffffffffffffffffffffffffffffffffffffffffff0000000000000000000000n;
  result = result | 0xffn << 80n;
  result = result | chainId << 16n;
  result = result | BigInt(handleType) << 8n;
  result = result | BigInt(constants_default.FHEVM_HANDLE_VERSION);
  return result;
}
function createBinaryOpHandle(op, lhs, rhs, scalar, type, aclAddress, chainId) {
  if (typeof scalar === "boolean") {
    scalar = scalar ? "0x01" : "0x00";
  }
  const enc = ethers_exports.solidityPacked(["uint8", "bytes32", "bytes32", "bytes1", "address", "uint256"], [op, lhs, rhs, scalar, aclAddress, chainId]);
  const prehandle = BigInt(ethers_exports.keccak256(enc));
  return ethers_exports.toBeHex(_appendMetadataToPrehandle(prehandle, type, BigInt(chainId)));
}
function createNumericalOpHandle(op, lhs, rhs, scalar, aclAddress, chainId) {
  const handleLhs = FhevmHandle.fromBytes32Hex(lhs);
  return createBinaryOpHandle(op, lhs, rhs, scalar, handleLhs.fheType, aclAddress, chainId);
}
function createBitwiseOpHandle(op, lhs, rhs, scalar, aclAddress, chainId) {
  const handleLhs = FhevmHandle.fromBytes32Hex(lhs);
  return createBinaryOpHandle(op, lhs, rhs, scalar, handleLhs.fheType, aclAddress, chainId);
}
function createCompareOpHandle(op, lhs, rhs, scalar, aclAddress, chainId) {
  return createBinaryOpHandle(op, lhs, rhs, scalar, FheType.Bool, aclAddress, chainId);
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/coprocessor/CoprocessorEvents.js
function isCoprocessorEventName(value) {
  return value === "VerifyCiphertext" || value === "TrivialEncrypt" || value === "TrivialEncryptBytes" || value === "FheAdd" || value === "FheSub" || value === "FheMul" || value === "FheDiv" || value === "FheRem" || value === "FheBitAnd" || value === "FheBitOr" || value === "FheBitXor" || value === "FheShl" || value === "FheShr" || value === "FheRotl" || value === "FheRotr" || value === "FheEq" || value === "FheEqBytes" || value === "FheNe" || value === "FheNeBytes" || value === "FheGe" || value === "FheGt" || value === "FheLe" || value === "FheLt" || value === "FheMin" || value === "FheMax" || value === "FheRand" || value === "FheRandBounded" || value === "FheNot" || value === "FheNeg" || value === "Cast" || value === "FheIfThenElse";
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/coprocessor/utils.js
async function getCoprocessorEvents(coprocessorContractInterface, coprocessorContractAddress, readonlyProvider, options) {
  let currentBlockNumber = -1;
  let toBlock;
  if (options.toBlockNumber !== void 0) {
    toBlock = options.toBlockNumber;
  } else {
    currentBlockNumber = await readonlyProvider.getBlockNumber();
    toBlock = currentBlockNumber;
  }
  let fromBlock;
  if (options.fromBlockNumber !== void 0) {
    fromBlock = options.fromBlockNumber;
  } else {
    fromBlock = toBlock;
  }
  if (fromBlock > toBlock) {
    throw new FhevmError(`Invalid block filter fromBlock=${fromBlock} toBlock=${toBlock}`);
  }
  const filter = {
    address: coprocessorContractAddress,
    fromBlock,
    toBlock
  };
  const logs = await readonlyProvider.getLogs(filter);
  const cursor = new BlockLogCursor(-1);
  const events = logs.map((log) => {
    try {
      cursor.updateForward(log.blockNumber, log.index);
      const parsedLog = coprocessorContractInterface.parseLog(log);
      if (log.blockNumber === fromBlock) {
        if (options.fromBlockLogIndex !== void 0) {
          if (log.index < options.fromBlockLogIndex) {
            return null;
          }
        }
      }
      if (!isCoprocessorEventName(parsedLog.name)) {
        return null;
      }
      const evt = {
        eventName: parsedLog.name,
        args: parsedLog.args,
        index: log.index,
        blockNumber: log.blockNumber,
        transactionHash: log.transactionHash,
        transactionIndex: log.transactionIndex
      };
      return evt;
    } catch {
      return null;
    }
  }).filter((event) => event !== null);
  return { events, cursor };
}
function parseCoprocessorEventsFromLogs(logs) {
  if (!logs) {
    return [];
  }
  const events = [];
  for (const log of logs) {
    const event = FHEVMExecutorPartialInterface.parseLog(log);
    if (!event) {
      continue;
    }
    if (!isCoprocessorEventName(event.name)) {
      continue;
    }
    const ce = {
      eventName: event.name,
      args: event.args,
      blockNumber: log.blockNumber,
      index: log.index,
      transactionHash: log.transactionHash,
      transactionIndex: log.transactionIndex
    };
    events.push(ce);
  }
  return events;
}

// node_modules/@fhevm/mock-utils/_esm/ethers/anvil.js
async function anvilNodeInfo(provider) {
  return minimalProviderSend(provider, "anvil_nodeInfo", []);
}
async function isAnvilProvider(provider) {
  try {
    const nodeInfo = await anvilNodeInfo(provider);
    if (!("environment" in nodeInfo)) {
      return { isAnvil: false, couldNotConnect: false };
    }
    const env = nodeInfo.environment;
    if (!("chainId" in env)) {
      return { isAnvil: false, couldNotConnect: false };
    }
    return { isAnvil: true, chainId: Number(BigInt(env.chainId)), couldNotConnect: false };
  } catch (e) {
    if (isHardhatProviderError(e)) {
      if (e.code === -32004 || e.code === -32601) {
        return { isAnvil: false, couldNotConnect: false };
      }
    } else if (isHardhatError(e)) {
      if (e.number === 108) {
        return { couldNotConnect: true };
      }
    } else if (isNodeRuntime()) {
      if (e instanceof Error && "code" in e) {
        if (e.code === "ECONNREFUSED") {
          return { couldNotConnect: true };
        }
      }
    }
    throw e;
  }
}

// node_modules/@fhevm/mock-utils/_esm/ethers/hardhat.js
async function isHardhatProvider(provider) {
  try {
    const metadata = await minimalProviderSend(provider, "hardhat_metadata", []);
    if (!("chainId" in metadata) || metadata.chainId !== 31337) {
      return { couldNotConnect: false, isHardhat: false };
    }
    if (!("instanceId" in metadata) || metadata.instanceId.length !== 66) {
      return { couldNotConnect: false, isHardhat: false };
    }
    return { couldNotConnect: false, isHardhat: true, chainId: Number(BigInt(metadata.chainId)) };
  } catch (e) {
    if (isHardhatProviderError(e)) {
      if (e.code === -32004 || e.code === -32601) {
        return { couldNotConnect: false, isHardhat: false };
      }
    } else if (isHardhatError(e)) {
      if (e.number === 108) {
        return { couldNotConnect: true };
      }
    } else if (isNodeRuntime()) {
      if (e instanceof Error && "code" in e) {
        if (e.code === "ECONNREFUSED") {
          return { couldNotConnect: true };
        }
      }
    }
    throw e;
  }
}

// node_modules/@fhevm/mock-utils/_esm/ethers/FhevmMockProvider.js
var __classPrivateFieldSet13 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet13 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FhevmMockProvider_minimalProvider;
var _FhevmMockProvider_readonlyEthersProvider;
var _FhevmMockProvider_info;
var _FhevmMockProvider_savedBlockGasLimit;
var _FhevmMockProvider_debugFunc;
var FhevmMockProviderType;
(function(FhevmMockProviderType2) {
  FhevmMockProviderType2[FhevmMockProviderType2["Unknown"] = 0] = "Unknown";
  FhevmMockProviderType2[FhevmMockProviderType2["Hardhat"] = 1] = "Hardhat";
  FhevmMockProviderType2[FhevmMockProviderType2["HardhatNode"] = 2] = "HardhatNode";
  FhevmMockProviderType2[FhevmMockProviderType2["Anvil"] = 3] = "Anvil";
  FhevmMockProviderType2[FhevmMockProviderType2["SepoliaEthereum"] = 4] = "SepoliaEthereum";
})(FhevmMockProviderType || (FhevmMockProviderType = {}));
function fhevmMockProviderTypeToString(value) {
  switch (value) {
    case FhevmMockProviderType.Unknown:
      return "Unknown";
    case FhevmMockProviderType.Hardhat:
      return "Hardhat";
    case FhevmMockProviderType.HardhatNode:
      return "Hardhat Node";
    case FhevmMockProviderType.Anvil:
      return "Anvil";
    case FhevmMockProviderType.SepoliaEthereum:
      return "SepoliaEthereum";
  }
}
var FhevmMockProvider = class _FhevmMockProvider {
  constructor() {
    _FhevmMockProvider_minimalProvider.set(this, void 0);
    _FhevmMockProvider_readonlyEthersProvider.set(this, void 0);
    _FhevmMockProvider_info.set(this, void 0);
    _FhevmMockProvider_savedBlockGasLimit.set(this, void 0);
    _FhevmMockProvider_debugFunc.set(this, void 0);
  }
  static async fromReadonlyProvider(readonlyProvider, networkName, defaultProviderType, defaultChainId, url) {
    return _FhevmMockProvider.create(readonlyProvider, readonlyProvider, networkName, defaultProviderType, defaultChainId, url);
  }
  static async create(minimalProvider, readonlyEthersProvider, networkName, defaultProviderType, defaultChainId, url) {
    const info = await _resolveProviderInfo(minimalProvider, networkName, defaultProviderType, defaultChainId, url);
    const p = new _FhevmMockProvider();
    __classPrivateFieldSet13(p, _FhevmMockProvider_minimalProvider, minimalProvider, "f");
    __classPrivateFieldSet13(p, _FhevmMockProvider_info, info, "f");
    if (readonlyEthersProvider === void 0 && info.url !== void 0) {
      readonlyEthersProvider = new JsonRpcProvider(info.url);
    }
    __classPrivateFieldSet13(p, _FhevmMockProvider_readonlyEthersProvider, readonlyEthersProvider, "f");
    return p;
  }
  setDebugFunc(debugFunc) {
    assertFhevm(typeof debugFunc === "function");
    __classPrivateFieldSet13(this, _FhevmMockProvider_debugFunc, debugFunc, "f");
  }
  // public async getTransaction(txHash: string): Promise<null | EthersT.TransactionResponse> {
  //   return await this.ethersProvider.getTransaction(txHash);
  // }
  get readonlyEthersProvider() {
    if (!__classPrivateFieldGet13(this, _FhevmMockProvider_minimalProvider, "f")) {
      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);
    }
    if (!__classPrivateFieldGet13(this, _FhevmMockProvider_readonlyEthersProvider, "f")) {
      throw new FhevmError(`the FhevmMockProvider instance is not able to provide a valid ethers.Provider instance.`);
    }
    return __classPrivateFieldGet13(this, _FhevmMockProvider_readonlyEthersProvider, "f");
  }
  get minimalProvider() {
    if (!__classPrivateFieldGet13(this, _FhevmMockProvider_minimalProvider, "f")) {
      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);
    }
    return __classPrivateFieldGet13(this, _FhevmMockProvider_minimalProvider, "f");
  }
  get info() {
    if (!__classPrivateFieldGet13(this, _FhevmMockProvider_info, "f")) {
      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);
    }
    return __classPrivateFieldGet13(this, _FhevmMockProvider_info, "f");
  }
  get isMock() {
    if (!__classPrivateFieldGet13(this, _FhevmMockProvider_info, "f")) {
      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);
    }
    return __classPrivateFieldGet13(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.Hardhat || __classPrivateFieldGet13(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.HardhatNode || __classPrivateFieldGet13(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.Anvil;
  }
  get isSepoliaEthereum() {
    if (!__classPrivateFieldGet13(this, _FhevmMockProvider_info, "f")) {
      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);
    }
    return __classPrivateFieldGet13(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.SepoliaEthereum;
  }
  get isHardhatWeb3Client() {
    if (!__classPrivateFieldGet13(this, _FhevmMockProvider_info, "f")) {
      throw new FhevmError(`the FhevmMockProvider instance is not initialized.`);
    }
    return __classPrivateFieldGet13(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.Hardhat || __classPrivateFieldGet13(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.HardhatNode;
  }
  get chainId() {
    return this.info.chainId;
  }
  async impersonateAddressAndSetBalance(address, balance) {
    if (!this.info.methods.impersonateAccount) {
      throw new FhevmError(`Network ${this.info.networkName} does not support account impersonation`);
    }
    if (!this.info.methods.setBalance) {
      throw new FhevmError(`Network ${this.info.networkName} does not support account setBalance`);
    }
    if (this.info.type === FhevmMockProviderType.Anvil) {
      if (!this.info.url) {
        throw new FhevmError(`Unable to impersonate account. Missing Anvil url.`);
      }
    }
    await this.send(this.info.methods.impersonateAccount, [address]);
    await this.send(this.info.methods.setBalance, [address, ethers_exports.toBeHex(balance)]);
    if (this.info.type === FhevmMockProviderType.Anvil) {
      const jsonRpcProvider = new ethers_exports.JsonRpcProvider(this.info.url);
      jsonRpcProvider.pollingInterval = 100;
      return await jsonRpcProvider.getSigner(address);
    } else if (this.isHardhatWeb3Client) {
      return void 0;
    } else {
      throw new FhevmError(`Network ${this.info.networkName} does not support account impersonation`);
    }
  }
  async setCodeAt(address, byteCode) {
    const methodName = this.info.methods.setCode;
    if (!methodName) {
      throw new FhevmError(`Network ${this.info.networkName} does not support 'setCode' method.`);
    }
    if (typeof byteCode !== "string") {
      throw new FhevmError(`Invalid contract bytecode.`);
    }
    await this.send(methodName, [address, byteCode]);
  }
  send(method, params) {
    return minimalProviderSend(this.minimalProvider, method, params ?? []);
  }
  async getCodeAt(address) {
    const byteCode = await this.send("eth_getCode", [address, "latest"]);
    if (typeof byteCode !== "string") {
      throw new FhevmError(`Unexpected 'eth_getCode' RPC response type.`);
    }
    return byteCode;
  }
  async getBlockNumber() {
    const blockNumber = await this.send("eth_blockNumber");
    return Number(blockNumber);
  }
  async unsetTemporaryMinimumBlockGasLimit() {
    if (!__classPrivateFieldGet13(this, _FhevmMockProvider_savedBlockGasLimit, "f")) {
      return;
    }
    try {
      await this.setBlockGasLimit(__classPrivateFieldGet13(this, _FhevmMockProvider_savedBlockGasLimit, "f"));
    } finally {
      __classPrivateFieldSet13(this, _FhevmMockProvider_savedBlockGasLimit, void 0, "f");
    }
  }
  async setTemporaryMinimumBlockGasLimit(minBlockGasLimit) {
    if (__classPrivateFieldGet13(this, _FhevmMockProvider_savedBlockGasLimit, "f")) {
      throw new FhevmError(`The minimum block gas limit has already been set.`);
    }
    const currentBlockGasLimit = await this.getBlockGasLimit();
    if (!currentBlockGasLimit) {
      this._debug(`Unable to setup minimum block gas limit.`);
      return void 0;
    }
    if (minBlockGasLimit <= currentBlockGasLimit) {
      return void 0;
    }
    this._debug(`Adjust block gas limit to: ${minBlockGasLimit}. Current block gas limit is too low: ${currentBlockGasLimit}`);
    await this.setBlockGasLimit(minBlockGasLimit);
    __classPrivateFieldSet13(this, _FhevmMockProvider_savedBlockGasLimit, currentBlockGasLimit, "f");
  }
  async setBlockGasLimit(blockGasLimit) {
    const blockGasLimitHex = "0x" + blockGasLimit.toString(16);
    await this.send("evm_setBlockGasLimit", [blockGasLimitHex]);
    this._debug(`Call evm_setBlockGasLimit ${blockGasLimit}`);
  }
  async getBlockGasLimit() {
    const res = await this.send("eth_getBlockByNumber", ["latest", false]);
    if (!res) {
      return void 0;
    }
    if (!("gasLimit" in res)) {
      return void 0;
    }
    try {
      return BigInt(res.gasLimit);
    } catch {
      return void 0;
    }
  }
  _debug(message) {
    if (__classPrivateFieldGet13(this, _FhevmMockProvider_debugFunc, "f")) {
      __classPrivateFieldGet13(this, _FhevmMockProvider_debugFunc, "f").call(this, message);
    }
  }
};
_FhevmMockProvider_minimalProvider = /* @__PURE__ */ new WeakMap(), _FhevmMockProvider_readonlyEthersProvider = /* @__PURE__ */ new WeakMap(), _FhevmMockProvider_info = /* @__PURE__ */ new WeakMap(), _FhevmMockProvider_savedBlockGasLimit = /* @__PURE__ */ new WeakMap(), _FhevmMockProvider_debugFunc = /* @__PURE__ */ new WeakMap();
async function _resolveProviderInfo(minimalProvider, networkName, defaultProviderType, defaultChainId, url) {
  assertIsString(networkName, "networkName");
  if (networkName !== "hardhat" && networkName !== "localhost" && defaultChainId === constants_default.SEPOLIA_ETHEREUM_TESTNET_CHAINID) {
    assertFhevm(url !== void 0, "Missing sepolia url");
    return {
      type: FhevmMockProviderType.SepoliaEthereum,
      chainId: constants_default.SEPOLIA_ETHEREUM_TESTNET_CHAINID,
      methods: {},
      url,
      networkName,
      web3ClientVersion: ""
    };
  }
  const p = await _resolveProvider(minimalProvider, defaultProviderType, defaultChainId, url);
  switch (p.type) {
    case FhevmMockProviderType.Unknown: {
      return {
        type: p.type,
        chainId: p.chainId,
        methods: {},
        url,
        networkName,
        web3ClientVersion: p.web3ClientVersion
      };
    }
    case FhevmMockProviderType.Hardhat:
    case FhevmMockProviderType.HardhatNode: {
      return {
        type: p.type,
        chainId: p.chainId,
        methods: {
          setBalance: "hardhat_setBalance",
          setCode: "hardhat_setCode",
          impersonateAccount: "hardhat_impersonateAccount"
        },
        url,
        networkName,
        web3ClientVersion: p.web3ClientVersion
      };
    }
    case FhevmMockProviderType.Anvil: {
      return {
        type: p.type,
        chainId: p.chainId,
        methods: {
          setBalance: "anvil_setBalance",
          setCode: "anvil_setCode",
          impersonateAccount: "anvil_impersonateAccount"
        },
        url,
        networkName,
        web3ClientVersion: p.web3ClientVersion
      };
    }
    default: {
      throw new FhevmError(`Unsuppored FhevmMockProviderType enum value '${p.type}'`);
    }
  }
}
async function _resolveProvider(minimalProvider, defaultProviderType, defaultChainId, url) {
  if (!url) {
    if (defaultProviderType !== FhevmMockProviderType.Hardhat) {
      throw new FhevmError(`Missing provider url`);
    } else {
      if (defaultChainId !== 31337) {
        throw new FhevmError(`Unexpected default chainId. Expecting '31337', got '${defaultChainId}' instead.`);
      }
    }
  } else {
    if (!URL.canParse(url)) {
      throw new FhevmError(`Invalid provider url '${url}'`);
    }
  }
  const clientRes = await connectedWeb3Client(minimalProvider);
  const anvilRes = await isAnvilProvider(minimalProvider);
  if (!anvilRes.couldNotConnect) {
    if (anvilRes.isAnvil) {
      if (defaultProviderType !== void 0 && defaultProviderType !== FhevmMockProviderType.Anvil) {
        throw new FhevmError(`Provider type mismatch. Expecting ${fhevmMockProviderTypeToString(defaultProviderType)}, got ${fhevmMockProviderTypeToString(FhevmMockProviderType.Anvil)} instead`);
      }
      if (defaultChainId !== void 0 && defaultChainId !== anvilRes.chainId) {
        throw new FhevmError(`Anvil chainId mismatch. Expecting chainId=${defaultChainId}, got ${anvilRes.chainId} instead`);
      }
      if (!clientRes.client) {
        throw new FhevmError(`Unable to retrieve Anvil web3 client version.`);
      }
      return {
        type: FhevmMockProviderType.Anvil,
        chainId: anvilRes.chainId,
        web3ClientVersion: clientRes.client
      };
    }
  }
  const hhRes = await isHardhatProvider(minimalProvider);
  if (!hhRes.couldNotConnect) {
    if (hhRes.isHardhat) {
      const providerType = url !== void 0 ? FhevmMockProviderType.HardhatNode : FhevmMockProviderType.Hardhat;
      if (defaultProviderType !== void 0 && defaultProviderType !== providerType) {
        throw new FhevmError(`Provider type mismatch. Expecting ${fhevmMockProviderTypeToString(defaultProviderType)}, got ${fhevmMockProviderTypeToString(providerType)} instead`);
      }
      if (defaultChainId !== void 0 && defaultChainId !== hhRes.chainId) {
        throw new FhevmError(`Hardhat chainId mismatch. Expecting chainId=${defaultChainId}, got ${hhRes.chainId} instead`);
      }
      if (!clientRes.client) {
        throw new FhevmError(`Unable to retrieve Hardhat web3 client version.`);
      }
      return {
        type: providerType,
        chainId: hhRes.chainId,
        web3ClientVersion: clientRes.client
      };
    }
  }
  if (!clientRes.couldNotConnect) {
    const chainId = await connectedChainId(minimalProvider);
    if (chainId === void 0) {
      throw new FhevmError(`Unable to query provider chaindId`);
    }
    if (defaultProviderType !== void 0 && defaultProviderType !== FhevmMockProviderType.Unknown) {
      throw new FhevmError(`Provider type mismatch. Expecting ${fhevmMockProviderTypeToString(defaultProviderType)}, got ${fhevmMockProviderTypeToString(FhevmMockProviderType.Unknown)} instead`);
    }
    if (defaultChainId !== void 0 && defaultChainId !== chainId) {
      throw new FhevmError(`Provider chainId mismatch. Expecting chainId=${defaultChainId}, got ${chainId} instead`);
    }
    if (!clientRes.client) {
      throw new FhevmError(`Unable to retrieve provider web3 client version.`);
    }
    return { type: FhevmMockProviderType.Unknown, chainId, web3ClientVersion: clientRes.client };
  }
  if (defaultProviderType === void 0) {
    throw new FhevmError(`Resolve provider failed. Missing default provider type.`);
  }
  if (defaultChainId === void 0) {
    throw new FhevmError(`Resolve provider failed. Missing default provider chainId.`);
  }
  return { type: defaultProviderType, chainId: defaultChainId, web3ClientVersion: void 0 };
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/coprocessor/CoprocessorEventsHandler.js
var __classPrivateFieldSet14 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet14 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CoprocessorEventsHandler_db;
var _CoprocessorEventsHandler_counterRand;
var CoprocessorEventsHandler = class {
  constructor(db) {
    _CoprocessorEventsHandler_db.set(this, void 0);
    _CoprocessorEventsHandler_counterRand.set(this, void 0);
    __classPrivateFieldSet14(this, _CoprocessorEventsHandler_db, db, "f");
    __classPrivateFieldSet14(this, _CoprocessorEventsHandler_counterRand, 0, "f");
  }
  get counterRand() {
    return __classPrivateFieldGet14(this, _CoprocessorEventsHandler_counterRand, "f");
  }
  async handleEvent(coprocessorEvent) {
    var _a;
    assertFhevm(coprocessorEvent.blockNumber >= __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").fromBlockNumber, "coprocessorEvent.blockNumber < this.#db.fromBlockNumber");
    if (coprocessorEvent.eventName === "VerifyCiphertext") {
      await this.verifyCipherText(coprocessorEvent.args);
    } else {
      const res = await this.executeCoprocessorEvent(coprocessorEvent);
      if (res) {
        await __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").insertHandleBytes32(res.resultBytes32, res.clearText, {
          index: coprocessorEvent.index,
          blockNumber: coprocessorEvent.blockNumber,
          transactionHash: coprocessorEvent.transactionHash
        }, res.replace !== void 0 ? { replace: res.replace } : void 0);
        if (coprocessorEvent.eventName === "FheRandBounded" || coprocessorEvent.eventName === "FheRand") {
          __classPrivateFieldSet14(this, _CoprocessorEventsHandler_counterRand, (_a = __classPrivateFieldGet14(this, _CoprocessorEventsHandler_counterRand, "f"), _a++, _a), "f");
        }
      }
    }
  }
  async executeCoprocessorEvent(event) {
    switch (event.eventName) {
      case "TrivialEncrypt": {
        const ptUint256 = event.args[1];
        const fheType = event.args[2];
        const resultBytes32 = event.args[3];
        assertEventArgIsBigUint256(ptUint256, "TrivialEncrypt", 1);
        assertEventArgIsBigUint256(fheType, "TrivialEncrypt", 2);
        assertEventArgIsBytes32String(resultBytes32, "TrivialEncrypt", 3);
        return {
          resultBytes32,
          clearText: ptUint256
        };
      }
      case "TrivialEncryptBytes": {
        const ptBytes = event.args[1];
        const resultBytes32 = event.args[3];
        assertEventArgIsBytesString(ptBytes, "TrivialEncryptBytes", 1);
        assertEventArgIsBytes32String(resultBytes32, "TrivialEncrypt", 3);
        return {
          resultBytes32,
          clearText: ptBytes
        };
      }
      case "FheAdd": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        let clearText = binaryOp.clearTextLhsBigInt + binaryOp.clearTextRhsBigInt;
        clearText = clearText % 2n ** binaryOp.clearTextBitLength;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheSub": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        let clearText = binaryOp.clearTextLhsBigInt - binaryOp.clearTextRhsBigInt;
        if (clearText < 0n)
          clearText = clearText + 2n ** binaryOp.clearTextBitLength;
        clearText = clearText % 2n ** binaryOp.clearTextBitLength;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheMul": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        let clearText = binaryOp.clearTextLhsBigInt * binaryOp.clearTextRhsBigInt;
        clearText = clearText % 2n ** binaryOp.clearTextBitLength;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheDiv": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        if (!binaryOp.scalar) {
          throw new Error("Non-scalar div not implemented yet");
        }
        const clearText = binaryOp.clearTextLhsBigInt / binaryOp.clearTextRhsBigInt;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheRem": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        if (!binaryOp.scalar) {
          throw new Error("Non-scalar rem not implemented yet");
        }
        const clearText = binaryOp.clearTextLhsBigInt % binaryOp.clearTextRhsBigInt;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheBitAnd": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        let clearText = binaryOp.clearTextLhsBigInt & binaryOp.clearTextRhsBigInt;
        clearText = clearText % 2n ** binaryOp.clearTextBitLength;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheBitOr": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        let clearText = binaryOp.clearTextLhsBigInt | binaryOp.clearTextRhsBigInt;
        clearText = clearText % 2n ** binaryOp.clearTextBitLength;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheBitXor": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        let clearText = binaryOp.clearTextLhsBigInt ^ binaryOp.clearTextRhsBigInt;
        clearText = clearText % 2n ** binaryOp.clearTextBitLength;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheShl": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        let clearText = binaryOp.clearTextLhsBigInt << binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
        clearText = clearText % 2n ** binaryOp.clearTextBitLength;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheShr": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        let clearText = binaryOp.clearTextLhsBigInt >> binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
        clearText = clearText % 2n ** binaryOp.clearTextBitLength;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheRotl": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        const shift = binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
        let clearText = binaryOp.clearTextLhsBigInt << shift | binaryOp.clearTextLhsBigInt >> binaryOp.clearTextBitLength - shift;
        clearText = clearText % 2n ** binaryOp.clearTextBitLength;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheRotr": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        const shift = binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
        let clearText = binaryOp.clearTextLhsBigInt >> shift | binaryOp.clearTextLhsBigInt << binaryOp.clearTextBitLength - shift;
        clearText = clearText % 2n ** binaryOp.clearTextBitLength;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheEq": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 1n : 0n;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheEqBytes": {
        const binaryOp = await this.parseBinaryBytesOpEvent(event);
        const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 1n : 0n;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheNe": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 0n : 1n;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheNeBytes": {
        const binaryOp = await this.parseBinaryBytesOpEvent(event);
        const clearText = binaryOp.clearTextLhsBigInt !== binaryOp.clearTextRhsBigInt ? 1n : 0n;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheGe": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        const clearText = binaryOp.clearTextLhsBigInt >= binaryOp.clearTextRhsBigInt ? 1n : 0n;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheGt": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        const clearText = binaryOp.clearTextLhsBigInt > binaryOp.clearTextRhsBigInt ? 1n : 0n;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheLe": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        const clearText = binaryOp.clearTextLhsBigInt <= binaryOp.clearTextRhsBigInt ? 1n : 0n;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheLt": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        const clearText = binaryOp.clearTextLhsBigInt < binaryOp.clearTextRhsBigInt ? 1n : 0n;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheMin": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        const clearText = binaryOp.clearTextLhsBigInt < binaryOp.clearTextRhsBigInt ? binaryOp.clearTextLhsBigInt : binaryOp.clearTextRhsBigInt;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheMax": {
        const binaryOp = await this.parseBinaryOpEvent(event);
        const clearText = binaryOp.clearTextLhsBigInt > binaryOp.clearTextRhsBigInt ? binaryOp.clearTextLhsBigInt : binaryOp.clearTextRhsBigInt;
        return {
          resultBytes32: binaryOp.resultBytes32,
          clearText
        };
      }
      case "FheNot": {
        const unaryOp = await this.parseUnaryOpEvent(event);
        const clearText = bitwiseNotUIntBits(unaryOp.clearTextBigInt, unaryOp.clearTextBitLength);
        return {
          resultBytes32: unaryOp.resultBytes32,
          clearText
        };
      }
      case "FheNeg": {
        const unaryOp = await this.parseUnaryOpEvent(event);
        let clearText = bitwiseNotUIntBits(unaryOp.clearTextBigInt, unaryOp.clearTextBitLength);
        clearText = (clearText + 1n) % 2n ** unaryOp.clearTextBitLength;
        return {
          resultBytes32: unaryOp.resultBytes32,
          clearText
        };
      }
      case "Cast": {
        const ctBytes32 = event.args[1];
        const toTypeUint8 = event.args[2];
        const resultBytes32 = event.args[3];
        assertEventArgIsBytes32String(ctBytes32, event.eventName, 1);
        assertEventArgIsBigUint8(toTypeUint8, event.eventName, 2);
        assertEventArgIsBytes32String(resultBytes32, event.eventName, 3);
        const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
        const resultType = resultFhevmHandle.fheType;
        const clearTextBitLength = BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength);
        assertFhevm(BigInt(resultType) === toTypeUint8, `Cast type mismatch, (resultType:${resultType}) !== (toTypeUint8:${toTypeUint8})`);
        const ct = BigInt((await __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ctBytes32)).clearTextHex);
        const clearText = ct % 2n ** clearTextBitLength;
        return {
          resultBytes32,
          clearText
        };
      }
      case "FheIfThenElse": {
        const controlBytes32 = event.args[1];
        const ifTrueBytes32 = event.args[2];
        const ifFalseBytes32 = event.args[3];
        const resultBytes32 = event.args[4];
        assertEventArgIsBytes32String(controlBytes32, event.eventName, 1);
        assertEventArgIsBytes32String(ifTrueBytes32, event.eventName, 2);
        assertEventArgIsBytes32String(ifFalseBytes32, event.eventName, 3);
        assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);
        const control = BigInt((await __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(controlBytes32)).clearTextHex);
        const ifTrue = BigInt((await __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ifTrueBytes32)).clearTextHex);
        const ifFalse = BigInt((await __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ifFalseBytes32)).clearTextHex);
        assertFhevm(control === 0n || control === 1n, `Unexpected FheIfThenElse control value. Got ${control}, expecting 0 or 1`);
        const clearText = control === 1n ? ifTrue : ifFalse;
        return {
          resultBytes32,
          clearText
        };
      }
      case "FheRand": {
        const randTypeUint8 = event.args[1];
        const seedBytes16 = event.args[2];
        const resultBytes32 = event.args[3];
        assertEventArgIsBigUint8(randTypeUint8, event.eventName, 1);
        assertEventArgIsBytes16String(seedBytes16, event.eventName, 2);
        assertEventArgIsBytes32String(resultBytes32, event.eventName, 3);
        const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
        const resultType = resultFhevmHandle.fheType;
        const clearTextBitLength = resultFhevmHandle.fhevmTypeInfo.clearTextBitLength;
        assertFhevm(BigInt(resultType) === randTypeUint8, `Rand type mismatch, (resultType:${resultType}) !== (randTypeUint8:${randTypeUint8})`);
        const clearText = getRandomBigInt(clearTextBitLength);
        return {
          resultBytes32,
          clearText,
          replace: true
        };
      }
      case "FheRandBounded": {
        const upperBoundUint256 = event.args[1];
        const randTypeUint8 = event.args[2];
        const seedBytes16 = event.args[3];
        const resultBytes32 = event.args[4];
        assertEventArgIsBigUint256(upperBoundUint256, event.eventName, 1);
        assertEventArgIsBigUint8(randTypeUint8, event.eventName, 2);
        assertEventArgIsBytes16String(seedBytes16, event.eventName, 3);
        assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);
        const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
        const resultType = resultFhevmHandle.fheType;
        assertFhevm(BigInt(resultType) === randTypeUint8, `Rand type mismatch, (resultType:${resultType}) !== (randTypeUint8:${randTypeUint8})`);
        const clearText = getRandomBigInt(Number(log2BigInt(upperBoundUint256)));
        return {
          resultBytes32,
          clearText,
          replace: true
        };
      }
    }
    throw new FhevmError(`Unknown fhevm coprocessor event: ${event.eventName}`);
  }
  async verifyCipherText(eventArgs) {
    const inputHandleBytes32 = eventArgs[1];
    const userAddress = eventArgs[2];
    const inputProofBytes = eventArgs[3];
    const fheType = eventArgs[4];
    const resultBytes32 = eventArgs[5];
    assertEventArgIsBytes32String(inputHandleBytes32, "VerifyCipherText", 1);
    assertEventArgIsAddress(userAddress, "VerifyCipherText", 2);
    assertEventArgIsBytesString(inputProofBytes, "VerifyCipherText", 3);
    assertEventArgIsBigUint256(fheType, "VerifyCipherText", 4);
    assertEventArgIsBytes32String(resultBytes32, "VerifyCipherText", 5);
    assertFhevm(inputHandleBytes32 === resultBytes32, `VerifyCipherText: inputHandleBytes32=${inputHandleBytes32} differs from resultBytes32=${resultBytes32}`);
    try {
      await __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(inputHandleBytes32);
    } catch {
      throw new FhevmError(`User input was not found in DB inputHandle=${inputHandleBytes32}`);
    }
  }
  async parseUnaryOpEvent(event) {
    const ctBytes32 = event.args[1];
    const resultBytes32 = event.args[2];
    assertEventArgIsBytes32String(ctBytes32, event.eventName, 1);
    assertEventArgIsBytes32String(resultBytes32, event.eventName, 2);
    const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
    const clearTextBigInt = BigInt((await __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ctBytes32)).clearTextHex);
    return {
      resultBytes32,
      clearTextBigInt,
      clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength)
    };
  }
  async parseBinaryOpEvent(event) {
    const lhsBytes32 = event.args[1];
    const rhsBytes32 = event.args[2];
    const scalarBytes1 = event.args[3];
    const resultBytes32 = event.args[4];
    assertEventArgIsBytes32String(lhsBytes32, event.eventName, 1);
    assertEventArgIsBytes32String(rhsBytes32, event.eventName, 2);
    assertEventArgIsBytes1String(scalarBytes1, event.eventName, 3);
    assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);
    const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
    const scalar = scalarBytes1 === "0x01";
    const clearTextLhsBigInt = BigInt((await __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(lhsBytes32)).clearTextHex);
    const clearTextRhsBigInt = scalar ? BigInt(rhsBytes32) : BigInt((await __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(rhsBytes32)).clearTextHex);
    return {
      resultBytes32,
      clearTextLhsBigInt,
      clearTextRhsBigInt,
      scalar,
      clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength)
    };
  }
  async parseBinaryBytesOpEvent(event) {
    const lhsBytes32 = event.args[1];
    const rhsBytes = event.args[2];
    const scalarBytes1 = event.args[3];
    const resultBytes32 = event.args[4];
    assertEventArgIsBytes32String(lhsBytes32, event.eventName, 1);
    assertEventArgIsBytesString(rhsBytes, event.eventName, 2);
    assertEventArgIsBytes1String(scalarBytes1, event.eventName, 3);
    assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);
    const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
    const scalar = scalarBytes1 === "0x01";
    const clearTextLhsBigInt = BigInt((await __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(lhsBytes32)).clearTextHex);
    const clearTextRhsBigInt = scalar ? BigInt(rhsBytes) : BigInt((await __classPrivateFieldGet14(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(rhsBytes)).clearTextHex);
    return {
      resultBytes32,
      clearTextLhsBigInt,
      clearTextRhsBigInt,
      scalar,
      clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength)
    };
  }
};
_CoprocessorEventsHandler_db = /* @__PURE__ */ new WeakMap(), _CoprocessorEventsHandler_counterRand = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/coprocessor/CoprocessorEventsIterator.js
var __classPrivateFieldSet15 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet15 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CoprocessorEventsIterator_cursor;
var _CoprocessorEventsIterator_coprocessorContractInterface;
var _CoprocessorEventsIterator_coprocessorContractAddress;
var _CoprocessorEventsIterator_readonlyProvider;
var CoprocessorEventsIterator = class {
  constructor(coprocessorContractInterface, coprocessorContractAddress, readonlyProvider, fromBlockNumber) {
    _CoprocessorEventsIterator_cursor.set(this, void 0);
    _CoprocessorEventsIterator_coprocessorContractInterface.set(this, void 0);
    _CoprocessorEventsIterator_coprocessorContractAddress.set(this, void 0);
    _CoprocessorEventsIterator_readonlyProvider.set(this, void 0);
    __classPrivateFieldSet15(this, _CoprocessorEventsIterator_coprocessorContractInterface, coprocessorContractInterface, "f");
    __classPrivateFieldSet15(this, _CoprocessorEventsIterator_coprocessorContractAddress, coprocessorContractAddress, "f");
    __classPrivateFieldSet15(this, _CoprocessorEventsIterator_readonlyProvider, readonlyProvider, "f");
    __classPrivateFieldSet15(this, _CoprocessorEventsIterator_cursor, new BlockLogCursor(fromBlockNumber), "f");
  }
  async next() {
    const currentBlockNumber = await __classPrivateFieldGet15(this, _CoprocessorEventsIterator_readonlyProvider, "f").getBlockNumber();
    if (currentBlockNumber === __classPrivateFieldGet15(this, _CoprocessorEventsIterator_cursor, "f").blockNumber) {
      return [];
    }
    const { events, cursor } = await getCoprocessorEvents(__classPrivateFieldGet15(this, _CoprocessorEventsIterator_coprocessorContractInterface, "f"), __classPrivateFieldGet15(this, _CoprocessorEventsIterator_coprocessorContractAddress, "f"), __classPrivateFieldGet15(this, _CoprocessorEventsIterator_readonlyProvider, "f"), {
      fromBlockNumber: __classPrivateFieldGet15(this, _CoprocessorEventsIterator_cursor, "f").nextBlockNumber,
      toBlockNumber: currentBlockNumber
    });
    if (!cursor.isEmpty) {
      __classPrivateFieldGet15(this, _CoprocessorEventsIterator_cursor, "f").updateForward(cursor.blockNumber, cursor.blockLogIndex);
    } else {
      assertFhevm(events.length === 0);
    }
    return events;
  }
};
_CoprocessorEventsIterator_cursor = /* @__PURE__ */ new WeakMap(), _CoprocessorEventsIterator_coprocessorContractInterface = /* @__PURE__ */ new WeakMap(), _CoprocessorEventsIterator_coprocessorContractAddress = /* @__PURE__ */ new WeakMap(), _CoprocessorEventsIterator_readonlyProvider = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/coprocessor/MockCoprocessor.js
var __classPrivateFieldSet16 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet16 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MockCoprocessor_iterator;
var _MockCoprocessor_handler;
var _MockCoprocessor_db;
var _MockCoprocessor_coprocessorSigners;
var _MockCoprocessor_inputVerifier;
var MockCoprocessor = class _MockCoprocessor {
  constructor() {
    _MockCoprocessor_iterator.set(this, void 0);
    _MockCoprocessor_handler.set(this, void 0);
    _MockCoprocessor_db.set(this, void 0);
    _MockCoprocessor_coprocessorSigners.set(this, void 0);
    _MockCoprocessor_inputVerifier.set(this, void 0);
  }
  static async create(readonlyProvider, params) {
    const mc = new _MockCoprocessor();
    const coprocessorItf = params.coprocessorContractInterface ?? FHEVMExecutorPartialInterface;
    __classPrivateFieldSet16(mc, _MockCoprocessor_iterator, new CoprocessorEventsIterator(coprocessorItf, params.coprocessorContractAddress, readonlyProvider, params.db.fromBlockNumber), "f");
    __classPrivateFieldSet16(mc, _MockCoprocessor_handler, new CoprocessorEventsHandler(params.db), "f");
    __classPrivateFieldSet16(mc, _MockCoprocessor_db, params.db, "f");
    __classPrivateFieldSet16(mc, _MockCoprocessor_inputVerifier, await InputVerifier.create(readonlyProvider, params.inputVerifierContractAddress), "f");
    __classPrivateFieldSet16(mc, _MockCoprocessor_coprocessorSigners, params.coprocessorSigners, "f");
    return mc;
  }
  getDB() {
    assertFhevm(__classPrivateFieldGet16(this, _MockCoprocessor_db, "f") !== void 0, `MockCoprocessor not initialized`);
    return __classPrivateFieldGet16(this, _MockCoprocessor_db, "f");
  }
  async awaitCoprocessor() {
    assertFhevm(__classPrivateFieldGet16(this, _MockCoprocessor_iterator, "f") !== void 0, `MockCoprocessor not initialized`);
    assertFhevm(__classPrivateFieldGet16(this, _MockCoprocessor_handler, "f") !== void 0, `MockCoprocessor not initialized`);
    const events = await __classPrivateFieldGet16(this, _MockCoprocessor_iterator, "f").next();
    for (let i = 0; i < events.length; ++i) {
      await __classPrivateFieldGet16(this, _MockCoprocessor_handler, "f").handleEvent(events[i]);
    }
  }
  async clearHandleDB() {
    assertFhevm(__classPrivateFieldGet16(this, _MockCoprocessor_db, "f") !== void 0, `MockCoprocessor not initialized`);
    await this.awaitCoprocessor();
    await __classPrivateFieldGet16(this, _MockCoprocessor_db, "f").reset();
  }
  async handleEvmRevert(newBlockNumber) {
    console.log("HANDLE REVERT HERE!! " + newBlockNumber);
  }
  async insertHandleBytes32(handleBytes32Hex, clearTextHex, metadata) {
    assertFhevm(__classPrivateFieldGet16(this, _MockCoprocessor_db, "f") !== void 0, `MockCoprocessor not initialized`);
    await __classPrivateFieldGet16(this, _MockCoprocessor_db, "f").insertHandleBytes32(handleBytes32Hex, clearTextHex, metadata);
  }
  async queryHandlesBytes32AsHex(handlesBytes32) {
    assertFhevm(__classPrivateFieldGet16(this, _MockCoprocessor_db, "f") !== void 0, `MockCoprocessor not initialized`);
    await this.awaitCoprocessor();
    const clearTextHexList = [];
    for (let i = 0; i < handlesBytes32.length; ++i) {
      assertIsBytes32String(handlesBytes32[i]);
      let clearTextHex;
      try {
        clearTextHex = (await __classPrivateFieldGet16(this, _MockCoprocessor_db, "f").queryHandleBytes32(handlesBytes32[i])).clearTextHex;
      } catch {
        clearTextHex = "0x";
      }
      clearTextHexList.push(clearTextHex);
    }
    return clearTextHexList;
  }
  async computeCoprocessorSignatures(handlesBytes32List, contractChainId, contractAddress, userAddress, extraData) {
    assertFhevm(__classPrivateFieldGet16(this, _MockCoprocessor_inputVerifier, "f") !== void 0, `MockCoprocessor not initialized`);
    assertFhevm(__classPrivateFieldGet16(this, _MockCoprocessor_coprocessorSigners, "f") !== void 0, `MockCoprocessor not initialized`);
    const numHandles = handlesBytes32List.length;
    const handlesBytes32HexNoPrefixList = [];
    const handlesBytes32HexList = [];
    for (let index = 0; index < numHandles; ++index) {
      const handleBytes32Hex = ethers_exports.hexlify(handlesBytes32List[index]);
      handlesBytes32HexList.push(handleBytes32Hex);
      handlesBytes32HexNoPrefixList.push(removePrefix(handleBytes32Hex, "0x"));
    }
    const eip712 = __classPrivateFieldGet16(this, _MockCoprocessor_inputVerifier, "f").createCiphertextVerificationEIP712(handlesBytes32HexList, contractChainId, contractAddress, userAddress, extraData);
    const signaturesHex = await multiSignEIP712(__classPrivateFieldGet16(this, _MockCoprocessor_coprocessorSigners, "f"), eip712.domain, eip712.types, eip712.message);
    const signatureHexNoPrefixList = signaturesHex.map((sigHex) => removePrefix(sigHex, "0x"));
    return {
      handles: handlesBytes32HexNoPrefixList,
      signatures: signatureHexNoPrefixList
    };
  }
};
_MockCoprocessor_iterator = /* @__PURE__ */ new WeakMap(), _MockCoprocessor_handler = /* @__PURE__ */ new WeakMap(), _MockCoprocessor_db = /* @__PURE__ */ new WeakMap(), _MockCoprocessor_coprocessorSigners = /* @__PURE__ */ new WeakMap(), _MockCoprocessor_inputVerifier = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/decryptionOracle/DecryptionOracleEvents.js
function isDecryptionOracleEventName(value) {
  return value === "DecryptionRequest";
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/decryptionOracle/abi.js
var DecryptionOraclePartialInterface = new ethers_exports.Interface([
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "counter",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "requestID",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes32[]",
        name: "cts",
        type: "bytes32[]"
      },
      {
        indexed: false,
        internalType: "address",
        name: "contractCaller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes4",
        name: "callbackSelector",
        type: "bytes4"
      }
    ],
    name: "DecryptionRequest",
    type: "event"
  }
]);

// node_modules/@fhevm/mock-utils/_esm/fhevm/decryptionOracle/utils.js
async function getDecryptionOracleEvents(decryptionOracleContractInterface, decryptionOracleContractAddress, readonlyProvider, options) {
  let currentBlockNumber = -1;
  let toBlock;
  if (options.toBlockNumber !== void 0) {
    toBlock = options.toBlockNumber;
  } else {
    currentBlockNumber = await readonlyProvider.getBlockNumber();
    toBlock = currentBlockNumber;
  }
  let fromBlock;
  if (options.fromBlockNumber !== void 0) {
    fromBlock = options.fromBlockNumber;
  } else {
    fromBlock = toBlock;
  }
  if (fromBlock > toBlock) {
    throw new FhevmError(`Invalid block filter fromBlock=${fromBlock} toBlock=${toBlock}`);
  }
  const eventDecryptionFragment = decryptionOracleContractInterface.getEvent("DecryptionRequest");
  if (!eventDecryptionFragment) {
    throw new FhevmError(`Unknown "DecryptionRequest" event`);
  }
  const topics = decryptionOracleContractInterface.encodeFilterTopics(eventDecryptionFragment, []);
  const filter = {
    address: decryptionOracleContractAddress,
    fromBlock,
    toBlock,
    topics
  };
  const logs = await readonlyProvider.getLogs(filter);
  const cursor = new BlockLogCursor(-1);
  const events = logs.map((log) => {
    try {
      cursor.updateForward(log.blockNumber, log.index);
      const parsedLog = decryptionOracleContractInterface.parseLog(log);
      if (!isDecryptionOracleEventName(parsedLog.name)) {
        return null;
      }
      if (log.blockNumber === fromBlock) {
        if (options.fromBlockLogIndex !== void 0) {
          if (log.index < options.fromBlockLogIndex) {
            return null;
          }
        }
      }
      const evt = {
        eventName: parsedLog.name,
        args: parsedLog.args,
        index: log.index,
        blockNumber: log.blockNumber,
        transactionHash: log.transactionHash,
        transactionIndex: log.transactionIndex
      };
      return evt;
    } catch {
      return null;
    }
  }).filter((event) => event !== null);
  return { events, cursor };
}
function toDecryptionRequestEvent(e) {
  if (e.eventName !== "DecryptionRequest") {
    return null;
  }
  const counter = e.args[0];
  const requestID = e.args[1];
  const handlesBytes32Hex = e.args[2];
  const contractCallerAddress = e.args[3];
  const callbackSelectorBytes4Hex = e.args[4];
  assertEventArgIsBigUint256(counter, "DecryptionRequest", 0);
  assertEventArgIsBigUint256(requestID, "DecryptionRequest", 1);
  assertFhevm(handlesBytes32Hex.length > 0);
  assertEventArgIsBytes32String(handlesBytes32Hex[0], "DecryptionRequest", 2);
  assertEventArgIsAddress(contractCallerAddress, "DecryptionRequest", 3);
  assertEventArgIsBytes4String(callbackSelectorBytes4Hex, "DecryptionRequest", 4);
  const evt = {
    blockNumber: e.blockNumber,
    index: e.index,
    transactionHash: e.transactionHash,
    transactionIndex: e.transactionIndex,
    counter,
    requestID,
    handlesBytes32Hex,
    contractCallerAddress,
    callbackSelectorBytes4Hex
  };
  return evt;
}
function parseDecryptionRequestEventsFromLogs(logs) {
  if (!logs) {
    return [];
  }
  const events = [];
  for (const log of logs) {
    const event = DecryptionOraclePartialInterface.parseLog(log);
    if (!event) {
      continue;
    }
    if (!isDecryptionOracleEventName(event.name)) {
      continue;
    }
    const doe = {
      eventName: event.name,
      args: event.args,
      blockNumber: log.blockNumber,
      index: log.index,
      transactionHash: log.transactionHash,
      transactionIndex: log.transactionIndex
    };
    const e = toDecryptionRequestEvent(doe);
    if (!e) {
      continue;
    }
    events.push(e);
  }
  return events;
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/decryptionOracle/DecryptionOracleEventsHandler.js
var __classPrivateFieldSet17 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet17 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DecryptionOracleEventsHandler_db;
var _DecryptionOracleEventsHandler_kmsVerifier;
var _DecryptionOracleEventsHandler_kmsSigners;
var _DecryptionOracleEventsHandler_relayerSigner;
var DecryptionOracleEventsHandler = class {
  constructor(db, kmsVerifier, kmsSigners, relayerSigner) {
    _DecryptionOracleEventsHandler_db.set(this, void 0);
    _DecryptionOracleEventsHandler_kmsVerifier.set(this, void 0);
    _DecryptionOracleEventsHandler_kmsSigners.set(this, void 0);
    _DecryptionOracleEventsHandler_relayerSigner.set(this, void 0);
    __classPrivateFieldSet17(this, _DecryptionOracleEventsHandler_db, db, "f");
    __classPrivateFieldSet17(this, _DecryptionOracleEventsHandler_kmsVerifier, kmsVerifier, "f");
    __classPrivateFieldSet17(this, _DecryptionOracleEventsHandler_kmsSigners, kmsSigners, "f");
    __classPrivateFieldSet17(this, _DecryptionOracleEventsHandler_relayerSigner, relayerSigner, "f");
  }
  // coproc.await should have been called before
  async handleEvent(decryptionRequestEvent) {
    const clearTextsHex = [];
    const handlesBytes32Hex = [];
    for (let i = 0; i < decryptionRequestEvent.handlesBytes32Hex.length; ++i) {
      assertFhevm(decryptionRequestEvent.blockNumber >= __classPrivateFieldGet17(this, _DecryptionOracleEventsHandler_db, "f").fromBlockNumber, `Unexpected event blockNumber: decryptionRequestEvent.blockNumber < this.#db.fromBlockNumber`);
      const entry = await __classPrivateFieldGet17(this, _DecryptionOracleEventsHandler_db, "f").queryHandleBytes32(decryptionRequestEvent.handlesBytes32Hex[i]);
      assertFhevm(entry.clearTextHex !== "0x");
      clearTextsHex.push(entry.clearTextHex);
      handlesBytes32Hex.push(decryptionRequestEvent.handlesBytes32Hex[i]);
    }
    const extraDataV0 = ethers_exports.solidityPacked(["uint8"], [0]);
    const { calldata } = await computeDecryptionCallbackSignaturesAndCalldata(handlesBytes32Hex, clearTextsHex, extraDataV0, decryptionRequestEvent.requestID, decryptionRequestEvent.callbackSelectorBytes4Hex, ethers_exports.AbiCoder.defaultAbiCoder(), __classPrivateFieldGet17(this, _DecryptionOracleEventsHandler_kmsVerifier, "f"), __classPrivateFieldGet17(this, _DecryptionOracleEventsHandler_kmsSigners, "f"));
    const txData = {
      to: decryptionRequestEvent.contractCallerAddress,
      data: calldata
    };
    const tx = await __classPrivateFieldGet17(this, _DecryptionOracleEventsHandler_relayerSigner, "f").sendTransaction(txData);
    const receipt = await tx.wait();
    return { tx, receipt };
  }
};
_DecryptionOracleEventsHandler_db = /* @__PURE__ */ new WeakMap(), _DecryptionOracleEventsHandler_kmsVerifier = /* @__PURE__ */ new WeakMap(), _DecryptionOracleEventsHandler_kmsSigners = /* @__PURE__ */ new WeakMap(), _DecryptionOracleEventsHandler_relayerSigner = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/decryptionOracle/DecryptionOracleEventsIterator.js
var __classPrivateFieldSet18 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet18 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DecryptionOracleEventsIterator_cursor;
var _DecryptionOracleEventsIterator_decryptionOracleContractInterface;
var _DecryptionOracleEventsIterator_decryptionOracleContractAddress;
var _DecryptionOracleEventsIterator_readonlyProvider;
var DecryptionOracleEventsIterator = class {
  constructor(decryptionOracleContractInterface, decryptionOracleContractAddress, readonlyProvider, fromBlockNumber) {
    _DecryptionOracleEventsIterator_cursor.set(this, void 0);
    _DecryptionOracleEventsIterator_decryptionOracleContractInterface.set(this, void 0);
    _DecryptionOracleEventsIterator_decryptionOracleContractAddress.set(this, void 0);
    _DecryptionOracleEventsIterator_readonlyProvider.set(this, void 0);
    __classPrivateFieldSet18(this, _DecryptionOracleEventsIterator_decryptionOracleContractInterface, decryptionOracleContractInterface, "f");
    __classPrivateFieldSet18(this, _DecryptionOracleEventsIterator_decryptionOracleContractAddress, decryptionOracleContractAddress, "f");
    __classPrivateFieldSet18(this, _DecryptionOracleEventsIterator_readonlyProvider, readonlyProvider, "f");
    __classPrivateFieldSet18(this, _DecryptionOracleEventsIterator_cursor, new BlockLogCursor(fromBlockNumber), "f");
  }
  async next() {
    let evmHasReverted = false;
    const currentBlockNumber = await __classPrivateFieldGet18(this, _DecryptionOracleEventsIterator_readonlyProvider, "f").getBlockNumber();
    if (currentBlockNumber <= __classPrivateFieldGet18(this, _DecryptionOracleEventsIterator_cursor, "f").blockNumber) {
      evmHasReverted = true;
      __classPrivateFieldGet18(this, _DecryptionOracleEventsIterator_cursor, "f").update(currentBlockNumber - 1, 0);
    }
    const { events, cursor } = await getDecryptionOracleEvents(__classPrivateFieldGet18(this, _DecryptionOracleEventsIterator_decryptionOracleContractInterface, "f"), __classPrivateFieldGet18(this, _DecryptionOracleEventsIterator_decryptionOracleContractAddress, "f"), __classPrivateFieldGet18(this, _DecryptionOracleEventsIterator_readonlyProvider, "f"), {
      fromBlockNumber: __classPrivateFieldGet18(this, _DecryptionOracleEventsIterator_cursor, "f").nextBlockNumber,
      toBlockNumber: currentBlockNumber
    });
    if (!cursor.isEmpty) {
      __classPrivateFieldGet18(this, _DecryptionOracleEventsIterator_cursor, "f").updateForward(cursor.blockNumber, cursor.blockLogIndex);
    } else {
      assertFhevm(events.length === 0);
    }
    return { events, evmHasReverted, currentBlockNumber };
  }
};
_DecryptionOracleEventsIterator_cursor = /* @__PURE__ */ new WeakMap(), _DecryptionOracleEventsIterator_decryptionOracleContractInterface = /* @__PURE__ */ new WeakMap(), _DecryptionOracleEventsIterator_decryptionOracleContractAddress = /* @__PURE__ */ new WeakMap(), _DecryptionOracleEventsIterator_readonlyProvider = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/decryptionOracle/MockDecryptionOracle.js
var __classPrivateFieldGet19 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet19 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _MockDecryptionOracleDB_map;
var _MockDecryptionOracle_iterator;
var _MockDecryptionOracle_handler;
var _MockDecryptionOracle_readonlyProvider;
var _MockDecryptionOracle_coprocessor;
var _MockDecryptionOracle_requestDB;
var _MockDecryptionOracle_acl;
var _MockDecryptionOracle_kmsVerifier;
var _MockDecryptionOracle_kmsSigners;
var MockDecryptionOracleDB = class _MockDecryptionOracleDB {
  constructor() {
    _MockDecryptionOracleDB_map.set(this, /* @__PURE__ */ new Map());
  }
  static key(event, counterOverride) {
    return `${Number(counterOverride ?? event.counter)}}`;
  }
  tryQuery(event) {
    return __classPrivateFieldGet19(this, _MockDecryptionOracleDB_map, "f").get(_MockDecryptionOracleDB.key(event));
  }
  delete(event) {
    __classPrivateFieldGet19(this, _MockDecryptionOracleDB_map, "f").delete(_MockDecryptionOracleDB.key(event));
  }
  setPending(event, evmHasReverted) {
    if (this.has(event) && !evmHasReverted) {
      throw new FhevmError(`Decryption Request counter=${event.counter}, requestID=${event.requestID}, contractCaller=${event.contractCallerAddress} already registered`);
    }
    const entry = {
      event: {
        counter: Number(event.counter),
        requestID: Number(event.requestID),
        contractCallerAddress: event.contractCallerAddress,
        index: event.index,
        blockNumber: event.blockNumber,
        transactionHash: event.transactionHash,
        transactionIndex: event.transactionIndex
      },
      callbackBlockNumber: -1,
      callbackTransactionHash: void 0,
      callbackReverted: void 0,
      pending: true
    };
    __classPrivateFieldGet19(this, _MockDecryptionOracleDB_map, "f").set(_MockDecryptionOracleDB.key(event), entry);
    return entry;
  }
  isPending(event) {
    const entry = __classPrivateFieldGet19(this, _MockDecryptionOracleDB_map, "f").get(_MockDecryptionOracleDB.key(event));
    if (!entry) {
      return false;
    }
    return entry.pending;
  }
  executed(event) {
    const entry = __classPrivateFieldGet19(this, _MockDecryptionOracleDB_map, "f").get(_MockDecryptionOracleDB.key(event));
    if (!entry) {
      return false;
    }
    return !entry.pending;
  }
  has(event) {
    return __classPrivateFieldGet19(this, _MockDecryptionOracleDB_map, "f").has(_MockDecryptionOracleDB.key(event));
  }
};
_MockDecryptionOracleDB_map = /* @__PURE__ */ new WeakMap();
var MockDecryptionOracle = class _MockDecryptionOracle {
  constructor() {
    _MockDecryptionOracle_iterator.set(this, void 0);
    _MockDecryptionOracle_handler.set(this, void 0);
    _MockDecryptionOracle_readonlyProvider.set(this, void 0);
    _MockDecryptionOracle_coprocessor.set(this, void 0);
    _MockDecryptionOracle_requestDB.set(this, new MockDecryptionOracleDB());
    _MockDecryptionOracle_acl.set(this, void 0);
    _MockDecryptionOracle_kmsVerifier.set(this, void 0);
    _MockDecryptionOracle_kmsSigners.set(this, void 0);
  }
  static async create(readonlyProvider, params) {
    const mdo = new _MockDecryptionOracle();
    const db = params.coprocessor.getDB();
    const decryptionOracleContractItf = params.decryptionOracleContractInterface ?? DecryptionOraclePartialInterface;
    __classPrivateFieldSet19(mdo, _MockDecryptionOracle_readonlyProvider, readonlyProvider, "f");
    __classPrivateFieldSet19(mdo, _MockDecryptionOracle_coprocessor, params.coprocessor, "f");
    __classPrivateFieldSet19(mdo, _MockDecryptionOracle_iterator, new DecryptionOracleEventsIterator(decryptionOracleContractItf, params.decryptionOracleContractAddress, readonlyProvider, db.fromBlockNumber), "f");
    __classPrivateFieldSet19(mdo, _MockDecryptionOracle_kmsVerifier, await KMSVerifier.create(readonlyProvider, params.kmsVerifierContractAddress), "f");
    __classPrivateFieldSet19(mdo, _MockDecryptionOracle_acl, await ACL.create(readonlyProvider, params.aclContractAddress), "f");
    __classPrivateFieldSet19(mdo, _MockDecryptionOracle_handler, new DecryptionOracleEventsHandler(db, __classPrivateFieldGet19(mdo, _MockDecryptionOracle_kmsVerifier, "f"), params.kmsSigners, params.relayerSigner), "f");
    __classPrivateFieldSet19(mdo, _MockDecryptionOracle_kmsSigners, params.kmsSigners, "f");
    return mdo;
  }
  async createDecryptionSignatures(handlesBytes32Hex, clearTextValues, extraData) {
    assertFhevm(__classPrivateFieldGet19(this, _MockDecryptionOracle_kmsVerifier, "f") !== void 0, `MockDecryptionOracle not initialized`);
    assertFhevm(__classPrivateFieldGet19(this, _MockDecryptionOracle_kmsSigners, "f") !== void 0, `MockDecryptionOracle not initialized`);
    const res = await computeDecryptionSignatures(handlesBytes32Hex, clearTextValues, extraData, ethers_exports.AbiCoder.defaultAbiCoder(), __classPrivateFieldGet19(this, _MockDecryptionOracle_kmsVerifier, "f"), __classPrivateFieldGet19(this, _MockDecryptionOracle_kmsSigners, "f"));
    return { decryptedResult: res.decryptedResult, signatures: res.signatures };
  }
  async awaitDecryptionOracle() {
    assertFhevm(__classPrivateFieldGet19(this, _MockDecryptionOracle_coprocessor, "f") !== void 0, `MockDecryptionOracle not initialized`);
    assertFhevm(__classPrivateFieldGet19(this, _MockDecryptionOracle_iterator, "f") !== void 0, `MockDecryptionOracle not initialized`);
    assertFhevm(__classPrivateFieldGet19(this, _MockDecryptionOracle_readonlyProvider, "f") !== void 0, `MockDecryptionOracle not initialized`);
    assertFhevm(__classPrivateFieldGet19(this, _MockDecryptionOracle_acl, "f") !== void 0, `MockDecryptionOracle not initialized`);
    assertFhevm(__classPrivateFieldGet19(this, _MockDecryptionOracle_handler, "f") !== void 0, `MockDecryptionOracle not initialized`);
    await __classPrivateFieldGet19(this, _MockDecryptionOracle_coprocessor, "f").awaitCoprocessor();
    const { events, evmHasReverted } = await __classPrivateFieldGet19(this, _MockDecryptionOracle_iterator, "f").next();
    for (let i = 0; i < events.length; ++i) {
      const dre = toDecryptionRequestEvent(events[i]);
      if (!dre) {
        continue;
      }
      if (__classPrivateFieldGet19(this, _MockDecryptionOracle_requestDB, "f").isPending(dre)) {
        throw new FhevmError(`DecryptionRequest requestID=${dre.requestID}, contractCaller=${dre.contractCallerAddress} already being executed.`);
      }
      await __classPrivateFieldGet19(this, _MockDecryptionOracle_acl, "f").checkIsAllowedForDecryption(dre.handlesBytes32Hex, __classPrivateFieldGet19(this, _MockDecryptionOracle_readonlyProvider, "f"));
      const newEntry = __classPrivateFieldGet19(this, _MockDecryptionOracle_requestDB, "f").setPending(dre, evmHasReverted);
      assertFhevm(newEntry.pending);
      assertFhevm(newEntry.callbackBlockNumber === -1);
      assertFhevm(newEntry.callbackReverted === void 0);
      assertFhevm(newEntry.callbackTransactionHash === void 0);
      try {
        const { tx, receipt } = await __classPrivateFieldGet19(this, _MockDecryptionOracle_handler, "f").handleEvent(dre);
        newEntry.callbackBlockNumber = receipt == null ? void 0 : receipt.blockNumber;
        newEntry.callbackReverted = (receipt == null ? void 0 : receipt.status) === 0;
        newEntry.callbackTransactionHash = tx.hash;
        newEntry.pending = false;
      } catch (e) {
        __classPrivateFieldGet19(this, _MockDecryptionOracle_requestDB, "f").delete(dre);
        throw e;
      }
    }
  }
};
_MockDecryptionOracle_iterator = /* @__PURE__ */ new WeakMap(), _MockDecryptionOracle_handler = /* @__PURE__ */ new WeakMap(), _MockDecryptionOracle_readonlyProvider = /* @__PURE__ */ new WeakMap(), _MockDecryptionOracle_coprocessor = /* @__PURE__ */ new WeakMap(), _MockDecryptionOracle_requestDB = /* @__PURE__ */ new WeakMap(), _MockDecryptionOracle_acl = /* @__PURE__ */ new WeakMap(), _MockDecryptionOracle_kmsVerifier = /* @__PURE__ */ new WeakMap(), _MockDecryptionOracle_kmsSigners = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/relayer-sdk/sdk/keypair.js
var ML_KEM_CT_PK_LENGTH = 1568;
var ML_KEM_SK_LENGTH = 3168;
var PUBLIC_KEY_LENGTH = (ML_KEM_CT_PK_LENGTH + 8) * 2;
var PRIVATE_KEY_LENGTH = (ML_KEM_SK_LENGTH + 8) * 2;
function _verifyKeypair(keyPair) {
  keyPair.publicKey = remove0x(keyPair.publicKey);
  keyPair.privateKey = remove0x(keyPair.privateKey);
  if (!ethers_exports.isHexString("0x" + keyPair.publicKey, PUBLIC_KEY_LENGTH)) {
    throw new FhevmError(`Invalid key pair's publicKey. Call FhevmInstance.generateKeyPair() to generate a valid FHEVM key pair.`);
  }
  if (!ethers_exports.isHexString("0x" + keyPair.privateKey, PRIVATE_KEY_LENGTH)) {
    throw new FhevmError(`Invalid key pair's publicKey. Call FhevmInstance.generateKeyPair() to generate a valid FHEVM key pair.`);
  }
}
function generateKeypair() {
  const wallet = ethers_exports.Wallet.createRandom();
  const walletPublicKeyNoPrefix = remove0x(wallet.publicKey);
  const walletPrivateKeyNoPrefix = remove0x(wallet.privateKey);
  assertFhevm(walletPublicKeyNoPrefix.length === walletPrivateKeyNoPrefix.length + 2);
  const publicKeyPrefixLen = 2 * PUBLIC_KEY_LENGTH - walletPublicKeyNoPrefix.length;
  const privateKeyPrefixLen = 2 * PRIVATE_KEY_LENGTH - (2 + walletPrivateKeyNoPrefix.length);
  let n = Math.floor(publicKeyPrefixLen / 8);
  const publicKeyPrefix = "deadbeef".repeat(n) + "0".repeat(publicKeyPrefixLen - n * 8);
  n = Math.floor(privateKeyPrefixLen / 8);
  const privateKeyPrefix = "deadbeef".repeat(n) + "0".repeat(privateKeyPrefixLen - n * 8);
  const publicKey = "0x" + publicKeyPrefix + walletPublicKeyNoPrefix;
  const privateKey = "0x" + privateKeyPrefix + "00" + walletPrivateKeyNoPrefix;
  assertFhevm(publicKey.length === 2 + 2 * PUBLIC_KEY_LENGTH);
  assertFhevm(privateKey.length === 2 + 2 * PRIVATE_KEY_LENGTH);
  assertFhevm(walletPublicKeyNoPrefix.length === 66);
  assertFhevm(walletPrivateKeyNoPrefix.length === 64);
  const keypair = {
    publicKey,
    privateKey
  };
  _verifyKeypair(keypair);
  return keypair;
}
var createEIP712 = (verifyingContract, contractsChainId) => (publicKey, contractAddresses, startTimestamp, durationDays, delegatedAccount) => {
  const extraData = "0x00";
  if (delegatedAccount && !ethers_exports.isAddress(delegatedAccount))
    throw new Error("Invalid delegated account.");
  if (!ethers_exports.isAddress(verifyingContract)) {
    throw new Error("Invalid verifying contract address.");
  }
  if (!contractAddresses.every((c) => ethers_exports.isAddress(c))) {
    throw new Error("Invalid contract address.");
  }
  const formattedPublicKey = typeof publicKey === "string" ? publicKey.startsWith("0x") ? publicKey : `0x${publicKey}` : publicKey;
  const formattedStartTimestamp = typeof startTimestamp === "number" ? startTimestamp.toString() : startTimestamp;
  const formattedDurationDays = typeof durationDays === "number" ? durationDays.toString() : durationDays;
  const EIP712Domain = [
    { name: "name", type: "string" },
    { name: "version", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "verifyingContract", type: "address" }
  ];
  const domain = {
    name: "Decryption",
    version: "1",
    chainId: contractsChainId,
    verifyingContract
  };
  if (delegatedAccount) {
    return {
      types: {
        EIP712Domain,
        DelegatedUserDecryptRequestVerification: [
          { name: "publicKey", type: "bytes" },
          { name: "contractAddresses", type: "address[]" },
          { name: "contractsChainId", type: "uint256" },
          { name: "startTimestamp", type: "uint256" },
          { name: "durationDays", type: "uint256" },
          { name: "extraData", type: "bytes" },
          {
            name: "delegatedAccount",
            type: "address"
          }
        ]
      },
      primaryType: "DelegatedUserDecryptRequestVerification",
      domain,
      message: {
        publicKey: formattedPublicKey,
        contractAddresses,
        contractsChainId,
        startTimestamp: formattedStartTimestamp,
        durationDays: formattedDurationDays,
        extraData,
        delegatedAccount
      }
    };
  }
  return {
    types: {
      EIP712Domain,
      UserDecryptRequestVerification: [
        { name: "publicKey", type: "bytes" },
        { name: "contractAddresses", type: "address[]" },
        { name: "contractsChainId", type: "uint256" },
        { name: "startTimestamp", type: "uint256" },
        { name: "durationDays", type: "uint256" },
        { name: "extraData", type: "bytes" }
      ]
    },
    primaryType: "UserDecryptRequestVerification",
    domain,
    message: {
      publicKey: formattedPublicKey,
      contractAddresses,
      contractsChainId,
      startTimestamp: formattedStartTimestamp,
      durationDays: formattedDurationDays,
      extraData
    }
  };
};

// node_modules/@fhevm/mock-utils/_esm/fhevm/MockRelayerEncryptedInput.js
var __classPrivateFieldSet20 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet20 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MockRelayerEncryptedInput_clearTextValues;
var _MockRelayerEncryptedInput_fhevmTypes;
var _MockRelayerEncryptedInput_fheTypes;
var _MockRelayerEncryptedInput_totalFheBits;
var _MockRelayerEncryptedInput_contractChainId;
var _MockRelayerEncryptedInput_contractAddress;
var _MockRelayerEncryptedInput_userAddress;
var _MockRelayerEncryptedInput_relayerProvider;
var _MockRelayerEncryptedInput_aclContractAddress;
var _MockRelayerEncryptedInput_inputVerifier;
var MockRelayerEncryptedInput = class _MockRelayerEncryptedInput {
  constructor(relayerProvider, contractChainId, contractAddress, userAddress, aclContractAddress, inputVerifier) {
    _MockRelayerEncryptedInput_clearTextValues.set(this, []);
    _MockRelayerEncryptedInput_fhevmTypes.set(this, []);
    _MockRelayerEncryptedInput_fheTypes.set(this, []);
    _MockRelayerEncryptedInput_totalFheBits.set(this, 0);
    _MockRelayerEncryptedInput_contractChainId.set(this, void 0);
    _MockRelayerEncryptedInput_contractAddress.set(this, void 0);
    _MockRelayerEncryptedInput_userAddress.set(this, void 0);
    _MockRelayerEncryptedInput_relayerProvider.set(this, void 0);
    _MockRelayerEncryptedInput_aclContractAddress.set(this, void 0);
    _MockRelayerEncryptedInput_inputVerifier.set(this, void 0);
    if (BigInt(contractChainId) > MAX_UINT64) {
      throw new Error("ChainId exceeds maximum allowed value (8 bytes)");
    }
    __classPrivateFieldSet20(this, _MockRelayerEncryptedInput_relayerProvider, relayerProvider, "f");
    __classPrivateFieldSet20(this, _MockRelayerEncryptedInput_contractChainId, contractChainId, "f");
    __classPrivateFieldSet20(this, _MockRelayerEncryptedInput_contractAddress, contractAddress, "f");
    __classPrivateFieldSet20(this, _MockRelayerEncryptedInput_userAddress, userAddress, "f");
    __classPrivateFieldSet20(this, _MockRelayerEncryptedInput_aclContractAddress, aclContractAddress, "f");
    __classPrivateFieldSet20(this, _MockRelayerEncryptedInput_inputVerifier, inputVerifier, "f");
  }
  get userAddress() {
    return __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_userAddress, "f");
  }
  get contractAddress() {
    return __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_contractAddress, "f");
  }
  _checkAddFheBits(fheBitLen) {
    assertFhevm(fheBitLen >= 0);
    if (__classPrivateFieldGet20(this, _MockRelayerEncryptedInput_totalFheBits, "f") + fheBitLen > _MockRelayerEncryptedInput.MAX_FHE_BITS) {
      throw Error("Packing more than 2048 bits in a single input ciphertext is unsupported");
    }
    if (__classPrivateFieldGet20(this, _MockRelayerEncryptedInput_clearTextValues, "f").length + 1 > _MockRelayerEncryptedInput.MAX_VAR_COUNT) {
      throw Error("Packing more than 256 variables in a single input ciphertext is unsupported");
    }
  }
  _addClearTextValueFheBitsPair(clearTextValue, fhevmType) {
    const fheType = FhevmTypeToFheType(fhevmType);
    const fheBitLen = getFheTypeBitLength(fheType);
    this._checkAddFheBits(fheBitLen);
    __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_fhevmTypes, "f").push(fhevmType);
    __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_fheTypes, "f").push(fheType);
    __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_clearTextValues, "f").push(clearTextValue);
    __classPrivateFieldSet20(this, _MockRelayerEncryptedInput_totalFheBits, __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_totalFheBits, "f") + fheBitLen, "f");
    assertFhevm(__classPrivateFieldGet20(this, _MockRelayerEncryptedInput_clearTextValues, "f").length <= _MockRelayerEncryptedInput.MAX_VAR_COUNT);
    assertFhevm(__classPrivateFieldGet20(this, _MockRelayerEncryptedInput_totalFheBits, "f") <= _MockRelayerEncryptedInput.MAX_FHE_BITS);
    assertFhevm(__classPrivateFieldGet20(this, _MockRelayerEncryptedInput_clearTextValues, "f").length === __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_fheTypes, "f").length);
    assertFhevm(__classPrivateFieldGet20(this, _MockRelayerEncryptedInput_clearTextValues, "f").length === __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_fhevmTypes, "f").length);
  }
  _addBytes(clearTextValue, fhevmType) {
    assertFhevm(isFhevmEbytes(fhevmType));
    const fhevmTypeInfo = getFhevmTypeInfo(fhevmType);
    const fheBitLen = getFheTypeBitLength(fhevmTypeInfo.fheType);
    const clearTextBitLen = fhevmTypeInfo.clearTextBitLength;
    assertFhevm(clearTextBitLen === fheBitLen);
    assertFhevm(fheBitLen % 8 === 0);
    const fheByteLen = fheBitLen / 8;
    if (clearTextValue.length > fheByteLen) {
      throw new FhevmError(`Uncorrect length of input Uint8Array, should be ${fheByteLen} for an ${fhevmTypeInfo.name}`);
    }
    const clearTextValueBigInt = ethers_exports.toBigInt(clearTextValue);
    const maxClearTextValueBigInt = getMaxBigInt(clearTextBitLen);
    assertFhevm(clearTextValue.length * 8 === fheBitLen);
    assertFhevm(clearTextValueBigInt <= maxClearTextValueBigInt);
    this._addClearTextValueFheBitsPair(clearTextValueBigInt, fhevmType);
    return this;
  }
  _addUint(clearTextValue, fhevmzType) {
    assertFhevm(isFhevmEuint(fhevmzType));
    const fhevmTypeInfo = getFhevmTypeInfo(fhevmzType);
    const clearTextBitLen = fhevmTypeInfo.clearTextBitLength;
    if (clearTextValue < 0) {
      throw new FhevmError(`Invalid unsigned integer value ${clearTextValue}`);
    }
    const clearTextValueBigInt = BigInt(clearTextValue);
    const maxClearTextValueBigInt = getMaxBigInt(clearTextBitLen);
    if (clearTextValueBigInt > maxClearTextValueBigInt) {
      throw new FhevmError(`Invalid ${fhevmTypeInfo.solidityTypeName} value: ${clearTextValue}, it exceeds the maximum allowed value of ${maxClearTextValueBigInt}.`);
    }
    this._addClearTextValueFheBitsPair(clearTextValueBigInt, fhevmzType);
    return this;
  }
  // Accepts : 0, 1, true, false
  addBool(value) {
    const zeroOrOneBigInt = boolToBigInt(value);
    this._addClearTextValueFheBitsPair(zeroOrOneBigInt, FhevmType.ebool);
    return this;
  }
  add8(value) {
    return this._addUint(value, FhevmType.euint8);
  }
  add16(value) {
    return this._addUint(value, FhevmType.euint16);
  }
  add32(value) {
    return this._addUint(value, FhevmType.euint32);
  }
  add64(value) {
    return this._addUint(value, FhevmType.euint64);
  }
  add128(value) {
    return this._addUint(value, FhevmType.euint128);
  }
  addAddress(value) {
    if (!ethers_exports.isAddress(value)) {
      throw new Error("Invalid address value: ${value}.");
    }
    const clearTextValue = ethers_exports.getAddress(value);
    this._addClearTextValueFheBitsPair(clearTextValue, FhevmType.eaddress);
    return this;
  }
  add256(value) {
    return this._addUint(value, FhevmType.euint256);
  }
  addBytes64(value) {
    return this._addBytes(value, FhevmType.ebytes64);
  }
  addBytes128(value) {
    return this._addBytes(value, FhevmType.ebytes128);
  }
  addBytes256(value) {
    return this._addBytes(value, FhevmType.ebytes256);
  }
  _toMockFhevmRelayerV1InputProofPayload(extraData) {
    const numHandles = __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_clearTextValues, "f").length;
    const clearTextValuesBigIntHex = [];
    const clearTextValuesBigInt = [];
    const rand32BufferList = [];
    const metadatas = [];
    for (let i = 0; i < numHandles; ++i) {
      const clearTextValueBigInt = BigInt(__classPrivateFieldGet20(this, _MockRelayerEncryptedInput_clearTextValues, "f")[i]);
      clearTextValuesBigInt.push(clearTextValueBigInt);
      clearTextValuesBigIntHex.push(ethers_exports.toBeHex(clearTextValueBigInt));
      rand32BufferList.push(ethers_exports.randomBytes(32));
      metadatas.push({
        blockNumber: 0,
        index: 0,
        transactionHash: ethers_exports.ZeroHash
      });
    }
    const mockCiphertextWithInputVerification = _MockRelayerEncryptedInput._computeMockCiphertextWithZKProof(clearTextValuesBigInt, __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_fheTypes, "f"), rand32BufferList);
    const mockData = {
      clearTextValuesBigIntHex,
      metadatas,
      fheTypes: __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_fheTypes, "f"),
      fhevmTypes: __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_fhevmTypes, "f"),
      aclContractAddress: __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_aclContractAddress, "f"),
      random32List: rand32BufferList.map(ethers_exports.hexlify)
    };
    const mockPayload = {
      contractAddress: __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_contractAddress, "f"),
      userAddress: __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_userAddress, "f"),
      ciphertextWithInputVerification: ethers_exports.hexlify(mockCiphertextWithInputVerification),
      contractChainId: "0x" + __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_contractChainId, "f").toString(16),
      extraData,
      mockData
    };
    return mockPayload;
  }
  static _computeMockCiphertextWithZKProof(clearTextValuesBigInt, fheTypes, rand32BufferList) {
    let encrypted = new Uint8Array(0);
    const numHandles = clearTextValuesBigInt.length;
    assertFhevm(rand32BufferList.length === numHandles);
    assertFhevm(fheTypes.length === numHandles);
    for (let i = 0; i < numHandles; ++i) {
      const clearTextValueBigInt = clearTextValuesBigInt[i];
      const fheByteLen = getFheTypeByteLength(fheTypes[i]);
      const fheType1Byte = new Uint8Array([fheTypes[i]]);
      const clearTextValueXXBytes = uintToBytes(clearTextValueBigInt, fheByteLen);
      const rand32Buffer = rand32BufferList[i];
      encrypted = concatBytes(encrypted, fheType1Byte, clearTextValueXXBytes, rand32Buffer);
    }
    return ethers_exports.getBytes(ethers_exports.keccak256(encrypted));
  }
  async encrypt() {
    const extraData = "0x00";
    const payload = this._toMockFhevmRelayerV1InputProofPayload(extraData);
    const mockCiphertextWithZKProof = ethers_exports.getBytes(payload.ciphertextWithInputVerification);
    const response = await requestRelayerV1InputProof(__classPrivateFieldGet20(this, _MockRelayerEncryptedInput_relayerProvider, "f"), payload);
    const handlesBytes32List = FhevmHandle.computeHandles(mockCiphertextWithZKProof, __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_fhevmTypes, "f"), __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_aclContractAddress, "f"), __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_contractChainId, "f"), constants_default.FHEVM_HANDLE_VERSION);
    __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_inputVerifier, "f").verifySignatures(handlesBytes32List, __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_userAddress, "f"), __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_contractAddress, "f"), __classPrivateFieldGet20(this, _MockRelayerEncryptedInput_contractChainId, "f"), extraData, response.signatures);
    const inputProofHex = computeInputProofHex(response.handles, response.signatures, extraData);
    return {
      handles: handlesBytes32List,
      inputProof: ethers_exports.toBeArray(inputProofHex)
    };
  }
  getBits() {
    throw new FhevmError("ZKInput interface method: Not supported in mock mode");
  }
};
_MockRelayerEncryptedInput_clearTextValues = /* @__PURE__ */ new WeakMap(), _MockRelayerEncryptedInput_fhevmTypes = /* @__PURE__ */ new WeakMap(), _MockRelayerEncryptedInput_fheTypes = /* @__PURE__ */ new WeakMap(), _MockRelayerEncryptedInput_totalFheBits = /* @__PURE__ */ new WeakMap(), _MockRelayerEncryptedInput_contractChainId = /* @__PURE__ */ new WeakMap(), _MockRelayerEncryptedInput_contractAddress = /* @__PURE__ */ new WeakMap(), _MockRelayerEncryptedInput_userAddress = /* @__PURE__ */ new WeakMap(), _MockRelayerEncryptedInput_relayerProvider = /* @__PURE__ */ new WeakMap(), _MockRelayerEncryptedInput_aclContractAddress = /* @__PURE__ */ new WeakMap(), _MockRelayerEncryptedInput_inputVerifier = /* @__PURE__ */ new WeakMap();
Object.defineProperty(MockRelayerEncryptedInput, "MAX_FHE_BITS", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 2048
});
Object.defineProperty(MockRelayerEncryptedInput, "MAX_VAR_COUNT", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 256
});

// node_modules/@fhevm/mock-utils/_esm/relayer-sdk/relayer/decryptUtils.js
var NumEncryptedBits = {
  0: 2,
  // ebool
  2: 8,
  // euint8
  3: 16,
  // euint16
  4: 32,
  // euint32
  5: 64,
  // euint64
  6: 128,
  // euint128
  7: 160,
  // eaddress
  8: 256
  // euint256
};
function checkEncryptedBits(handles) {
  let total = 0;
  for (const handle of handles) {
    if (handle.length !== 66) {
      throw new Error(`Handle ${handle} is not of valid length`);
    }
    const hexPair = handle.slice(-4, -2).toLowerCase();
    const typeDiscriminant = parseInt(hexPair, 16);
    if (!(typeDiscriminant in NumEncryptedBits)) {
      throw new Error(`Handle ${handle} is not of valid type`);
    }
    total += NumEncryptedBits[typeDiscriminant];
    if (total > 2048) {
      throw new Error("Cannot decrypt more than 2048 encrypted bits in a single request");
    }
  }
  return total;
}

// node_modules/@fhevm/mock-utils/_esm/relayer-sdk/relayer/publicDecrypt.js
var CiphertextType = {
  0: "bool",
  2: "uint256",
  3: "uint256",
  4: "uint256",
  5: "uint256",
  6: "uint256",
  7: "address",
  8: "uint256"
};
function deserializeDecryptedResult(handles, decryptedResult) {
  let typesList = [];
  for (const handle of handles) {
    const hexPair = handle.slice(-4, -2).toLowerCase();
    const typeDiscriminant = parseInt(hexPair, 16);
    typesList.push(typeDiscriminant);
  }
  const restoredEncoded = "0x" + "00".repeat(32) + // dummy requestID (ignored)
  decryptedResult.slice(2) + "00".repeat(32);
  const abiTypes = typesList.map((t) => {
    const abiType = CiphertextType[t];
    return abiType;
  });
  const coder = new ethers_exports.AbiCoder();
  const decoded = coder.decode(["uint256", ...abiTypes, "bytes[]"], restoredEncoded);
  const rawValues = decoded.slice(1, 1 + typesList.length);
  let results = {};
  handles.forEach((handle, idx) => results[handle] = rawValues[idx]);
  return results;
}

// node_modules/@fhevm/mock-utils/_esm/relayer-sdk/relayer/userDecrypt.js
var MAX_USER_DECRYPT_CONTRACT_ADDRESSES = 10;
var MAX_USER_DECRYPT_DURATION_DAYS = 365n;
function checkDeadlineValidity(startTimestamp, durationDays) {
  if (durationDays === BigInt(0)) {
    throw new FhevmError("durationDays is null");
  }
  if (durationDays > MAX_USER_DECRYPT_DURATION_DAYS) {
    throw new FhevmError(`durationDays is above max duration of ${MAX_USER_DECRYPT_DURATION_DAYS}`);
  }
  const currentTimestamp = BigInt(Math.floor(Date.now() / 1e3));
  if (startTimestamp > currentTimestamp) {
    throw new FhevmError("startTimestamp is set in the future");
  }
  const durationInSeconds = durationDays * BigInt(86400);
  if (startTimestamp + durationInSeconds < currentTimestamp) {
    throw new FhevmError("User decrypt request has expired");
  }
}
function formatAccordingToType(decryptedBigInt, type) {
  if (type === 0) {
    return decryptedBigInt === BigInt(1);
  } else if (type === 7) {
    return ethers_exports.getAddress("0x" + decryptedBigInt.toString(16).padStart(40, "0"));
  } else if (type === 9) {
    return "0x" + decryptedBigInt.toString(16).padStart(128, "0");
  } else if (type === 10) {
    return "0x" + decryptedBigInt.toString(16).padStart(256, "0");
  } else if (type === 11) {
    return "0x" + decryptedBigInt.toString(16).padStart(512, "0");
  }
  return decryptedBigInt;
}
function buildUserDecryptedResult(handles, listBigIntDecryptions) {
  let typesList = [];
  for (const handle of handles) {
    const hexPair = handle.slice(-4, -2).toLowerCase();
    const typeDiscriminant = parseInt(hexPair, 16);
    typesList.push(typeDiscriminant);
  }
  let results = {};
  handles.forEach((handle, idx) => results[handle] = formatAccordingToType(listBigIntDecryptions[idx], typesList[idx]));
  return results;
}
function checkMaxContractAddresses(contractAddresses) {
  const contractAddressesLength = contractAddresses.length;
  if (contractAddressesLength === 0) {
    throw new FhevmError("contractAddresses is empty");
  }
  if (contractAddressesLength > MAX_USER_DECRYPT_CONTRACT_ADDRESSES) {
    throw new FhevmError(`contractAddresses max length of ${MAX_USER_DECRYPT_CONTRACT_ADDRESSES} exceeded`);
  }
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/MockFhevmInstance.js
var __classPrivateFieldSet21 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet21 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MockFhevmInstance_relayerProvider;
var _MockFhevmInstance_readonlyEthersProvider;
var _MockFhevmInstance_chainId;
var _MockFhevmInstance_gatewayChainId;
var _MockFhevmInstance_verifyingContractAddressInputVerification;
var _MockFhevmInstance_verifyingContractAddressDecryption;
var _MockFhevmInstance_contractsChainId;
var _MockFhevmInstance_aclContractAddress;
var _MockFhevmInstance_kmsVerifier;
var _MockFhevmInstance_inputVerifier;
var _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc;
var MockFhevmInstance = class _MockFhevmInstance {
  constructor(config, extra) {
    _MockFhevmInstance_relayerProvider.set(this, void 0);
    _MockFhevmInstance_readonlyEthersProvider.set(this, void 0);
    _MockFhevmInstance_chainId.set(this, void 0);
    _MockFhevmInstance_gatewayChainId.set(this, void 0);
    _MockFhevmInstance_verifyingContractAddressInputVerification.set(this, void 0);
    _MockFhevmInstance_verifyingContractAddressDecryption.set(this, void 0);
    _MockFhevmInstance_contractsChainId.set(this, void 0);
    _MockFhevmInstance_aclContractAddress.set(this, void 0);
    _MockFhevmInstance_kmsVerifier.set(this, void 0);
    _MockFhevmInstance_inputVerifier.set(this, void 0);
    _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc.set(this, void 0);
    assertIsAddress(config.verifyingContractAddressInputVerification, "config.verifyingContractAddressInputVerification");
    assertIsAddress(config.verifyingContractAddressDecryption, "config.verifyingContractAddressDecryption");
    assertIsNumber(config.gatewayChainId, "config.gatewayChainId");
    __classPrivateFieldSet21(this, _MockFhevmInstance_relayerProvider, extra.relayerProvider, "f");
    __classPrivateFieldSet21(this, _MockFhevmInstance_readonlyEthersProvider, extra.readonlyEthersProvider, "f");
    __classPrivateFieldSet21(this, _MockFhevmInstance_chainId, config.chainId, "f");
    __classPrivateFieldSet21(this, _MockFhevmInstance_gatewayChainId, config.gatewayChainId, "f");
    __classPrivateFieldSet21(this, _MockFhevmInstance_verifyingContractAddressInputVerification, config.verifyingContractAddressInputVerification, "f");
    __classPrivateFieldSet21(this, _MockFhevmInstance_verifyingContractAddressDecryption, config.verifyingContractAddressDecryption, "f");
    __classPrivateFieldSet21(this, _MockFhevmInstance_contractsChainId, config.chainId, "f");
    __classPrivateFieldSet21(this, _MockFhevmInstance_aclContractAddress, config.aclContractAddress, "f");
    __classPrivateFieldSet21(this, _MockFhevmInstance_kmsVerifier, extra.kmsVerifier, "f");
    __classPrivateFieldSet21(this, _MockFhevmInstance_inputVerifier, extra.inputVerifier, "f");
    __classPrivateFieldSet21(this, _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc, createEIP712(__classPrivateFieldGet21(this, _MockFhevmInstance_verifyingContractAddressDecryption, "f"), __classPrivateFieldGet21(this, _MockFhevmInstance_contractsChainId, "f")), "f");
  }
  get chainId() {
    return __classPrivateFieldGet21(this, _MockFhevmInstance_chainId, "f");
  }
  static async create(relayerProvider, readonlyEthersProvider, config) {
    const kmsVerifier = await KMSVerifier.create(readonlyEthersProvider, config.kmsContractAddress);
    const inputVerifier = await InputVerifier.create(readonlyEthersProvider, config.inputVerifierContractAddress);
    const instance = new _MockFhevmInstance(config, {
      relayerProvider,
      readonlyEthersProvider,
      inputVerifier,
      kmsVerifier
    });
    return instance;
  }
  static createEIP712(publicKey, contractAddresses, startTimestamp, durationDays, verifyingContractAddressDecryption, contractsChainId) {
    assertIsAddressArray(contractAddresses, "contractAddresses");
    const eip712Func = createEIP712(verifyingContractAddressDecryption, contractsChainId);
    const eip712 = eip712Func(publicKey, contractAddresses, startTimestamp, durationDays);
    assertFhevm(eip712.domain.version === constants_default.PUBLIC_DECRYPT_EIP712.domain.version.toString());
    assertFhevm(eip712.domain.name === constants_default.PUBLIC_DECRYPT_EIP712.domain.name);
    return eip712;
  }
  // Create EIP712 for decryption
  createEIP712(publicKey, contractAddresses, startTimestamp, durationDays) {
    assertIsAddressArray(contractAddresses, "contractAddresses");
    const eip712 = __classPrivateFieldGet21(this, _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc, "f").call(this, publicKey, contractAddresses, startTimestamp, durationDays);
    assertFhevm(BigInt(__classPrivateFieldGet21(this, _MockFhevmInstance_gatewayChainId, "f")) === __classPrivateFieldGet21(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.chainId);
    assertFhevm(eip712.domain.verifyingContract === __classPrivateFieldGet21(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.verifyingContract);
    assertFhevm(eip712.domain.version === __classPrivateFieldGet21(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.version);
    assertFhevm(eip712.domain.name === __classPrivateFieldGet21(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.name);
    assertFhevm(BigInt(eip712.domain.chainId) === BigInt(__classPrivateFieldGet21(this, _MockFhevmInstance_contractsChainId, "f")));
    return eip712;
  }
  createEncryptedInput(contractAddress, userAddress) {
    assertFhevm(__classPrivateFieldGet21(this, _MockFhevmInstance_verifyingContractAddressInputVerification, "f") === __classPrivateFieldGet21(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.verifyingContract);
    assertFhevm(BigInt(__classPrivateFieldGet21(this, _MockFhevmInstance_gatewayChainId, "f")) === __classPrivateFieldGet21(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.chainId);
    return new MockRelayerEncryptedInput(__classPrivateFieldGet21(this, _MockFhevmInstance_relayerProvider, "f"), __classPrivateFieldGet21(this, _MockFhevmInstance_chainId, "f"), contractAddress, userAddress, __classPrivateFieldGet21(this, _MockFhevmInstance_aclContractAddress, "f"), __classPrivateFieldGet21(this, _MockFhevmInstance_inputVerifier, "f"));
  }
  generateKeypair() {
    return generateKeypair();
  }
  getPublicKey() {
    throw new FhevmError("Not supported in mock mode");
  }
  getPublicParams(_bits) {
    throw new FhevmError("Not supported in mock mode");
  }
  async publicDecrypt(handles) {
    const extraData = "0x00";
    for (let i = 0; i < handles.length; ++i) {
      assertFhevm(typeof handles[i] === "string" || handles[i] instanceof Uint8Array, "handle is not a string or a Uint8Array");
    }
    const relayerHandles = handles.map((h) => typeof h === "string" ? toHexString(fromHexString(h)) : toHexString(h));
    checkEncryptedBits(relayerHandles);
    await _MockFhevmInstance.verifyPublicACLPermissions(__classPrivateFieldGet21(this, _MockFhevmInstance_readonlyEthersProvider, "f"), __classPrivateFieldGet21(this, _MockFhevmInstance_aclContractAddress, "f"), relayerHandles);
    const payloadForRequest = {
      ciphertextHandles: relayerHandles,
      extraData
    };
    const json = await requestRelayerV1PublicDecrypt(__classPrivateFieldGet21(this, _MockFhevmInstance_relayerProvider, "f"), payloadForRequest);
    const result = json.response[0];
    const decryptedResult = ensure0x(result.decrypted_value);
    const signatures = result.signatures.map(ensure0x);
    const domain = {
      name: constants_default.PUBLIC_DECRYPT_EIP712.domain.name,
      version: constants_default.PUBLIC_DECRYPT_EIP712.domain.version,
      chainId: __classPrivateFieldGet21(this, _MockFhevmInstance_gatewayChainId, "f"),
      verifyingContract: __classPrivateFieldGet21(this, _MockFhevmInstance_verifyingContractAddressDecryption, "f")
    };
    const types = constants_default.PUBLIC_DECRYPT_EIP712.types;
    const signedExtraData = "0x00";
    const recoveredAddresses = signatures.map((signature) => {
      assertFhevm(signature.startsWith("0x"));
      const recoveredAddress = ethers_exports.verifyTypedData(domain, types, { ctHandles: handles, decryptedResult, extraData: signedExtraData }, signature);
      return recoveredAddress;
    });
    const thresholdReached = isThresholdReached(__classPrivateFieldGet21(this, _MockFhevmInstance_kmsVerifier, "f").getKmsSignersAddresses(), recoveredAddresses, __classPrivateFieldGet21(this, _MockFhevmInstance_kmsVerifier, "f").getThreshold(), "KMS");
    if (!thresholdReached) {
      throw Error("KMS signers threshold is not reached");
    }
    const results = deserializeDecryptedResult(relayerHandles, decryptedResult);
    return results;
  }
  async userDecrypt(handles, _privateKey, publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays) {
    const extraData = "0x00";
    for (let i = 0; i < handles.length; ++i) {
      assertFhevm(typeof handles[i].handle === "string" || handles[i].handle instanceof Uint8Array, "handle is not a string or a Uint8Array");
    }
    const relayerHandles = handles.map((h) => ({
      handle: typeof h.handle === "string" ? toHexString(fromHexString(h.handle)) : toHexString(h.handle),
      contractAddress: h.contractAddress
    }));
    checkEncryptedBits(relayerHandles.map((h) => h.handle));
    checkDeadlineValidity(BigInt(startTimestamp), BigInt(durationDays));
    await _MockFhevmInstance.verifyUserACLPermissions(__classPrivateFieldGet21(this, _MockFhevmInstance_readonlyEthersProvider, "f"), __classPrivateFieldGet21(this, _MockFhevmInstance_aclContractAddress, "f"), relayerHandles, userAddress);
    checkMaxContractAddresses(contractAddresses);
    _MockFhevmInstance.verifyHandleContractAddresses(relayerHandles, contractAddresses);
    await _MockFhevmInstance.verifyUserDecryptSignature(publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays, __classPrivateFieldGet21(this, _MockFhevmInstance_verifyingContractAddressDecryption, "f"), __classPrivateFieldGet21(this, _MockFhevmInstance_contractsChainId, "f"));
    const payloadForRequest = {
      handleContractPairs: relayerHandles,
      requestValidity: {
        startTimestamp: startTimestamp.toString(),
        // Convert to string
        durationDays: durationDays.toString()
        // Convert to string
      },
      contractsChainId: __classPrivateFieldGet21(this, _MockFhevmInstance_chainId, "f").toString(),
      // Convert to string
      contractAddresses: contractAddresses.map((c) => ethers_exports.getAddress(c)),
      userAddress: ethers_exports.getAddress(userAddress),
      signature: remove0x(signature),
      publicKey: remove0x(publicKey),
      extraData
    };
    const json = await requestRelayerV1UserDecrypt(__classPrivateFieldGet21(this, _MockFhevmInstance_relayerProvider, "f"), payloadForRequest);
    const result = json.response[0];
    const clearTextHexList = result.payload.decrypted_values;
    const listBigIntDecryptions = clearTextHexList.map(ethers_exports.toBigInt);
    const results = buildUserDecryptedResult(relayerHandles.map((h) => h.handle), listBigIntDecryptions);
    return results;
  }
  // Static function called by:
  // - MockFhevmInstance.userDecrypt()
  // - packages/hardhat-plugin/src/internal/provider/FhevmProviderExtender._handleFhevmRelayerV1UserDecrypt()
  static async verifyUserDecryptSignature(publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays, verifyingContractAddressDecryption, contractsChainId) {
    publicKey = ensure0x(publicKey);
    signature = ensure0x(signature);
    const eip712 = _MockFhevmInstance.createEIP712(publicKey, contractAddresses, startTimestamp, durationDays, verifyingContractAddressDecryption, contractsChainId);
    const types = {};
    types[eip712.primaryType] = eip712.types[eip712.primaryType];
    const signerAddress = ethers_exports.verifyTypedData(eip712.domain, types, eip712.message, signature);
    const normalizedSignerAddress = ethers_exports.getAddress(signerAddress);
    const normalizedUserAddress = ethers_exports.getAddress(userAddress);
    if (normalizedSignerAddress !== normalizedUserAddress) {
      throw new FhevmError("Invalid EIP-712 signature!");
    }
  }
  static async verifyPublicACLPermissions(readonlyEthersProvider, aclContractAddress, handles) {
    const aclABI = ["function isAllowedForDecryption(bytes32 handle) view returns (bool)"];
    const acl = new ethers_exports.Contract(aclContractAddress, aclABI, readonlyEthersProvider);
    const verifications = handles.map(async (h) => {
      const ctHandleHex = ethers_exports.toBeHex(ethers_exports.toBigInt(h), 32);
      const allowed = await acl.isAllowedForDecryption(ctHandleHex);
      if (!allowed) {
        throw new FhevmError(`Handle ${h} is not allowed for public decryption!`);
      }
    });
    return Promise.all(verifications).catch((e) => {
      throw e;
    });
  }
  // (Duplicated code) Should be imported from @zama-fhe/relayer-sdk
  static async verifyUserACLPermissions(readonlyEthersProvider, aclContractAddress, handles, userAddress) {
    const aclABI = ["function persistAllowed(bytes32 handle, address account) view returns (bool)"];
    const acl = new ethers_exports.Contract(aclContractAddress, aclABI, readonlyEthersProvider);
    const verifications = handles.map(async ({ handle, contractAddress }) => {
      const ctHandleHex = ethers_exports.toBeHex(ethers_exports.toBigInt(handle), 32);
      const userAllowed = await acl.persistAllowed(ctHandleHex, userAddress);
      const contractAllowed = await acl.persistAllowed(ctHandleHex, contractAddress);
      if (!userAllowed) {
        throw new FhevmError(`User ${userAddress} is not authorized to user decrypt handle ${handle}!`);
      }
      if (!contractAllowed) {
        throw new FhevmError(`dapp contract ${contractAddress} is not authorized to user decrypt handle ${handle}!`);
      }
      if (userAddress === contractAddress) {
        throw new FhevmError(`userAddress ${userAddress} should not be equal to contractAddress when requesting decryption!`);
      }
    });
    return Promise.all(verifications).catch((e) => {
      throw e;
    });
  }
  static verifyHandleContractAddresses(handles, contractAddresses) {
    const set = /* @__PURE__ */ new Set();
    for (let i = 0; i < contractAddresses.length; ++i) {
      const add = contractAddresses[i].toLowerCase();
      if (!set.has(add)) {
        set.add(add);
      }
    }
    for (let i = 0; i < handles.length; ++i) {
      if (!set.has(handles[i].contractAddress.toLowerCase())) {
        throw new FhevmError(`Contract address ${handles[i].contractAddress} associated to handle ${handles[i].handle} is not listed in the contractAddresses array argument.`);
      }
    }
  }
};
_MockFhevmInstance_relayerProvider = /* @__PURE__ */ new WeakMap(), _MockFhevmInstance_readonlyEthersProvider = /* @__PURE__ */ new WeakMap(), _MockFhevmInstance_chainId = /* @__PURE__ */ new WeakMap(), _MockFhevmInstance_gatewayChainId = /* @__PURE__ */ new WeakMap(), _MockFhevmInstance_verifyingContractAddressInputVerification = /* @__PURE__ */ new WeakMap(), _MockFhevmInstance_verifyingContractAddressDecryption = /* @__PURE__ */ new WeakMap(), _MockFhevmInstance_contractsChainId = /* @__PURE__ */ new WeakMap(), _MockFhevmInstance_aclContractAddress = /* @__PURE__ */ new WeakMap(), _MockFhevmInstance_kmsVerifier = /* @__PURE__ */ new WeakMap(), _MockFhevmInstance_inputVerifier = /* @__PURE__ */ new WeakMap(), _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc = /* @__PURE__ */ new WeakMap();

// node_modules/@fhevm/mock-utils/_esm/fhevm/userDecrypt.js
async function userDecryptHandleBytes32(instance, handleContractPairs, user, options) {
  _assertIsContractAddressesArray(handleContractPairs);
  const userDecryptArgs = await _resolveUserDecryptOptions(instance, options);
  const chainId = _getFhevmInstanceChainId(instance);
  _verifyFhevmHandleContractPairs(handleContractPairs, chainId);
  const { signature, contractAddresses } = await _computeUserSignatureAndContractAddresses(instance, handleContractPairs, user, userDecryptArgs);
  const userAddress = await user.getAddress();
  const handles = handleContractPairs.map((p) => {
    return { handle: p.handleBytes32, contractAddress: p.contractAddress };
  });
  const decryptedHandles = await instance.userDecrypt(handles, userDecryptArgs.keypair.privateKey, userDecryptArgs.keypair.publicKey, signature, contractAddresses, userAddress, userDecryptArgs.startTimestamp, userDecryptArgs.durationDays);
  return decryptedHandles;
}
async function _resolveUserDecryptOptions(instance, options) {
  var _a, _b;
  let keypair;
  if ((options == null ? void 0 : options.keypair) !== void 0) {
    keypair = { ...options.keypair };
    verifyKeypair(keypair);
  } else {
    keypair = instance.generateKeypair();
  }
  const startTimestamp = ((_a = options == null ? void 0 : options.validity) == null ? void 0 : _a.startTimestamp) || timestampNow();
  const durationDays = ((_b = options == null ? void 0 : options.validity) == null ? void 0 : _b.durationDays) || constants_default.DEFAULT_DURATION_DAYS;
  const startTimestampNumber = toUIntNumber(startTimestamp, "startTimeStamp");
  const durationDaysNumber = toUIntNumber(durationDays, "durationDays");
  return {
    keypair,
    startTimestamp: startTimestampNumber,
    durationDays: durationDaysNumber
  };
}
async function _computeUserSignatureAndContractAddresses(instance, contractAddresses, user, userDecryptArgs) {
  if (contractAddresses.length === 0) {
    throw new FhevmError("Empty list of contract addresses.");
  }
  const contractAddressesSortUnique = _buildDeterministicContractAddressesList(contractAddresses);
  if (contractAddressesSortUnique.length === 0) {
    throw new FhevmError("Empty list of valid contract addresses.");
  }
  const eip712 = instance.createEIP712(userDecryptArgs.keypair.publicKey, contractAddressesSortUnique, userDecryptArgs.startTimestamp, userDecryptArgs.durationDays);
  const signature = await user.signTypedData(eip712.domain, { UserDecryptRequestVerification: eip712.types.UserDecryptRequestVerification }, eip712.message);
  return {
    signature,
    contractAddresses: contractAddressesSortUnique
  };
}
function _getFhevmInstanceChainId(instance) {
  const dummyEIP712 = instance.createEIP712("", [ethers_exports.ZeroAddress], 0, 0);
  return dummyEIP712.message.contractsChainId;
}
function _buildDeterministicContractAddressesList(contractAddresses) {
  const set = /* @__PURE__ */ new Set();
  for (let i = 0; i < contractAddresses.length; ++i) {
    const ca = contractAddresses[i];
    let contractAddress;
    if (typeof ca === "string") {
      contractAddress = ca;
    } else {
      contractAddress = ca.contractAddress;
    }
    const add = ethers_exports.getAddress(contractAddress);
    if (!set.has(add)) {
      set.add(add);
    }
  }
  return [...set].sort((a, b) => {
    const addrA = a.toLowerCase();
    const addrB = b.toLowerCase();
    if (addrA < addrB) {
      return -1;
    }
    if (addrA > addrB) {
      return 1;
    }
    return 0;
  });
}
function _assertIsContractAddressesArray(contractAddresses) {
  if (contractAddresses.length === 0) {
    throw new FhevmError("Empty list of contract addresses.");
  }
  for (let i = 0; i < contractAddresses.length; ++i) {
    const ca = contractAddresses[i];
    let contractAddress;
    if (typeof ca === "string") {
      contractAddress = ca;
    } else {
      contractAddress = ca.contractAddress;
    }
    assertIsAddress(contractAddress, "contractAddress");
  }
}
function _verifyFhevmHandleContractPairs(handleContractPairs, chainId) {
  if (handleContractPairs.length === 0) {
    throw new FhevmError("Empty list of handle/contract pairs.");
  }
  for (let i = 0; i < handleContractPairs.length; ++i) {
    const pair = handleContractPairs[i];
    FhevmHandle.verify(pair.handleBytes32, {
      ...pair.fhevmType !== void 0 && { fhevmType: pair.fhevmType },
      ...chainId !== void 0 && { chainId }
    });
    assertIsAddress(pair.contractAddress, "contractAddress");
  }
}

// node_modules/@fhevm/mock-utils/_esm/ethers/storage.js
function computeStorageLocation(storageName) {
  const enc = ethers_exports.AbiCoder.defaultAbiCoder().encode(["uint256"], [BigInt(ethers_exports.keccak256(ethers_exports.toUtf8Bytes(storageName))) - 1n]);
  return ethers_exports.toBeHex(BigInt(ethers_exports.keccak256(enc)) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00n, 32);
}
async function getStorageAt(provider, address, index) {
  assertIsAddress(address);
  const indexParam = ethers_exports.toBeHex(index, 32);
  const data = await minimalProviderSend(provider, "eth_getStorageAt", [address, indexParam, "latest"]);
  assertIsBytes32String(data);
  return data;
}
async function setStorageAt(provider, methodName, address, index, valueBytes32) {
  assertIsAddress(address);
  assertIsBytes32String(valueBytes32);
  if (methodName !== "hardhat_setStorageAt") {
    throw new FhevmError(`Only hardhat_setStorageAt is supported. Got ${methodName} instead.`);
  }
  const indexParam = ethers_exports.toBeHex(index, 32);
  await minimalProviderSend(provider, methodName, [address, indexParam, valueBytes32]);
}
async function getAddressesFromStorage(provider, contractAddress, storageLocationBytes32, numAddresses) {
  const addresses = [];
  for (let i = 0; i < numAddresses; ++i) {
    const addr = await getStorageAt(provider, contractAddress, BigInt(storageLocationBytes32) + BigInt(i));
    addresses.push(addr);
  }
  const errorMsg = `The contract at address ${contractAddress} has not been initialized properly.`;
  for (let i = 0; i < numAddresses; ++i) {
    const addr = addresses[i];
    if (typeof addr !== "string" || !ethers_exports.isBytesLike(addr) || addr.length !== 66) {
      throw new FhevmError(errorMsg);
    }
    const hex = ethers_exports.toBeHex(BigInt(addr), 20);
    try {
      addresses[i] = ethers_exports.getAddress(hex);
    } catch {
      throw new FhevmError(errorMsg);
    }
  }
  return addresses;
}
async function getInitializableStorage(provider, contractAddress) {
  const storageLocationBytes32 = computeStorageLocation("openzeppelin.storage.Initializable");
  assertFhevm(storageLocationBytes32 === "0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00", "Wrong 'openzeppelin.storage.Initializable' storage location");
  let data = await getStorageAt(provider, contractAddress, BigInt(storageLocationBytes32) + BigInt(0));
  data = data.replace(/^0x/, "").padStart(64, "0");
  const initializedHex = "0x" + data.slice(-16);
  const initialized = BigInt(initializedHex);
  const initializingByte = parseInt(data.slice(-18, -16), 16);
  const initializing = initializingByte !== 0;
  return { initialized, initializing };
}
async function setInitializableStorage(provider, contractAddress, value) {
  const storageLocationBytes32 = computeStorageLocation("openzeppelin.storage.Initializable");
  assertFhevm(storageLocationBytes32 === "0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00", "Wrong 'openzeppelin.storage.Initializable' storage location");
  const initializedBytes = ethers_exports.toBeHex(value.initialized, 8);
  const initializingByte = value.initializing ? "0x01" : "0x00";
  const packedHex = initializingByte + initializedBytes.slice(2);
  const paddedSlotValue = ethers_exports.zeroPadValue(packedHex, 32);
  await setStorageAt(provider, "hardhat_setStorageAt", contractAddress, BigInt(storageLocationBytes32) + BigInt(0), paddedSlotValue);
}
async function setOwnableStorage(provider, contractAddress, ownerAddress) {
  const storageLocationBytes32 = computeStorageLocation("openzeppelin.storage.Ownable");
  assertFhevm(storageLocationBytes32 === "0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300", "Wrong 'openzeppelin.storage.Ownable' storage location");
  const paddedSlotValue = ethers_exports.zeroPadValue(ownerAddress, 32);
  await setStorageAt(provider, "hardhat_setStorageAt", contractAddress, BigInt(storageLocationBytes32) + BigInt(0), paddedSlotValue);
}

// node_modules/@fhevm/mock-utils/_esm/fhevm/CoprocessorConfig.js
async function getCoprocessorConfig(provider, contractAddress) {
  const coprocessorConfigStorageLocation = computeStorageLocation("confidential.storage.config");
  assertFhevm(coprocessorConfigStorageLocation === "0x9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700");
  const addresses = await getAddressesFromStorage(
    provider,
    contractAddress,
    coprocessorConfigStorageLocation,
    4
    /* number of addresses in the struct */
  );
  return {
    ACLAddress: addresses[0],
    CoprocessorAddress: addresses[1],
    DecryptionOracleAddress: addresses[2],
    KMSVerifierAddress: addresses[3]
  };
}

// node_modules/@fhevm/mock-utils/_esm/_version.js
var version = "0.1.0";
export {
  FhevmDBMap,
  FhevmHandle,
  FhevmHandleCoder,
  FhevmMockProvider,
  FhevmMockProviderType,
  FhevmType,
  MockCoprocessor,
  MockDecryptionOracle,
  MockFhevmInstance,
  MockRelayerEncryptedInput,
  assertIsEIP712Domain,
  connectedChainId,
  constants_default as constants,
  contracts_exports as contracts,
  getCoprocessorConfig,
  getFhevmTypeInfo,
  getInitializableStorage,
  isAnvilProvider,
  isFhevmEaddress,
  isFhevmEbool,
  isFhevmEbytes,
  isFhevmEuint,
  isHardhatProvider,
  minimalProviderSend,
  parseCoprocessorEventsFromLogs,
  parseDecryptionRequestEventsFromLogs,
  relayer_exports as relayer,
  setInitializableStorage,
  setOwnableStorage,
  tryParseFhevmType,
  userDecryptHandleBytes32,
  utils_exports as utils,
  version
};
//# sourceMappingURL=@fhevm_mock-utils.js.map
